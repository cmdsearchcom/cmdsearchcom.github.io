<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>QEMU.1(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">QEMU.1(1)</td>
    <td class="head-vol"> </td>
    <td class="head-rtitle">QEMU.1(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
qemu-doc - QEMU Emulator User Documentation
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>qemu-system-i386</b> [<i>options</i>] [<i>disk_image</i>]
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The QEMU PC System emulator simulates the following peripherals:
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">i440FX host PCI bridge and PIIX3 PCI to ISA bridge</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Cirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs
      VESA extensions (hardware level, including all non standard modes).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">PS/2 mouse and keyboard</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">2 PCI IDE interfaces with hard disk and CD-ROM support</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Floppy disk</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">PCI and ISA network adapters</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Serial ports</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">IPMI BMC, either and internal or external one</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Creative SoundBlaster 16 sound card</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">ENSONIQ AudioPCI ES1370 sound card</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Intel 82801AA AC97 Audio compatible sound card</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Intel HD Audio Controller and HDA codec</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Adlib (OPL2) - Yamaha YM3812 compatible chip</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">Gravis Ultrasound GF1 sound card</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">CS4231A compatible sound card</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">-</dt>
  <dd class="It-tag">PCI UHCI USB controller and a virtual USB hub.</dd>
</dl>
<div class="Pp"></div>
SMP is supported with up to 255 CPUs.
<div class="Pp"></div>
QEMU uses the PC BIOS from the Seabios project and the Plex86/Bochs LGPL VGA
  BIOS.
<div class="Pp"></div>
QEMU uses YM3812 emulation by Tatsuyuki Satoh.
<div class="Pp"></div>
QEMU uses GUS emulation (GUSEMU32 &lt;
  <b>http://www.deinmeister.de/gusemu/</b>&gt;) by Tibor &quot;TS&quot;
  Sch&#x00FC;tz.
<div class="Pp"></div>
Note that, by default, GUS shares <i>IRQ</i>(7) with parallel ports and so QEMU
  must be told to not have parallel ports to have working GUS.
<div class="Pp"></div>
<pre>
        qemu-system-i386 dos.img -soundhw gus -parallel none
</pre>
<div class="Pp"></div>
Alternatively:
<div class="Pp"></div>
<pre>
        qemu-system-i386 dos.img -device gus,irq=5
</pre>
<div class="Pp"></div>
Or some other unclaimed IRQ.
<div class="Pp"></div>
CS4231A is the chip used in Windows Sound System and GUSMAX products
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
<i>disk_image</i> is a raw hard disk image for IDE hard disk 0. Some targets do
  not need a disk image.
<div class="Pp"></div>
<i>Standard options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b></dt>
  <dd class="It-tag">Display help and exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-version</b></dt>
  <dd class="It-tag">Display version information and exit</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-machine
    [type=]</b><i>name</i><b>[,prop=</b><i>value</i> <b>[,...]]</b></dt>
  <dd class="It-tag">Select the emulated machine by <i>name</i>. Use
      &quot;-machine help&quot; to list available machines. Supported machine
      properties are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>accel=</b><i>accels1</i><b>[:</b><i>accels2</i><b>[:...]]</b></dt>
  <dd class="It-tag">This is used to enable an accelerator. Depending on the
      target architecture, kvm, xen, or tcg can be available. By default, tcg is
      used. If there is more than one accelerator specified, the next one is
      used if the previous one fails to initialize.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>kernel_irqchip=on|off</b></dt>
  <dd class="It-tag">Controls in-kernel irqchip support for the chosen
      accelerator when available.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gfx_passthru=on|off</b></dt>
  <dd class="It-tag">Enables IGD GFX passthrough support for the chosen machine
      when available.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vmport=on|off|auto</b></dt>
  <dd class="It-tag">Enables emulation of VMWare IO port, for vmmouse etc. auto
      says to select the value based on accel. For accel=xen the default is off
      otherwise the default is on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>kvm_shadow_mem=size</b></dt>
  <dd class="It-tag">Defines the size of the KVM shadow MMU.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dump-guest-core=on|off</b></dt>
  <dd class="It-tag">Include guest memory in a core dump. The default is
    on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mem-merge=on|off</b></dt>
  <dd class="It-tag">Enables or disables memory merge support. This feature,
      when supported by the host, de-duplicates identical memory pages among VMs
      instances (enabled by default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aes-key-wrap=on|off</b></dt>
  <dd class="It-tag">Enables or disables AES key wrapping support on s390-ccw
      hosts. This feature controls whether AES wrapping keys will be created to
      allow execution of AES cryptographic functions. The default is on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dea-key-wrap=on|off</b></dt>
  <dd class="It-tag">Enables or disables DEA key wrapping support on s390-ccw
      hosts. This feature controls whether DEA wrapping keys will be created to
      allow execution of DEA cryptographic functions. The default is on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>nvdimm=on|off</b></dt>
  <dd class="It-tag">Enables or disables NVDIMM support. The default is
    off.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-cpu</b> <i>model</i></dt>
  <dd class="It-tag">Select CPU model (&quot;-cpu help&quot; for list and
      additional feature selection)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-accel</b>
    <i>name</i><b>[,prop=</b><i>value</i><b>[,...]]</b></dt>
  <dd class="It-tag">This is used to enable an accelerator. Depending on the
      target architecture, kvm, xen, or tcg can be available. By default, tcg is
      used. If there is more than one accelerator specified, the next one is
      used if the previous one fails to initialize.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>thread=single|multi</b></dt>
  <dd class="It-tag">Controls number of TCG threads. When the TCG is
      multi-threaded there will be one thread per vCPU therefor taking advantage
      of additional host cores. The default is to enable multi-threading where
      both the back-end and front-ends support it and no incompatible TCG
      features have been enabled (e.g. icount/replay).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smp
    [cpus=]</b><i>n</i><b>[,cores=</b><i>cores</i><b>][,threads=</b>
    <i>threads</i>
    <b>][,sockets=</b><i>sockets</i><b>][,maxcpus=</b><i>maxcpus</i>
    <b>]</b></dt>
  <dd class="It-tag">Simulate an SMP system with <i>n</i> CPUs. On the PC
      target, up to 255 CPUs are supported. On Sparc32 target, Linux limits the
      number of usable CPUs to 4. For the PC target, the number of <i>cores</i>
      per socket, the number of <i>threads</i> per cores and the total number of
      <i>sockets</i> can be specified. Missing values will be computed. If any
      on the three values is given, the total number of CPUs <i>n</i> can be
      omitted. <i>maxcpus</i> specifies the maximum number of hotpluggable
    CPUs.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-numa
    node[,mem=</b><i>size</i><b>][,cpus=</b><i>firstcpu</i>
    <b>[-</b><i>lastcpu</i> <b>]][,nodeid=</b><i>node</i><b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-numa
    node[,memdev=</b><i>id</i><b>][,cpus=</b><i>firstcpu</i>
    <b>[-</b><i>lastcpu</i> <b>]][,nodeid=</b><i>node</i><b>]</b></dt>
  <dd class="It-tag">Define a NUMA node and assign RAM and VCPUs to it.
    <div style="height: 1.00em;">&#x00A0;</div>
     <i>firstcpu</i> and <i>lastcpu</i> are CPU indexes. Each <b>cpus</b> option
      represent a contiguous range of CPU indexes (or a single VCPU if
      <i>lastcpu</i> is omitted). A non-contiguous set of VCPUs can be
      represented by providing multiple <b>cpus</b> options. If <b>cpus</b> is
      omitted on all nodes, VCPUs are automatically split between them.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, the following option assigns VCPUs 0, 1, 2 and 5 to a NUMA
      node:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -numa node,cpus=0-2,cpus=5
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>mem</b> assigns a given RAM amount to a node. <b>memdev</b> assigns RAM
      from a given memory backend device to a node. If <b>mem</b> and
      <b>memdev</b> are omitted in all nodes, RAM is split equally between them.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>mem</b> and <b>memdev</b> are mutually exclusive. Furthermore, if one
      node uses <b>memdev</b>, all of them have to use it.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the - <b>numa</b> option doesn't allocate any of the specified
      resources, it just assigns existing resources to NUMA nodes. This means
      that one still has to use the <b>-m</b>, <b>-smp</b> options to allocate
      RAM and VCPUs respectively.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-add-fd
    fd=</b><i>fd</i><b>,set=</b><i>set</i><b>[,opaque=</b>
    <i>opaque</i><b>]</b></dt>
  <dd class="It-tag">Add a file descriptor to an fd set. Valid options are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>fd=</b><i>fd</i></dt>
  <dd class="It-tag">This option defines the file descriptor of which a
      duplicate is added to fd set. The file descriptor cannot be stdin, stdout,
      or stderr.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>set=</b><i>set</i></dt>
  <dd class="It-tag">This option defines the ID of the fd set to add the file
      descriptor to.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>opaque=</b><i>opaque</i></dt>
  <dd class="It-tag">This option defines a free-form string that can be used to
      describe <i>fd</i>.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
You can open an image using pre-opened file descriptors from an fd set:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386
        -add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
        -add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
        -drive file=/dev/fdset/2,index=0,media=disk
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-set</b>
    <i>group</i><b>.</b><i>id</i><b>.</b><i>arg</i><b>=</b><i>value</i></dt>
  <dd class="It-tag">Set parameter <i>arg</i> for item <i>id</i> of type
      <i>group</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-global</b>
    <i>driver</i><b>.</b><i>prop</i><b>=</b><i>value</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-global
    driver=</b><i>driver</i><b>,property=</b><i>property</i>
    <b>,value=</b><i>value</i></dt>
  <dd class="It-tag">Set default value of <i>driver</i>'s property <i>prop</i>
      to <i>value</i>, e.g.:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 -global ide-drive.physical_block_size=4096 -drive file=file,if=ide,index=0,media=disk
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    In particular, you can use this to set driver properties for devices which
      are created automatically by the machine model. To create a device which
      is not created automatically and set properties on it, use -
      <b>device</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    -global <i>driver</i>.<i>prop</i>=<i>value</i> is shorthand for -global
      driver= <i>driver</i>,property=<i>prop</i>,value=<i>value</i>. The
      longhand syntax works even when <i>driver</i> contains a dot.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-boot
    [order=</b><i>drives</i><b>][,once=</b><i>drives</i>
    <b>][,menu=on|off][,splash=</b>
    <i>sp_name</i><b>][,splash-time=</b><i>sp_time</i>
    <b>][,reboot-timeout=</b><i>rb_timeout</i><b>][,strict=on|off]</b></dt>
  <dd class="It-tag">Specify boot order <i>drives</i> as a string of drive
      letters. Valid drive letters depend on the target architecture. The x86 PC
      uses: a, b (floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p
      (Etherboot from network adapter 1-4), hard disk boot is the default. To
      apply a particular boot order only on the first startup, specify it via
      <b>once</b>. Note that the <b>order</b> or <b>once</b> parameter should
      not be used together with the <b>bootindex</b> property of devices, since
      the firmware implementations normally do not support both at the same
      time.
    <div style="height: 1.00em;">&#x00A0;</div>
    Interactive boot menus/prompts can be enabled via <b>menu=on</b> as far as
      firmware/BIOS supports them. The default is non-interactive boot.
    <div style="height: 1.00em;">&#x00A0;</div>
    A splash picture could be passed to bios, enabling user to show it as logo,
      when option splash= <i>sp_name</i> is given and menu=on, If firmware/BIOS
      supports them. Currently Seabios for X86 system support it. limitation:
      The splash file could be a jpeg file or a BMP file in 24 BPP format(true
      color). The resolution should be supported by the SVGA mode, so the
      recommended is 320x240, 640x480, 800x640.
    <div style="height: 1.00em;">&#x00A0;</div>
    A timeout could be passed to bios, guest will pause for <i>rb_timeout</i> ms
      when boot failed, then reboot. If <i>rb_timeout</i> is '-1', guest will
      not reboot, qemu passes '-1' to bios by default. Currently Seabios for X86
      system support it.
    <div style="height: 1.00em;">&#x00A0;</div>
    Do strict boot via <b>strict=on</b> as far as firmware/BIOS supports it.
      This only effects when boot priority is changed by bootindex options. The
      default is non-strict boot.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # try to boot from network first, then from hard disk
        qemu-system-i386 -boot order=nc
        # boot from CD-ROM first, switch back to default order after reboot
        qemu-system-i386 -boot once=d
        # boot with a splash picture for 5 seconds.
        qemu-system-i386 -boot menu=on,splash=/root/boot.bmp,splash-time=5000
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note: The legacy format '-boot <i>drives</i>' is still supported but its use
      is discouraged as it may be removed from future versions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-m
    [size=]</b><i>megs</i><b>[,slots=n,maxmem=size]</b></dt>
  <dd class="It-tag">Sets guest startup RAM size to <i>megs</i> megabytes.
      Default is 128 MiB. Optionally, a suffix of &quot;M&quot; or &quot;G&quot;
      can be used to signify a value in megabytes or gigabytes respectively.
      Optional pair <i>slots</i>, <i>maxmem</i> could be used to set amount of
      hotpluggable memory slots and maximum amount of memory. Note that
      <i>maxmem</i> must be aligned to the page size.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, the following command-line sets the guest startup RAM size to
      1GB, creates 3 slots to hotplug additional memory and sets the maximum
      memory the guest can reach to 4GB:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-x86_64 -m 1G,slots=3,maxmem=4G
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>slots</i> and <i>maxmem</i> are not specified, memory hotplug won't be
      enabled and the guest startup RAM will never increase.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-mem-path</b> <i>path</i></dt>
  <dd class="It-tag">Allocate guest RAM from a temporarily created file in
      <i>path</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-mem-prealloc</b></dt>
  <dd class="It-tag">Preallocate memory when using -mem-path.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-k</b> <i>language</i></dt>
  <dd class="It-tag">Use keyboard layout <i>language</i> (for example
      &quot;fr&quot; for French). This option is only needed where it is not
      easy to get raw PC keycodes (e.g. on Macs, with some X11 servers or with a
      VNC or curses display). You don't normally need to use it on PC/Linux or
      PC/Windows hosts.
    <div style="height: 1.00em;">&#x00A0;</div>
    The available layouts are:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
        da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
        de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The default is &quot;en-us&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-audio-help</b></dt>
  <dd class="It-tag">Will show the audio subsystem help: list of drivers,
      tunable parameters.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-soundhw</b> <i>card1</i><b>[,</b><i>card2</i><b>,...]
    or -soundhw all</b></dt>
  <dd class="It-tag">Enable audio and selected sound hardware. Use 'help' to
      print all available sound hardware.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 -soundhw sb16,adlib disk.img
        qemu-system-i386 -soundhw es1370 disk.img
        qemu-system-i386 -soundhw ac97 disk.img
        qemu-system-i386 -soundhw hda disk.img
        qemu-system-i386 -soundhw all disk.img
        qemu-system-i386 -soundhw help
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that Linux's i810_audio OSS kernel (for AC97) module might require
      manually specifying clocking.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        modprobe i810_audio clocking=48000
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-balloon none</b></dt>
  <dd class="It-tag">Disable balloon device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-balloon virtio[,addr=</b><i>addr</i><b>]</b></dt>
  <dd class="It-tag">Enable virtio balloon device (default), optionally with PCI
      address <i>addr</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-device</b>
    <i>driver</i><b>[,</b><i>prop</i><b>[=</b><i>value</i><b>][,...]]</b></dt>
  <dd class="It-tag">Add device <i>driver</i>. <i>prop</i>=<i>value</i> sets
      driver properties. Valid properties depend on the driver. To get help on
      possible drivers and properties, use &quot;-device help&quot; and
      &quot;-device <i>driver</i>,help&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some drivers are:</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-device
    ipmi-bmc-sim,id=</b><i>id</i><b>[,slave_addr=</b> <i>val</i><b>]</b></dt>
  <dd class="It-tag">Add an IPMI BMC. This is a simulation of a hardware
      management interface processor that normally sits on a system. It provides
      a watchdog and the ability to reset and power control the system. You need
      to connect this to an IPMI interface to make it useful
    <div style="height: 1.00em;">&#x00A0;</div>
    The IPMI slave address to use for the BMC. The default is 0x20. This address
      is the BMC's address on the I2C network of management controllers. If you
      don't know what this means, it is safe to ignore it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-device
    ipmi-bmc-extern,id=</b><i>id</i><b>,chardev=</b><i>id</i><b>[,slave_addr=</b><i>val</i><b>]</b></dt>
  <dd class="It-tag">Add a connection to an external IPMI BMC simulator. Instead
      of locally emulating the BMC like the above item, instead connect to an
      external entity that provides the IPMI services.
    <div style="height: 1.00em;">&#x00A0;</div>
    A connection is made to an external BMC simulator. If you do this, it is
      strongly recommended that you use the &quot;reconnect=&quot; chardev
      option to reconnect to the simulator if the connection is lost. Note that
      if this is not used carefully, it can be a security issue, as the
      interface has the ability to send resets, NMIs, and power off the VM. It's
      best if QEMU makes a connection to an external simulator running on a
      secure port on localhost, so neither the simulator nor QEMU is exposed to
      any outside network.
    <div style="height: 1.00em;">&#x00A0;</div>
    See the &quot;lanserv/README.vm&quot; file in the OpenIPMI library for more
      details on the external interface.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-device
    isa-ipmi-kcs,bmc=</b><i>id</i><b>[,ioport=</b><i>val</i><b>][,irq=</b><i>val</i><b>]</b></dt>
  <dd class="It-tag">Add a KCS IPMI interafce on the ISA bus. This also adds a
      corresponding ACPI and SMBIOS entries, if appropriate.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>bmc=</b><i>id</i></dt>
  <dd class="It-tag">The BMC to connect to, one of ipmi-bmc-sim or
      ipmi-bmc-extern above.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ioport=</b><i>val</i></dt>
  <dd class="It-tag">Define the I/O address of the interface. The default is
      0xca0 for KCS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>irq=</b><i>val</i></dt>
  <dd class="It-tag">Define the interrupt to use. The default is 5. To disable
      interrupts, set this to 0.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-device
    isa-ipmi-bt,bmc=</b><i>id</i><b>[,ioport=</b><i>val</i>
    <b>][,irq=</b><i>val</i> <b>]</b></dt>
  <dd class="It-tag">Like the KCS interface, but defines a BT interface. The
      default port is 0xe4 and the default interrupt is 5.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-name</b> <i>name</i></dt>
  <dd class="It-tag">Sets the <i>name</i> of the guest. This name will be
      displayed in the SDL window caption. The <i>name</i> will also be used for
      the VNC server. Also optionally set the top visible process name in Linux.
      Naming of individual threads can also be enabled on Linux to aid
      debugging.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-uuid</b> <i>uuid</i></dt>
  <dd class="It-tag">Set system UUID.</dd>
</dl>
<div class="Pp"></div>
<i>Block device options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fda</b> <i>file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fdb</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as floppy disk 0/1 image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hda</b> <i>file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hdb</b> <i>file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hdc</b> <i>file</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hdd</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as hard disk 0, 1, 2 or 3 image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-cdrom</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as CD-ROM image (you cannot use <b>-hdc</b>
      and <b>-cdrom</b> at the same time). You can use the host CD-ROM by using
      <i>/dev/cdrom</i> as filename.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-drive</b>
    <i>option</i><b>[,</b><i>option</i><b>[,</b><i>option</i><b>[,...]]]</b></dt>
  <dd class="It-tag">Define a new drive. Valid options are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>file=</b><i>file</i></dt>
  <dd class="It-tag">This option defines which disk image to use with this
      drive. If the filename contains comma, you must double it (for instance,
      &quot;file=my,,file&quot; to use file &quot;my,file&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    Special files such as iSCSI devices can be specified using protocol specific
      URLs. See the section for &quot;Device URL Syntax&quot; for more
      information.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>if=</b><i>interface</i></dt>
  <dd class="It-tag">This option defines on which type on interface the drive is
      connected. Available types are: ide, scsi, sd, mtd, floppy, pflash,
      virtio.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bus=</b><i>bus</i><b>,unit=</b><i>unit</i></dt>
  <dd class="It-tag">These options define where is connected the drive by
      defining the bus number and the unit id.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>index=</b><i>index</i></dt>
  <dd class="It-tag">This option defines where is connected the drive by using
      an index in the list of available connectors of a given interface
    type.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>media=</b><i>media</i></dt>
  <dd class="It-tag">This option defines the type of the media: disk or
    cdrom.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cyls=</b><i>c</i><b>,heads=</b><i>h</i><b>,secs=</b><i>s</i><b>[,trans=</b><i>t</i><b>]</b></dt>
  <dd class="It-tag">These options have the same definition as they have in
      <b>-hdachs</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>snapshot=</b><i>snapshot</i></dt>
  <dd class="It-tag"><i>snapshot</i> is &quot;on&quot; or &quot;off&quot; and
      controls snapshot mode for the given drive (see <b>-snapshot</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cache=</b><i>cache</i></dt>
  <dd class="It-tag"><i>cache</i> is &quot;none&quot;, &quot;writeback&quot;,
      &quot;unsafe&quot;, &quot;directsync&quot; or &quot;writethrough&quot; and
      controls how the host cache is used to access block data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>aio=</b><i>aio</i></dt>
  <dd class="It-tag"><i>aio</i> is &quot;threads&quot;, or &quot;native&quot;
      and selects between pthread based disk I/O and native Linux AIO.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>discard=</b><i>discard</i></dt>
  <dd class="It-tag"><i>discard</i> is one of &quot;ignore&quot; (or
      &quot;off&quot;) or &quot;unmap&quot; (or &quot;on&quot;) and controls
      whether <i>discard</i> (also known as <i>trim</i> or <i>unmap</i>)
      requests are ignored or passed to the filesystem. Some machine types may
      not support discard requests.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>format=</b><i>format</i></dt>
  <dd class="It-tag">Specify which disk <i>format</i> will be used rather than
      detecting the format. Can be used to specify format=raw to avoid
      interpreting an untrusted format header.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>serial=</b><i>serial</i></dt>
  <dd class="It-tag">This option specifies the serial number to assign to the
      device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>addr=</b><i>addr</i></dt>
  <dd class="It-tag">Specify the controller's PCI address (if=virtio only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>werror=</b><i>action</i><b>,rerror=</b><i>action</i></dt>
  <dd class="It-tag">Specify which <i>action</i> to take on write and read
      errors. Valid actions are: &quot;ignore&quot; (ignore the error and try to
      continue), &quot;stop&quot; (pause QEMU), &quot;report&quot; (report the
      error to the guest), &quot;enospc&quot; (pause QEMU only if the host disk
      is full; report the error to the guest otherwise). The default setting is
      <b>werror=enospc</b> and <b>rerror=report</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readonly</b></dt>
  <dd class="It-tag">Open drive <b>file</b> as read-only. Guest write attempts
      will fail.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>copy-on-read=</b><i>copy-on-read</i></dt>
  <dd class="It-tag"><i>copy-on-read</i> is &quot;on&quot; or &quot;off&quot;
      and enables whether to copy read backing file sectors into the image
    file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>detect-zeroes=</b><i>detect-zeroes</i></dt>
  <dd class="It-tag"><i>detect-zeroes</i> is &quot;off&quot;, &quot;on&quot; or
      &quot;unmap&quot; and enables the automatic conversion of plain zero
      writes by the OS to driver specific optimized zero write commands. You may
      even choose &quot;unmap&quot; if <i>discard</i> is set to
      &quot;unmap&quot; to allow a zero write to be converted to an UNMAP
      operation.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
By default, the <b>cache=writeback</b> mode is used. It will report data writes
  as completed as soon as the data is present in the host page cache. This is
  safe as long as your guest OS makes sure to correctly flush disk caches where
  needed. If your guest OS does not handle volatile disk write caches correctly
  and your host crashes or loses power, then the guest may experience data
  corruption.
<div style="height: 1.00em;">&#x00A0;</div>
For such guests, you should consider using <b>cache=writethrough</b>. This means
  that the host page cache will be used to read and write data, but write
  notification will be sent to the guest only after QEMU has made sure to flush
  each write to the disk. Be aware that this has a major impact on performance.
<div style="height: 1.00em;">&#x00A0;</div>
The host page cache can be avoided entirely with <b>cache=none</b>. This will
  attempt to do disk IO directly to the guest's memory. QEMU may still perform
  an internal copy of the data. Note that this is considered a writeback mode
  and the guest OS must handle the disk write cache correctly in order to avoid
  data corruption on host crashes.
<div style="height: 1.00em;">&#x00A0;</div>
The host page cache can be avoided while only sending write notifications to the
  guest when the data has been flushed to the disk using
  <b>cache=directsync</b>.
<div style="height: 1.00em;">&#x00A0;</div>
In case you don't care about data integrity over host failures, use
  <b>cache=unsafe</b>. This option tells QEMU that it never needs to write any
  data to the disk but can instead keep things in cache. If anything goes wrong,
  like your host losing power, the disk storage getting disconnected
  accidentally, etc. your image will most probably be rendered unusable. When
  using the <b>-snapshot</b> option, unsafe caching is always used.
<div style="height: 1.00em;">&#x00A0;</div>
Copy-on-read avoids accessing the same backing file sectors repeatedly and is
  useful when the backing file is over a slow network. By default copy-on-read
  is off.
<div style="height: 1.00em;">&#x00A0;</div>
Instead of <b>-cdrom</b> you can use:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -drive file=file,index=2,media=cdrom
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Instead of <b>-hda</b>, <b>-hdb</b>, <b>-hdc</b>, <b>-hdd</b>, you can use:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -drive file=file,index=0,media=disk
        qemu-system-i386 -drive file=file,index=1,media=disk
        qemu-system-i386 -drive file=file,index=2,media=disk
        qemu-system-i386 -drive file=file,index=3,media=disk
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
You can open an image using pre-opened file descriptors from an fd set:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386
        -add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
        -add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
        -drive file=/dev/fdset/2,index=0,media=disk
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
You can connect a CDROM to the slave of ide0:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -drive file=file,if=ide,index=1,media=cdrom
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
If you don't specify the &quot;file=&quot; argument, you define an empty drive:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -drive if=ide,index=1,media=cdrom
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Instead of <b>-fda</b>, <b>-fdb</b>, you can use:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -drive file=file,index=0,if=floppy
        qemu-system-i386 -drive file=file,index=1,if=floppy
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
By default, <i>interface</i> is &quot;ide&quot; and <i>index</i> is
  automatically incremented:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -drive file=a -drive file=b&quot;
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
is interpreted like:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 -hda a -hdb b
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-mtdblock</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as on-board Flash memory image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sd</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as SecureDigital card image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-pflash</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as a parallel flash image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-snapshot</b></dt>
  <dd class="It-tag">Write to temporary files instead of disk image files. In
      this case, the raw disk image you use is not written back. You can however
      force the write back by pressing <b>C-a s</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-hdachs</b>
    <i>c</i><b>,</b><i>h</i><b>,</b><i>s</i><b>,[,</b> <i>t</i><b>]</b></dt>
  <dd class="It-tag">Force hard disk 0 physical geometry (1 &lt;= <i>c</i> &lt;=
      16383, 1 &lt;= <i>h</i> &lt;= 16, 1 &lt;= <i>s</i> &lt;= 63) and
      optionally force the BIOS translation mode ( <i>t</i>=none, lba or auto).
      Usually QEMU can guess all those parameters. This option is useful for old
      MS-DOS disk images.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fsdev</b>
    <i>fsdriver</i><b>,id=</b><i>id</i><b>,path=</b>
    <i>path</i><b>,[security_model=</b>
    <i>security_model</i><b>][,writeout=</b><i>writeout</i><b>][,readonly][,socket=</b><i>socket</i><b>|sock_fd=</b><i>sock_fd</i><b>]</b></dt>
  <dd class="It-tag">Define a new file system device. Valid options are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>fsdriver</i></dt>
  <dd class="It-tag">This option specifies the fs driver backend to use.
      Currently &quot;local&quot;, &quot;handle&quot; and &quot;proxy&quot; file
      system drivers are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>id=</b><i>id</i></dt>
  <dd class="It-tag">Specifies identifier for this device</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>path=</b><i>path</i></dt>
  <dd class="It-tag">Specifies the export path for the file system device. Files
      under this path will be available to the 9p client on the guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>security_model=</b><i>security_model</i></dt>
  <dd class="It-tag">Specifies the security model to be used for this export
      path. Supported security models are &quot;passthrough&quot;,
      &quot;mapped-xattr&quot;, &quot;mapped-file&quot; and &quot;none&quot;. In
      &quot;passthrough&quot; security model, files are stored using the same
      credentials as they are created on the guest. This requires QEMU to run as
      root. In &quot;mapped-xattr&quot; security model, some of the file
      attributes like uid, gid, mode bits and link target are stored as file
      attributes. For &quot;mapped-file&quot; these attributes are stored in the
      hidden .virtfs_metadata directory. Directories exported by this security
      model cannot interact with other unix tools. &quot;none&quot; security
      model is same as passthrough except the sever won't report failures if it
      fails to set file attributes like ownership. Security model is mandatory
      only for local fsdriver. Other fsdrivers (like handle, proxy) don't take
      security model as a parameter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>writeout=</b><i>writeout</i></dt>
  <dd class="It-tag">This is an optional argument. The only supported value is
      &quot;immediate&quot;. This means that host page cache will be used to
      read and write data but write notification will be sent to the guest only
      when the data has been reported as written by the storage subsystem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readonly</b></dt>
  <dd class="It-tag">Enables exporting 9p share as a readonly mount for guests.
      By default read-write access is given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>socket=</b><i>socket</i></dt>
  <dd class="It-tag">Enables proxy filesystem driver to use passed socket file
      for communicating with virtfs-proxy-helper</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sock_fd=</b><i>sock_fd</i></dt>
  <dd class="It-tag">Enables proxy filesystem driver to use passed socket
      descriptor for communicating with virtfs-proxy-helper. Usually a helper
      like libvirt will create socketpair and pass one of the fds as
    sock_fd</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
-fsdev option is used along with -device driver &quot;virtio-9p-pci&quot;.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-device
    virtio-9p-pci,fsdev=</b><i>id</i><b>,mount_tag=</b> <i>mount_tag</i></dt>
  <dd class="It-tag">Options for virtio-9p-pci driver are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>fsdev=</b><i>id</i></dt>
  <dd class="It-tag">Specifies the id value specified along with -fsdev
    option</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mount_tag=</b><i>mount_tag</i></dt>
  <dd class="It-tag">Specifies the tag name to be used by the guest to mount
      this export point</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-virtfs</b>
    <i>fsdriver</i><b>[,path=</b><i>path</i><b>],mount_tag=</b>
    <i>mount_tag</i><b>[,security_model=</b><i>security_model</i><b>][,writeout=</b><i>writeout</i><b>][,readonly][,socket=</b><i>socket</i><b>|sock_fd=</b><i>sock_fd</i><b>]</b></dt>
  <dd class="It-tag">The general form of a Virtual File system pass-through
      options are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>fsdriver</i></dt>
  <dd class="It-tag">This option specifies the fs driver backend to use.
      Currently &quot;local&quot;, &quot;handle&quot; and &quot;proxy&quot; file
      system drivers are supported.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>id=</b><i>id</i></dt>
  <dd class="It-tag">Specifies identifier for this device</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>path=</b><i>path</i></dt>
  <dd class="It-tag">Specifies the export path for the file system device. Files
      under this path will be available to the 9p client on the guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>security_model=</b><i>security_model</i></dt>
  <dd class="It-tag">Specifies the security model to be used for this export
      path. Supported security models are &quot;passthrough&quot;,
      &quot;mapped-xattr&quot;, &quot;mapped-file&quot; and &quot;none&quot;. In
      &quot;passthrough&quot; security model, files are stored using the same
      credentials as they are created on the guest. This requires QEMU to run as
      root. In &quot;mapped-xattr&quot; security model, some of the file
      attributes like uid, gid, mode bits and link target are stored as file
      attributes. For &quot;mapped-file&quot; these attributes are stored in the
      hidden .virtfs_metadata directory. Directories exported by this security
      model cannot interact with other unix tools. &quot;none&quot; security
      model is same as passthrough except the sever won't report failures if it
      fails to set file attributes like ownership. Security model is mandatory
      only for local fsdriver. Other fsdrivers (like handle, proxy) don't take
      security model as a parameter.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>writeout=</b><i>writeout</i></dt>
  <dd class="It-tag">This is an optional argument. The only supported value is
      &quot;immediate&quot;. This means that host page cache will be used to
      read and write data but write notification will be sent to the guest only
      when the data has been reported as written by the storage subsystem.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readonly</b></dt>
  <dd class="It-tag">Enables exporting 9p share as a readonly mount for guests.
      By default read-write access is given.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>socket=</b><i>socket</i></dt>
  <dd class="It-tag">Enables proxy filesystem driver to use passed socket file
      for communicating with virtfs-proxy-helper. Usually a helper like libvirt
      will create socketpair and pass one of the fds as sock_fd</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sock_fd</b></dt>
  <dd class="It-tag">Enables proxy filesystem driver to use passed 'sock_fd' as
      the socket descriptor for interfacing with virtfs-proxy-helper</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-virtfs_synth</b></dt>
  <dd class="It-tag">Create synthetic file system image</dd>
</dl>
<div class="Pp"></div>
<i>USB options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-usb</b></dt>
  <dd class="It-tag">Enable the USB driver (will be the default soon)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-usbdevice</b> <i>devname</i></dt>
  <dd class="It-tag">Add the USB device <i>devname</i>.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>mouse</b></dt>
  <dd class="It-tag">Virtual Mouse. This will override the PS/2 mouse emulation
      when activated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tablet</b></dt>
  <dd class="It-tag">Pointer device that uses absolute coordinates (like a
      touchscreen). This means QEMU is able to report the mouse position without
      having to grab the mouse. Also overrides the PS/2 mouse emulation when
      activated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disk:[format=</b><i>format</i><b>]:</b><i>file</i></dt>
  <dd class="It-tag">Mass storage device based on file. The optional
      <i>format</i> argument will be used rather than detecting the format. Can
      be used to specify &quot;format=raw&quot; to avoid interpreting an
      untrusted format header.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>host:</b><i>bus</i><b>.</b><i>addr</i></dt>
  <dd class="It-tag">Pass through the host device identified by
      <i>bus</i>.<i>addr</i> (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>host:</b><i>vendor_id</i><b>:</b><i>product_id</i></dt>
  <dd class="It-tag">Pass through the host device identified by
      <i>vendor_id</i>: <i>product_id</i> (Linux only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>serial:[vendorid=</b><i>vendor_id</i><b>][,productid=</b><i>product_id</i><b>]:</b><i>dev</i></dt>
  <dd class="It-tag">Serial converter to host character device <i>dev</i>, see
      &quot;-serial&quot; for the available devices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>braille</b></dt>
  <dd class="It-tag">Braille device. This will use BrlAPI to display the braille
      output on a real or fake device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>net:</b><i>options</i></dt>
  <dd class="It-tag">Network adapter that supports CDC ethernet and RNDIS
      protocols.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<div class="Pp"></div>
<i>Display options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-display</b> <i>type</i></dt>
  <dd class="It-tag">Select type of display to use. This option is a replacement
      for the old style -sdl/-curses/... options. Valid values for <i>type</i>
      are</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>sdl</b></dt>
  <dd class="It-tag">Display video output via SDL (usually in a separate
      graphics window; see the SDL documentation for other possibilities).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>curses</b></dt>
  <dd class="It-tag">Display video output via curses. For graphics device models
      which support a text mode, QEMU can display this output using a
      curses/ncurses interface. Nothing is displayed when the graphics device is
      in graphical mode or if the graphics device does not support a text mode.
      Generally only the VGA device models support text mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">Do not display video output. The guest will still see an
      emulated graphics card, but its output will not be displayed to the QEMU
      user. This option differs from the -nographic option in that it only
      affects what is done with video output; -nographic also changes the
      destination of the serial and parallel port data.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gtk</b></dt>
  <dd class="It-tag">Display video output in a GTK window. This interface
      provides drop-down menus and other UI elements to configure and control
      the VM during runtime.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vnc</b></dt>
  <dd class="It-tag">Start a VNC server on display &lt;arg&gt;</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-nographic</b></dt>
  <dd class="It-tag">Normally, if QEMU is compiled with graphical window
      support, it displays output such as guest graphics, guest console, and the
      QEMU monitor in a window. With this option, you can totally disable
      graphical output so that QEMU is a simple command line application. The
      emulated serial port is redirected on the console and muxed with the
      monitor (unless redirected elsewhere explicitly). Therefore, you can still
      use QEMU to debug a Linux kernel with a serial console. Use <b>C-a h</b>
      for help on switching between the console and monitor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-curses</b></dt>
  <dd class="It-tag">Normally, if QEMU is compiled with graphical window
      support, it displays output such as guest graphics, guest console, and the
      QEMU monitor in a window. With this option, QEMU can display the VGA
      output when in text mode using a curses/ncurses interface. Nothing is
      displayed in graphical mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-frame</b></dt>
  <dd class="It-tag">Do not use decorations for SDL windows and start them using
      the whole available screen space. This makes the using QEMU in a dedicated
      desktop workspace more convenient.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-alt-grab</b></dt>
  <dd class="It-tag">Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt).
      Note that this also affects the special keys (for fullscreen, monitor-mode
      switching, etc).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-ctrl-grab</b></dt>
  <dd class="It-tag">Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note
      that this also affects the special keys (for fullscreen, monitor-mode
      switching, etc).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-quit</b></dt>
  <dd class="It-tag">Disable SDL window close capability.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sdl</b></dt>
  <dd class="It-tag">Enable SDL.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-spice</b>
    <i>option</i><b>[,</b><i>option</i><b>[,...]]</b></dt>
  <dd class="It-tag">Enable the spice remote desktop protocol. Valid options
    are</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>port=&lt;nr&gt;</b></dt>
  <dd class="It-tag">Set the TCP port spice is listening on for plaintext
      channels.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>addr=&lt;addr&gt;</b></dt>
  <dd class="It-tag">Set the IP address spice is listening on. Default is any
      address.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ipv4</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ipv6</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unix</b></dt>
  <dd class="It-tag">Force using the specified IP version.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>password=&lt;secret&gt;</b></dt>
  <dd class="It-tag">Set the password you need to authenticate.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sasl</b></dt>
  <dd class="It-tag">Require that the client use SASL to authenticate with the
      spice. The exact choice of authentication method used is controlled from
      the system / user's SASL configuration file for the 'qemu' service. This
      is typically found in /etc/sasl2/qemu.conf. If running QEMU as an
      unprivileged user, an environment variable SASL_CONF_PATH can be used to
      make it search alternate locations for the service config. While some SASL
      auth methods can also provide data encryption (eg GSSAPI), it is
      recommended that SASL always be combined with the 'tls' and 'x509'
      settings to enable use of SSL and server certificates. This ensures a data
      encryption preventing compromise of authentication credentials.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable-ticketing</b></dt>
  <dd class="It-tag">Allow client connects without authentication.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable-copy-paste</b></dt>
  <dd class="It-tag">Disable copy paste between the client and the guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>disable-agent-file-xfer</b></dt>
  <dd class="It-tag">Disable spice-vdagent based file-xfer between the client
      and the guest.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tls-port=&lt;nr&gt;</b></dt>
  <dd class="It-tag">Set the TCP port spice is listening on for encrypted
      channels.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509-dir=&lt;dir&gt;</b></dt>
  <dd class="It-tag">Set the x509 file directory. Expects same filenames as -vnc
      $display,x509=$dir</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509-key-file=&lt;file&gt;</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509-key-password=&lt;file&gt;</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509-cert-file=&lt;file&gt;</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509-cacert-file=&lt;file&gt;</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509-dh-key-file=&lt;file&gt;</b></dt>
  <dd class="It-tag">The x509 file names can also be configured
    individually.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tls-ciphers=&lt;list&gt;</b></dt>
  <dd class="It-tag">Specify which ciphers to use.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tls-channel=[main|display|cursor|inputs|record|playback]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>plaintext-channel=[main|display|cursor|inputs|record|playback]</b></dt>
  <dd class="It-tag">Force specific channel to be used with or without TLS
      encryption. The options can be specified multiple times to configure
      multiple channels. The special name &quot;default&quot; can be used to set
      the default mode. For channels which are not explicitly forced into one
      mode the spice client is allowed to pick tls/plaintext as he pleases.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>image-compression=[auto_glz|auto_lz|quic|glz|lz|off]</b></dt>
  <dd class="It-tag">Configure image compression (lossless). Default is
      auto_glz.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>jpeg-wan-compression=[auto|never|always]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>zlib-glz-wan-compression=[auto|never|always]</b></dt>
  <dd class="It-tag">Configure wan image compression (lossy for slow links).
      Default is auto.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>streaming-video=[off|all|filter]</b></dt>
  <dd class="It-tag">Configure video stream detection. Default is off.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>agent-mouse=[on|off]</b></dt>
  <dd class="It-tag">Enable/disable passing mouse events via vdagent. Default is
      on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>playback-compression=[on|off]</b></dt>
  <dd class="It-tag">Enable/disable audio stream compression (using celt 0.5.1).
      Default is on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>seamless-migration=[on|off]</b></dt>
  <dd class="It-tag">Enable/disable spice seamless migration. Default is
    off.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>gl=[on|off]</b></dt>
  <dd class="It-tag">Enable/disable OpenGL context. Default is off.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rendernode=&lt;file&gt;</b></dt>
  <dd class="It-tag">DRM render node for OpenGL rendering. If not specified, it
      will pick the first available. (Since 2.9)</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-portrait</b></dt>
  <dd class="It-tag">Rotate graphical output 90 deg left (only PXA LCD).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-rotate</b> <i>deg</i></dt>
  <dd class="It-tag">Rotate graphical output some deg left (only PXA LCD).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vga</b> <i>type</i></dt>
  <dd class="It-tag">Select type of VGA card to emulate. Valid values for
      <i>type</i> are</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>cirrus</b></dt>
  <dd class="It-tag">Cirrus Logic GD5446 Video card. All Windows versions
      starting from Windows 95 should recognize and use this graphic card. For
      optimal performances, use 16 bit color depth in the guest and the host OS.
      (This card was the default before QEMU 2.2)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>std</b></dt>
  <dd class="It-tag">Standard VGA card with Bochs VBE extensions. If your guest
      OS supports the VESA 2.0 VBE extensions (e.g. Windows XP) and if you want
      to use high resolution modes (&gt;= 1280x1024x16) then you should use this
      option. (This card is the default since QEMU 2.2)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>vmware</b></dt>
  <dd class="It-tag">VMWare SVGA-II compatible adapter. Use it if you have
      sufficiently recent XFree86/XOrg server or Windows guest with a driver for
      this card.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>qxl</b></dt>
  <dd class="It-tag">QXL paravirtual graphic card. It is VGA compatible
      (including VESA 2.0 VBE support). Works best with qxl guest drivers
      installed though. Recommended choice when using the spice protocol.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tcx</b></dt>
  <dd class="It-tag">(sun4m only) Sun TCX framebuffer. This is the default
      framebuffer for sun4m machines and offers both 8-bit and 24-bit colour
      depths at a fixed resolution of 1024x768.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cg3</b></dt>
  <dd class="It-tag">(sun4m only) Sun cgthree framebuffer. This is a simple
      8-bit framebuffer for sun4m machines available in both 1024x768 (OpenBIOS)
      and 1152x900 (OBP) resolutions aimed at people wishing to run older
      Solaris versions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>virtio</b></dt>
  <dd class="It-tag">Virtio VGA card.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">Disable VGA card.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-full-screen</b></dt>
  <dd class="It-tag">Start in full screen.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>
    <i>width</i><b>x</b><i>height</i><b>[x</b><i>depth</i> <b>]</b></dt>
  <dd class="It-tag">Set the initial graphical resolution and depth (PPC, SPARC
      only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-vnc</b>
    <i>display</i><b>[,</b><i>option</i><b>[,</b><i>option</i><b>[,...]]]</b></dt>
  <dd class="It-tag">Normally, if QEMU is compiled with graphical window
      support, it displays output such as guest graphics, guest console, and the
      QEMU monitor in a window. With this option, you can have QEMU listen on
      VNC display <i>display</i> and redirect the VGA display over the VNC
      session. It is very useful to enable the usb tablet device when using this
      option (option <b>-usbdevice tablet</b>). When using the VNC display, you
      must use the <b>-k</b> parameter to set the keyboard layout if you are not
      using en-us. Valid syntax for the <i>display</i> is</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>to=</b><i>L</i></dt>
  <dd class="It-tag">With this option, QEMU will try next available VNC
      <i>display</i>s, until the number <i>L</i>, if the origianlly defined
      &quot;-vnc <i>display</i>&quot; is not available, e.g. port 5900+
      <i>display</i> is already used by another application. By default,
    to=0.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>host</i><b>:</b><i>d</i></dt>
  <dd class="It-tag">TCP connections will only be allowed from <i>host</i> on
      display <i>d</i>. By convention the TCP port is 5900+ <i>d</i>.
      Optionally, <i>host</i> can be omitted in which case the server will
      accept connections from any host.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unix:</b><i>path</i></dt>
  <dd class="It-tag">Connections will be allowed over UNIX domain sockets where
      <i>path</i> is the location of a unix socket to listen for connections
    on.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">VNC is initialized but not started. The monitor
      &quot;change&quot; command can be used to later start the VNC server.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Following the <i>display</i> value there may be one or more <i>option</i> flags
  separated by commas. Valid options are
<dl class="Bl-tag">
  <dt class="It-tag"><b>reverse</b></dt>
  <dd class="It-tag">Connect to a listening VNC client via a &quot;reverse&quot;
      connection. The client is specified by the <i>display</i>. For reverse
      network connections ( <i>host</i>:<i>d</i>,&quot;reverse&quot;), the
      <i>d</i> argument is a TCP port number, not a display number.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>websocket</b></dt>
  <dd class="It-tag">Opens an additional TCP listening port dedicated to VNC
      Websocket connections. If a bare <i>websocket</i> option is given, the
      Websocket port is 5700+ <i>display</i>. An alternative port can be
      specified with the syntax &quot;websocket&quot;= <i>port</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If <i>host</i> is specified connections will only be allowed from this host.
      It is possible to control the websocket listen address independently,
      using the syntax &quot;websocket&quot;= <i>host</i>:<i>port</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    If no TLS credentials are provided, the websocket connection runs in
      unencrypted mode. If TLS credentials are provided, the websocket
      connection requires encrypted client connections.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>password</b></dt>
  <dd class="It-tag">Require that password based authentication is used for
      client connections.
    <div style="height: 1.00em;">&#x00A0;</div>
    The password must be set separately using the &quot;set_password&quot;
      command in the <b>pcsys_monitor</b>. The syntax to change your password
      is: &quot;set_password &lt;protocol&gt; &lt;password&gt;&quot; where
      &lt;protocol&gt; could be either &quot;vnc&quot; or &quot;spice&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you would like to change &lt;protocol&gt; password expiration, you should
      use &quot;expire_password &lt;protocol&gt; &lt;expiration-time&gt;&quot;
      where expiration time could be one of the following options: now, never,
      +seconds or UNIX time of expiration, e.g. +60 to make password expire in
      60 seconds, or 1335196800 to make password expire on &quot;Mon Apr 23
      12:00:00 EDT 2012&quot; (UNIX time for this date and time).
    <div style="height: 1.00em;">&#x00A0;</div>
    You can also use keywords &quot;now&quot; or &quot;never&quot; for the
      expiration time to allow &lt;protocol&gt; password to expire immediately
      or never expire.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tls-creds=</b><i>ID</i></dt>
  <dd class="It-tag">Provides the ID of a set of TLS credentials to use to
      secure the VNC server. They will apply to both the normal VNC server
      socket and the websocket socket (if enabled). Setting TLS credentials will
      cause the VNC server socket to enable the VeNCrypt auth mechanism. The
      credentials should have been previously created using the <b>-object
      tls-creds</b> argument.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <b>tls-creds</b> parameter obsoletes the <b>tls</b>, <b>x509</b>, and
      <b>x509verify</b> options, and as such it is not permitted to set both new
      and old type options at the same time.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tls</b></dt>
  <dd class="It-tag">Require that client use TLS when communicating with the VNC
      server. This uses anonymous TLS credentials so is susceptible to a
      man-in-the-middle attack. It is recommended that this option be combined
      with either the <b>x509</b> or <b>x509verify</b> options.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is now deprecated in favor of using the <b>tls-creds</b>
      argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509=</b><i>/path/to/certificate/dir</i></dt>
  <dd class="It-tag">Valid if <b>tls</b> is specified. Require that x509
      credentials are used for negotiating the TLS session. The server will send
      its x509 certificate to the client. It is recommended that a password be
      set on the VNC server to provide authentication of the client when this is
      used. The path following this option specifies where the x509 certificates
      are to be loaded from. See the <b>vnc_security</b> section for details on
      generating certificates.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is now deprecated in favour of using the <b>tls-creds</b>
      argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>x509verify=</b><i>/path/to/certificate/dir</i></dt>
  <dd class="It-tag">Valid if <b>tls</b> is specified. Require that x509
      credentials are used for negotiating the TLS session. The server will send
      its x509 certificate to the client, and request that the client send its
      own x509 certificate. The server will validate the client's certificate
      against the CA certificate, and reject clients when validation fails. If
      the certificate authority is trusted, this is a sufficient authentication
      mechanism. You may still wish to set a password on the VNC server as a
      second authentication layer. The path following this option specifies
      where the x509 certificates are to be loaded from. See the
      <b>vnc_security</b> section for details on generating certificates.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is now deprecated in favour of using the <b>tls-creds</b>
      argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sasl</b></dt>
  <dd class="It-tag">Require that the client use SASL to authenticate with the
      VNC server. The exact choice of authentication method used is controlled
      from the system / user's SASL configuration file for the 'qemu' service.
      This is typically found in /etc/sasl2/qemu.conf. If running QEMU as an
      unprivileged user, an environment variable SASL_CONF_PATH can be used to
      make it search alternate locations for the service config. While some SASL
      auth methods can also provide data encryption (eg GSSAPI), it is
      recommended that SASL always be combined with the 'tls' and 'x509'
      settings to enable use of SSL and server certificates. This ensures a data
      encryption preventing compromise of authentication credentials. See the
      <b>vnc_security</b> section for details on using SASL authentication.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>acl</b></dt>
  <dd class="It-tag">Turn on access control lists for checking of the x509
      client certificate and SASL party. For x509 certs, the ACL check is made
      against the certificate's distinguished name. This is something that looks
      like &quot;C=GB,O=ACME,L=Boston,CN=bob&quot;. For SASL party, the ACL
      check is made against the username, which depending on the SASL plugin,
      may include a realm component, eg &quot;bob&quot; or
      &quot;bob@EXAMPLE.COM&quot;. When the <b>acl</b> flag is set, the initial
      access list will be empty, with a &quot;deny&quot; policy. Thus no one
      will be allowed to use the VNC server until the ACLs have been loaded.
      This can be achieved using the &quot;acl&quot; monitor command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>lossy</b></dt>
  <dd class="It-tag">Enable lossy compression methods (gradient, JPEG, ...). If
      this option is set, VNC client may receive lossy framebuffer updates
      depending on its encoding settings. Enabling this option can save a lot of
      bandwidth at the expense of quality.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>non-adaptive</b></dt>
  <dd class="It-tag">Disable adaptive encodings. Adaptive encodings are enabled
      by default. An adaptive encoding will try to detect frequently updated
      screen regions, and send updates in these regions using a lossy encoding
      (like JPEG). This can be really helpful to save bandwidth when playing
      videos. Disabling adaptive encodings restores the original static behavior
      of encodings like Tight.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>share=[allow-exclusive|force-shared|ignore]</b></dt>
  <dd class="It-tag">Set display sharing policy. 'allow-exclusive' allows
      clients to ask for exclusive access. As suggested by the rfb spec this is
      implemented by dropping other connections. Connecting multiple clients in
      parallel requires all clients asking for a shared session (vncviewer:
      -shared switch). This is the default. 'force-shared' disables exclusive
      client access. Useful for shared desktop sessions, where you don't want
      someone forgetting specify -shared disconnect everybody else. 'ignore'
      completely ignores the shared flag and allows everybody connect
      unconditionally. Doesn't conform to the rfb spec but is traditional QEMU
      behavior.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>key-delay-ms</b></dt>
  <dd class="It-tag">Set keyboard delay, for key down and key up events, in
      milliseconds. Default is 10. Keyboards are low-bandwidth devices, so this
      slowdown can help the device and guest to keep up and not lose events in
      case events are arriving in bulk. Possible causes for the latter are flaky
      network connections, or scripts for automated testing.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<div class="Pp"></div>
<i>i386 target only</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-win2k-hack</b></dt>
  <dd class="It-tag">Use it when installing Windows 2000 to avoid a disk full
      bug. After Windows 2000 is installed, you no longer need this option (this
      option slows down the IDE transfers).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-fd-bootchk</b></dt>
  <dd class="It-tag">Disable boot signature checking for floppy disks in BIOS.
      May be needed to boot from old floppy disks.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-acpi</b></dt>
  <dd class="It-tag">Disable ACPI (Advanced Configuration and Power Interface)
      support. Use it if your guest OS complains about ACPI problems (PC target
      machine only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-hpet</b></dt>
  <dd class="It-tag">Disable HPET support.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-acpitable
    [sig=</b><i>str</i><b>][,rev=</b><i>n</i><b>][,oem_id=</b>
    <i>str</i><b>][,oem_table_id=</b> <i>str</i><b>][,oem_rev=</b><i>n</i><b>]
    [,asl_compiler_id=</b>
    <i>str</i><b>][,asl_compiler_rev=</b><i>n</i><b>][,data=</b>
    <i>file1</i><b>[:</b> <i>file2</i><b>]...]</b></dt>
  <dd class="It-tag">Add ACPI table with specified header fields and context
      from specified files. For file=, take whole ACPI table from the specified
      files, including all ACPI headers (possible overridden by other options).
      For data=, only data portion of the table is used, all header information
      is specified in the command line. If a SLIC table is supplied to QEMU,
      then the SLIC's oem_id and oem_table_id fields will override the same in
      the RSDT and the FADT (a.k.a. FACP), in order to ensure the field matches
      required by the Microsoft SLIC spec and the ACPI spec.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios file=</b><i>binary</i></dt>
  <dd class="It-tag">Load SMBIOS entry from binary file.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios
    type=0[,vendor=</b><i>str</i><b>][,version=</b><i>str</i><b>][,date=</b><i>str</i><b>][,release=</b><i></i><i>%d</i><i>.%d</i><b>][,uefi=on|off]</b></dt>
  <dd class="It-tag">Specify SMBIOS type 0 fields</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios
    type=1[,manufacturer=</b><i>str</i><b>][,product=</b>
    <i>str</i><b>][,version=</b>
    <i>str</i><b>][,serial=</b><i>str</i><b>][,uuid=</b>
    <i>uuid</i><b>][,sku=</b> <i>str</i><b>][,family=</b><i>str</i><b>]</b></dt>
  <dd class="It-tag">Specify SMBIOS type 1 fields</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios
    type=2[,manufacturer=</b><i>str</i><b>][,product=</b>
    <i>str</i><b>][,version=</b>
    <i>str</i><b>][,serial=</b><i>str</i><b>][,asset=</b>
    <i>str</i><b>][,location=</b>
    <i>str</i><b>][,family=</b><i>str</i><b>]</b></dt>
  <dd class="It-tag">Specify SMBIOS type 2 fields</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios
    type=3[,manufacturer=</b><i>str</i><b>][,version=</b>
    <i>str</i><b>][,serial=</b>
    <i>str</i><b>][,asset=</b><i>str</i><b>][,sku=</b> <i>str</i><b>]</b></dt>
  <dd class="It-tag">Specify SMBIOS type 3 fields</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios
    type=4[,sock_pfx=</b><i>str</i><b>][,manufacturer=</b>
    <i>str</i><b>][,version=</b>
    <i>str</i><b>][,serial=</b><i>str</i><b>][,asset=</b>
    <i>str</i><b>][,part=</b> <i>str</i><b>]</b></dt>
  <dd class="It-tag">Specify SMBIOS type 4 fields</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-smbios
    type=17[,loc_pfx=</b><i>str</i><b>][,bank=</b><i>str</i><b>][,manufacturer=</b><i>str</i><b>][,serial=</b><i>str</i><b>][,asset=</b><i>str</i><b>][,part=</b><i>str</i><b>][,speed=</b><i></i><i>%d</i><i></i><b>]</b></dt>
  <dd class="It-tag">Specify SMBIOS type 17 fields</dd>
</dl>
<div class="Pp"></div>
<i>Network options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    nic[,vlan=</b><i>n</i><b>][,macaddr=</b><i>mac</i><b>][,model=</b><i>type</i><b>]
    [,name=</b>
    <i>name</i><b>][,addr=</b><i>addr</i><b>][,vectors=</b><i>v</i><b>]</b></dt>
  <dd class="It-tag">Create a new Network Interface Card and connect it to VLAN
      <i>n</i> (<i>n</i> = 0 is the default). The NIC is an e1000 by default on
      the PC target. Optionally, the MAC address can be changed to <i>mac</i>,
      the device address set to <i>addr</i> (PCI cards only), and a <i>name</i>
      can be assigned for use in monitor commands. Optionally, for PCI cards,
      you can specify the number <i>v</i> of MSI-X vectors that the card should
      have; this option currently only affects virtio cards; set <i>v</i> = 0 to
      disable MSI-X. If no <b>-net</b> option is specified, a single NIC is
      created. QEMU can emulate several different models of network card. Valid
      values for <i>type</i> are &quot;virtio&quot;, &quot;i82551&quot;,
      &quot;i82557b&quot;, &quot;i82559er&quot;, &quot;ne2k_pci&quot;,
      &quot;ne2k_isa&quot;, &quot;pcnet&quot;, &quot;rtl8139&quot;,
      &quot;e1000&quot;, &quot;smc91c111&quot;, &quot;lance&quot; and
      &quot;mcf_fec&quot;. Not all devices are supported on all targets. Use
      &quot;-net nic,model=help&quot; for a list of available devices for your
      target.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    user,id=</b><i>id</i><b>[,</b><i>option</i><b>][,</b>
    <i>option</i><b>][,...]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    user[,</b><i>option</i><b>][,</b><i>option</i><b>][,...]</b></dt>
  <dd class="It-tag">Use the user mode network stack which requires no
      administrator privilege to run. Valid options are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>vlan=</b><i>n</i></dt>
  <dd class="It-tag">Connect user mode stack to VLAN <i>n</i> (<i>n</i> = 0 is
      the default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>id=</b><i>id</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>name=</b><i>name</i></dt>
  <dd class="It-tag">Assign symbolic name for use in monitor commands.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>ipv4</b> and <b>ipv6</b> specify that either IPv4 or IPv6 must be
      enabled. If neither is specified both protocols are enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>net=</b><i>addr</i><b>[/</b><i>mask</i><b>]</b></dt>
  <dd class="It-tag">Set IP network address the guest will see. Optionally
      specify the netmask, either in the form a.b.c.d or as number of valid
      top-most bits. Default is 10.0.2.0/24.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>host=</b><i>addr</i></dt>
  <dd class="It-tag">Specify the guest-visible address of the host. Default is
      the 2nd IP in the guest network, i.e. x.x.x.2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ipv6-net=</b><i>addr</i><b>[/</b><i>int</i><b>]</b></dt>
  <dd class="It-tag">Set IPv6 network address the guest will see (default is
      fec0::/64). The network prefix is given in the usual hexadecimal IPv6
      address notation. The prefix size is optional, and is given as the number
      of valid top-most bits (default is 64).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ipv6-host=</b><i>addr</i></dt>
  <dd class="It-tag">Specify the guest-visible IPv6 address of the host. Default
      is the 2nd IPv6 in the guest network, i.e. xxxx::2.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>restrict=on|off</b></dt>
  <dd class="It-tag">If this option is enabled, the guest will be isolated, i.e.
      it will not be able to contact the host and no guest IP packets will be
      routed over the host to the outside. This option does not affect any
      explicitly set forwarding rules.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hostname=</b><i>name</i></dt>
  <dd class="It-tag">Specifies the client hostname reported by the built-in DHCP
      server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dhcpstart=</b><i>addr</i></dt>
  <dd class="It-tag">Specify the first of the 16 IPs the built-in DHCP server
      can assign. Default is the 15th to 31st IP in the guest network, i.e.
      x.x.x.15 to x.x.x.31.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dns=</b><i>addr</i></dt>
  <dd class="It-tag">Specify the guest-visible address of the virtual
      nameserver. The address must be different from the host address. Default
      is the 3rd IP in the guest network, i.e. x.x.x.3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ipv6-dns=</b><i>addr</i></dt>
  <dd class="It-tag">Specify the guest-visible address of the IPv6 virtual
      nameserver. The address must be different from the host address. Default
      is the 3rd IP in the guest network, i.e. xxxx::3.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dnssearch=</b><i>domain</i></dt>
  <dd class="It-tag">Provides an entry for the domain-search list sent by the
      built-in DHCP server. More than one domain suffix can be transmitted by
      specifying this option multiple times. If supported, this will cause the
      guest to automatically try to append the given domain suffix(es) in case a
      domain name can not be resolved.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu -net user,dnssearch=mgmt.example.org,dnssearch=example.org [...]
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tftp=</b><i>dir</i></dt>
  <dd class="It-tag">When using the user mode network stack, activate a built-in
      TFTP server. The files in <i>dir</i> will be exposed as the root of a TFTP
      server. The TFTP client on the guest must be configured in binary mode
      (use the command &quot;bin&quot; of the Unix TFTP client).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>bootfile=</b><i>file</i></dt>
  <dd class="It-tag">When using the user mode network stack, broadcast
      <i>file</i> as the BOOTP filename. In conjunction with <b>tftp</b>, this
      can be used to network boot a guest from a local directory.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example (using pxelinux):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 -hda linux.img -boot n -net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>smb=</b><i>dir</i><b>[,smbserver=</b><i>addr</i><b>]</b></dt>
  <dd class="It-tag">When using the user mode network stack, activate a built-in
      SMB server so that Windows OSes can access to the host files in
      <i></i><i>dir</i> <i></i> transparently. The IP address of the SMB server
      can be set to <i>addr</i>. By default the 4th IP in the guest network is
      used, i.e. x.x.x.4.
    <div style="height: 1.00em;">&#x00A0;</div>
    In the guest Windows OS, the line:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        10.0.2.4 smbserver
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    must be added in the file <i>C:\WINDOWS\LMHOSTS</i> (for windows 9x/Me) or
      <i>C:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS</i> (Windows NT/2000).
    <div style="height: 1.00em;">&#x00A0;</div>
    Then <i></i><i>dir</i><i></i> can be accessed in <i>\\smbserver\qemu</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that a SAMBA server must be installed on the host OS. QEMU was tested
      successfully with smbd versions from Red Hat 9, Fedora Core 3 and OpenSUSE
      11.x.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>hostfwd=[tcp|udp]:[</b><i>hostaddr</i><b>]:</b><i>hostport</i><b>-[</b><i>guestaddr</i><b>]:</b><i>guestport</i></dt>
  <dd class="It-tag">Redirect incoming TCP or UDP connections to the host port
      <i>hostport</i> to the guest IP address <i>guestaddr</i> on guest port
      <i>guestport</i>. If <i>guestaddr</i> is not specified, its value is
      x.x.x.15 (default first address given by the built-in DHCP server). By
      specifying <i>hostaddr</i>, the rule can be bound to a specific host
      interface. If no connection type is set, TCP is used. This option can be
      given multiple times.
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to redirect host X11 connection from screen 1 to guest screen
      0, use the following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # on the host
        qemu-system-i386 -net user,hostfwd=tcp:127.0.0.1:6001-:6000 [...]
        # this host xterm should open in the guest X11 server
        xterm -display :1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    To redirect telnet connections from host port 5555 to telnet port on the
      guest, use the following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # on the host
        qemu-system-i386 -net user,hostfwd=tcp::5555-:23 [...]
        telnet localhost 5555
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Then when you use on the host &quot;telnet localhost 5555&quot;, you connect
      to the guest telnet server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>guestfwd=[tcp]:</b><i>server</i><b>:</b><i>port</i><b>-</b><i>dev</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>guestfwd=[tcp]:</b><i>server</i><b>:</b><i>port</i><b>-</b><i>cmd:command</i></dt>
  <dd class="It-tag">Forward guest TCP connections to the IP address
      <i>server</i> on port <i>port</i> to the character device <i>dev</i> or to
      a program executed by <i>cmd:command</i> which gets spawned for each
      connection. This option can be given multiple times.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can either use a chardev directly and have that one used throughout
      QEMU's lifetime, like in the following example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever
        # the guest accesses it
        qemu -net user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321 [...]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or you can execute a command on every TCP connection established by the
      guest, so that QEMU behaves similar to an inetd process for that virtual
      server:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # call &quot;netcat 10.10.1.1 4321&quot; on every TCP connection to 10.0.2.100:1234
        # and connect the TCP stream to its stdin/stdout
        qemu -net 'user,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321'
    </pre>
  </dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Note: Legacy stand-alone options -tftp, -bootp, -smb and -redir are still
  processed and applied to -net user. Mixing them with the new configuration
  syntax gives undefined results. Their use for new applications is discouraged
  as they will be removed from future versions.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    tap,id=</b><i>id</i><b>[,fd=</b><i>h</i><b>][,ifname=</b>
    <i>name</i><b>][,script=</b>
    <i>file</i><b>][,downscript=</b><i>dfile</i><b>][,br=</b>
    <i>bridge</i><b>][,helper=</b> <i>helper</i><b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    tap[,vlan=</b><i>n</i><b>][,name=</b><i>name</i><b>][,fd=</b>
    <i>h</i><b>][,ifname=</b>
    <i>name</i><b>][,script=</b><i>file</i><b>][,downscript=</b>
    <i>dfile</i><b>][,br=</b>
    <i>bridge</i><b>][,helper=</b><i>helper</i><b>]</b></dt>
  <dd class="It-tag">Connect the host TAP network interface <i>name</i> to VLAN
      <i>n</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use the network script <i>file</i> to configure it and the network script
      <i>dfile</i> to deconfigure it. If <i>name</i> is not provided, the OS
      automatically provides one. The default network configure script is
      <i>/etc/qemu-ifup</i> and the default network deconfigure script is
      <i>/etc/qemu-ifdown</i>. Use <b>script=no</b> or <b>downscript=no</b> to
      disable script execution.
    <div style="height: 1.00em;">&#x00A0;</div>
    If running QEMU as an unprivileged user, use the network helper
      <i>helper</i> to configure the TAP interface and attach it to the bridge.
      The default network helper executable is
      <i>/path/to/qemu-bridge-helper</i> and the default bridge device is
      <i>br0</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>fd</b>=<i>h</i> can be used to specify the handle of an already opened
      host TAP interface.
    <div style="height: 1.00em;">&#x00A0;</div>
    Examples:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        #launch a QEMU instance with the default network script
        qemu-system-i386 linux.img -net nic -net tap
        
        #launch a QEMU instance with two NICs, each one connected
        #to a TAP device
        qemu-system-i386 linux.img \
        -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 \
        -net nic,vlan=1 -net tap,vlan=1,ifname=tap1
        
        #launch a QEMU instance with the default network helper to
        #connect a TAP device to bridge br0
        qemu-system-i386 linux.img \
        -net nic -net tap,&quot;helper=/path/to/qemu-bridge-helper&quot;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    bridge,id=</b><i>id</i><b>[,br=</b><i>bridge</i><b>][,helper=</b><i>helper</i><b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    bridge[,vlan=</b><i>n</i><b>][,name=</b><i>name</i><b>][,br=</b><i>bridge</i><b>][,helper=</b><i>helper</i><b>]</b></dt>
  <dd class="It-tag">Connect a host TAP network interface to a host bridge
      device.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use the network helper <i>helper</i> to configure the TAP interface and
      attach it to the bridge. The default network helper executable is
      <i>/path/to/qemu-bridge-helper</i> and the default bridge device is
      <i>br0</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    Examples:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        #launch a QEMU instance with the default network helper to
        #connect a TAP device to bridge br0
        qemu-system-i386 linux.img -net bridge -net nic,model=virtio
        
        #launch a QEMU instance with the default network helper to
        #connect a TAP device to bridge qemubr0
        qemu-system-i386 linux.img -net bridge,br=qemubr0 -net nic,model=virtio
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    socket,id=</b><i>id</i><b>[,fd=</b><i>h</i><b>][,listen=[</b>
    <i>host</i><b>]:</b>
    <i>port</i><b>][,connect=</b><i>host</i><b>:</b><i>port</i> <b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    socket[,vlan=</b><i>n</i><b>][,name=</b><i>name</i><b>][,fd=</b><i>h</i><b>]
    [,listen=[</b>
    <i>host</i><b>]:</b><i>port</i><b>][,connect=</b><i>host</i><b>:</b><i>port</i><b>]</b></dt>
  <dd class="It-tag">Connect the VLAN <i>n</i> to a remote VLAN in another QEMU
      virtual machine using a TCP socket connection. If <b>listen</b> is
      specified, QEMU waits for incoming connections on <i>port</i> (
      <i>host</i> is optional). <b>connect</b> is used to connect to another
      QEMU instance using the <b>listen</b> option. <b>fd</b>=<i>h</i> specifies
      an already opened TCP socket.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # launch a first QEMU instance
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:56 \
        -net socket,listen=:1234
        # connect the VLAN 0 of this instance to the VLAN 0
        # of the first instance
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:57 \
        -net socket,connect=127.0.0.1:1234
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    socket,id=</b><i>id</i><b>[,fd=</b><i>h</i><b>][,mcast=</b>
    <i>maddr</i><b>:</b> <i>port</i><b>[,localaddr=</b><i>addr</i><b>]]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    socket[,vlan=</b><i>n</i><b>][,name=</b><i>name</i><b>][,fd=</b><i>h</i><b>][,mcast=</b><i>maddr</i><b>:</b><i>port</i><b>[,localaddr=</b><i>addr</i><b>]]</b></dt>
  <dd class="It-tag">Create a VLAN <i>n</i> shared with another QEMU virtual
      machines using a UDP multicast socket, effectively making a bus for every
      QEMU with same multicast address <i>maddr</i> and <i>port</i>. NOTES:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">1.</dt>
  <dd class="It-tag">Several QEMU can be running on different hosts and share
      same bus (assuming correct multicast setup for these hosts).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">2.</dt>
  <dd class="It-tag">mcast support is compatible with User Mode Linux (argument
      <b>eth</b><i>N</i><b>=mcast</b>), see &lt;
      <b>http://user-mode-linux.sf.net</b>&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">Use <b>fd=h</b> to specify an already opened UDP multicast
      socket.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Example:
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        # launch one QEMU instance
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:56 \
        -net socket,mcast=230.0.0.1:1234
        # launch another QEMU instance on same &quot;bus&quot;
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:57 \
        -net socket,mcast=230.0.0.1:1234
        # launch yet another QEMU instance on same &quot;bus&quot;
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:58 \
        -net socket,mcast=230.0.0.1:1234
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Example (User Mode Linux compat.):
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        # launch QEMU instance (note mcast address selected
        # is UML's default)
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:56 \
        -net socket,mcast=239.192.168.1:1102
        # launch UML
        /path/to/linux ubd0=/path/to/root_fs eth0=mcast
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Example (send packets from host's 1.2.3.4):
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-i386 linux.img \
        -net nic,macaddr=52:54:00:12:34:56 \
        -net socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4
</pre>
</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    l2tpv3,id=</b><i>id</i><b>,src=</b><i>srcaddr</i>
    <b>,dst=</b><i>dstaddr</i><b>[,srcport=</b><i>srcport</i><b>][,dstport=</b><i>dstport</i><b>],txsession=</b><i>txsession</i><b>[,rxsession=</b><i>rxsession</i><b>][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=</b><i>txcookie</i><b>][,rxcookie=</b><i>rxcookie</i><b>][,offset=</b><i>offset</i><b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    l2tpv3[,vlan=</b><i>n</i><b>][,name=</b><i>name</i><b>],src=</b><i>srcaddr</i><b>,dst=</b><i>dstaddr</i><b>[,srcport=</b><i>srcport</i><b>][,dstport=</b><i>dstport</i><b>],txsession=</b><i>txsession</i><b>[,rxsession=</b><i>rxsession</i><b>][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=</b><i>txcookie</i><b>][,rxcookie=</b><i>rxcookie</i><b>][,offset=</b><i>offset</i><b>]</b></dt>
  <dd class="It-tag">Connect VLAN <i>n</i> to L2TPv3 pseudowire. L2TPv3
      (RFC3391) is a popular protocol to transport Ethernet (and other Layer 2)
      data frames between two systems. It is present in routers, firewalls and
      the Linux kernel (from version 3.3 onwards).
    <div style="height: 1.00em;">&#x00A0;</div>
    This transport allows a VM to communicate to another VM, router or firewall
      directly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>src=</b><i>srcaddr</i></dt>
  <dd class="It-tag">source address (mandatory)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dst=</b><i>dstaddr</i></dt>
  <dd class="It-tag">destination address (mandatory)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>udp</b></dt>
  <dd class="It-tag">select udp encapsulation (default is ip).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>srcport=</b><i>srcport</i></dt>
  <dd class="It-tag">source udp port.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>dstport=</b><i>dstport</i></dt>
  <dd class="It-tag">destination udp port.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>ipv6</b></dt>
  <dd class="It-tag">force v6, otherwise defaults to v4.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>rxcookie=</b><i>rxcookie</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>txcookie=</b><i>txcookie</i></dt>
  <dd class="It-tag">Cookies are a weak form of security in the l2tpv3
      specification. Their function is mostly to prevent misconfiguration. By
      default they are 32 bit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cookie64</b></dt>
  <dd class="It-tag">Set cookie size to 64 bit instead of the default 32</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>counter=off</b></dt>
  <dd class="It-tag">Force a 'cut-down' L2TPv3 with no counter as in
      draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pincounter=on</b></dt>
  <dd class="It-tag">Work around broken counter handling in peer. This may also
      help on networks which have packet reorder.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>offset=</b><i>offset</i></dt>
  <dd class="It-tag">Add an extra offset between header and data
    <div style="height: 1.00em;">&#x00A0;</div>
    For example, to attach a VM running on host 4.3.2.1 via L2TPv3 to the bridge
      br-lan on the remote Linux host 1.2.3.4:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # Setup tunnel on linux host using raw ip as encapsulation
        # on 1.2.3.4
        ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \
        encap udp udp_sport 16384 udp_dport 16384
        ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \
        0xFFFFFFFF peer_session_id 0xFFFFFFFF
        ifconfig vmtunnel0 mtu 1500
        ifconfig vmtunnel0 up
        brctl addif br-lan vmtunnel0
        
        
        # on 4.3.2.1
        # launch QEMU instance - if your network has reorder or is very lossy add ,pincounter
        
        qemu-system-i386 linux.img -net nic -net l2tpv3,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    vde,id=</b><i>id</i><b>[,sock=</b><i>socketpath</i>
    <b>][,port=</b><i>n</i><b>][,group=</b><i>groupname</i><b>][,mode=</b><i>octalmode</i><b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    vde[,vlan=</b><i>n</i><b>][,name=</b><i>name</i><b>][,sock=</b>
    <i>socketpath</i> <b>]
    [,port=</b><i>n</i><b>][,group=</b><i>groupname</i><b>][,mode=</b><i>octalmode</i><b>]</b></dt>
  <dd class="It-tag">Connect VLAN <i>n</i> to PORT <i>n</i> of a vde switch
      running on host and listening for incoming connections on
      <i>socketpath</i>. Use GROUP <i>groupname</i> and MODE <i>octalmode</i> to
      change default ownership and permissions for communication port. This
      option is only available if QEMU has been compiled with vde support
      enabled.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # launch vde switch
        vde_switch -F -sock /tmp/myswitch
        # launch QEMU instance
        qemu-system-i386 linux.img -net nic -net vde,sock=/tmp/myswitch
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    hubport,id=</b><i>id</i><b>,hubid=</b><i>hubid</i></dt>
  <dd class="It-tag">Create a hub port on QEMU &quot;vlan&quot; <i>hubid</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The hubport netdev lets you connect a NIC to a QEMU &quot;vlan&quot; instead
      of a single netdev. &quot;-net&quot; and &quot;-device&quot; with
      parameter <b>vlan</b> create the required hub automatically.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-netdev
    vhost-user,chardev=</b><i>id</i><b>[,vhostforce=on|off][,queues=n]</b></dt>
  <dd class="It-tag">Establish a vhost-user netdev, backed by a chardev
      <i>id</i>. The chardev should be a unix domain socket backed one. The
      vhost-user uses a specifically defined protocol to pass vhost ioctl
      replacement messages to an application on the other end of the socket. On
      non-MSIX guests, the feature can be forced with <i>vhostforce</i>. Use
      'queues= <i>n</i>' to specify the number of queues to be created for
      multiqueue vhost-user.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \
        -numa node,memdev=mem \
        -chardev socket,id=chr0,path=/path/to/socket \
        -netdev type=vhost-user,id=net0,chardev=chr0 \
        -device virtio-net-pci,netdev=net0
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net
    dump[,vlan=</b><i>n</i><b>][,file=</b><i>file</i><b>][,len=</b><i>len</i><b>]</b></dt>
  <dd class="It-tag">Dump network traffic on VLAN <i>n</i> to file <i>file</i>
      (<i>qemu-vlan0.pcap</i> by default). At most <i>len</i> bytes (64k by
      default) per packet are stored. The file format is libpcap, so it can be
      analyzed with tools such as tcpdump or Wireshark. Note: For devices
      created with '-netdev', use '-object filter-dump,...' instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-net none</b></dt>
  <dd class="It-tag">Indicate that no network devices should be configured. It
      is used to override the default configuration ( <b>-net nic -net user</b>)
      which is activated if no <b>-net</b> options are provided.</dd>
</dl>
<div class="Pp"></div>
<i>Character device options</i>
<div class="Pp"></div>
The general form of a character device option is:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev</b> <i>backend</i> <b>,id=</b><i>id</i>
    <b>[,mux=on|off] [,</b> <i>options</i><b>]</b></dt>
  <dd class="It-tag">Backend is one of: <b>null</b>, <b>socket</b>, <b>udp</b>,
      <b>msmouse</b>, <b>vc</b>, <b>ringbuf</b>, <b>file</b>, <b>pipe</b>,
      <b>console</b>, <b>serial</b>, <b>pty</b>, <b>stdio</b>, <b>braille</b>,
      <b>tty</b>, <b>parallel</b>, <b>parport</b>, <b>spicevmc</b>.
      <b>spiceport</b>. The specific backend will determine the applicable
      options.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use &quot;-chardev help&quot; to print all available chardev backend types.
    <div style="height: 1.00em;">&#x00A0;</div>
    All devices must have an id, which can be any string up to 127 characters
      long. It is used to uniquely identify this device in other command line
      directives.
    <div style="height: 1.00em;">&#x00A0;</div>
    A character device may be used in multiplexing mode by multiple front-ends.
      Specify <b>mux=on</b> to enable this mode. A multiplexer is a
      &quot;1:N&quot; device, and here the &quot;1&quot; end is your specified
      chardev backend, and the &quot;N&quot; end is the various parts of QEMU
      that can talk to a chardev. If you create a chardev with <b>id=myid</b>
      and <b>mux=on</b>, QEMU will create a multiplexer with your specified ID,
      and you can then configure multiple front ends to use that chardev ID for
      their input/output. Up to four different front ends can be connected to a
      single multiplexed chardev. (Without multiplexing enabled, a chardev can
      only be used by a single front end.) For instance you could use this to
      allow a single stdio chardev to be used by two serial ports and the QEMU
      monitor:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -chardev stdio,mux=on,id=char0 \
        -mon chardev=char0,mode=readline \
        -serial chardev:char0 \
        -serial chardev:char0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can have more than one multiplexer in a system configuration; for
      instance you could have a TCP port multiplexed between UART 0 and UART 1,
      and stdio multiplexed between the QEMU monitor and a parallel port:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -chardev stdio,mux=on,id=char0 \
        -mon chardev=char0,mode=readline \
        -parallel chardev:char0 \
        -chardev tcp,...,mux=on,id=char1 \
        -serial chardev:char1 \
        -serial chardev:char1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    When you're using a multiplexed character device, some escape sequences are
      interpreted in the input.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that some other command line options may implicitly create multiplexed
      character backends; for instance <b>-serial mon:stdio</b> creates a
      multiplexed stdio backend connected to the serial port and the QEMU
      monitor, and <b>-nographic</b> also multiplexes the console and the
      monitor to stdio.
    <div style="height: 1.00em;">&#x00A0;</div>
    There is currently no support for multiplexing in the other direction (where
      a single QEMU front end takes input and output from multiple chardevs).
    <div style="height: 1.00em;">&#x00A0;</div>
    Every backend supports the <b>logfile</b> option, which supplies the path to
      a file to record all data transmitted via the backend. The
      <b>logappend</b> option controls whether the log file will be truncated or
      appended to when opened.
    <div style="height: 1.00em;">&#x00A0;</div>
    Further options to each backend are described below.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev null ,id=</b><i>id</i></dt>
  <dd class="It-tag">A void device. This device will not emit any data, and will
      drop any data it receives. The null backend does not take any
    options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev socket ,id=</b><i>id</i> <b>[</b><i>TCP
    options</i> <b>or</b> <i>unix options</i><b>] [,server] [,nowait] [,telnet]
    [,reconnect=</b> <i>seconds</i><b>] [,tls-creds=</b><i>id</i><b>]</b></dt>
  <dd class="It-tag">Create a two-way stream socket, which can be either a TCP
      or a unix socket. A unix socket will be created if <b>path</b> is
      specified. Behaviour is undefined if TCP options are specified for a unix
      socket.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>server</b> specifies that the socket shall be a listening socket.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>nowait</b> specifies that QEMU should not block waiting for a client to
      connect to a listening socket.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>telnet</b> specifies that traffic on the socket should interpret telnet
      escape sequences.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>reconnect</b> sets the timeout for reconnecting on non-server sockets
      when the remote end goes away. qemu will delay this many seconds and then
      attempt to reconnect. Zero disables reconnecting, and is the default.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>tls-creds</b> requests enablement of the TLS protocol for encryption,
      and specifies the id of the TLS credentials to use for the handshake. The
      credentials must be previously created with the <b>-object tls-creds</b>
      argument.
    <div style="height: 1.00em;">&#x00A0;</div>
    TCP and unix socket options are given below:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>TCP options: port=</b><i>port</i>
    <b>[,host=</b><i>host</i> <b>] [,to=</b><i>to</i><b>] [,ipv4] [,ipv6]
    [,nodelay]</b></dt>
  <dd class="It-tag"><b>host</b> for a listening socket specifies the local
      address to be bound. For a connecting socket species the remote host to
      connect to. <b>host</b> is optional for listening sockets. If not
      specified it defaults to 0.0.0.0.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>port</b> for a listening socket specifies the local port to be bound.
      For a connecting socket specifies the port on the remote host to connect
      to. <b>port</b> can be given as either a port number or a service name.
      <b>port</b> is required.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>to</b> is only relevant to listening sockets. If it is specified, and
      <b>port</b> cannot be bound, QEMU will attempt to bind to subsequent ports
      up to and including <b>to</b> until it succeeds. <b>to</b> must be
      specified as a port number.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>ipv4</b> and <b>ipv6</b> specify that either IPv4 or IPv6 must be used.
      If neither is specified the socket may use either protocol.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>nodelay</b> disables the Nagle algorithm.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unix options: path=</b><i>path</i></dt>
  <dd class="It-tag"><b>path</b> specifies the local path of the unix socket.
      <b>path</b> is required.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev udp ,id=</b><i>id</i>
    <b>[,host=</b><i>host</i><b>] ,port=</b><i>port</i>
    <b>[,localaddr=</b><i>localaddr</i> <b>]
    [,localport=</b><i>localport</i><b>] [,ipv4] [,ipv6]</b></dt>
  <dd class="It-tag">Sends all traffic from the guest to a remote host over UDP.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>host</b> specifies the remote host to connect to. If not specified it
      defaults to &quot;localhost&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>port</b> specifies the port on the remote host to connect to.
      <b>port</b> is required.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>localaddr</b> specifies the local address to bind to. If not specified
      it defaults to 0.0.0.0.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>localport</b> specifies the local port to bind to. If not specified any
      available local port will be used.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>ipv4</b> and <b>ipv6</b> specify that either IPv4 or IPv6 must be used.
      If neither is specified the device may use either protocol.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev msmouse ,id=</b><i>id</i></dt>
  <dd class="It-tag">Forward QEMU's emulated msmouse events to the guest.
      <b>msmouse</b> does not take any options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev vc ,id=</b><i>id</i>
    <b>[[,width=</b><i>width</i> <b>] [,height=</b><i>height</i><b>]]
    [[,cols=</b> <i>cols</i><b>] [,rows=</b><i>rows</i><b>]]</b></dt>
  <dd class="It-tag">Connect to a QEMU text console. <b>vc</b> may optionally be
      given a specific size.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>width</b> and <b>height</b> specify the width and height respectively of
      the console, in pixels.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>cols</b> and <b>rows</b> specify that the console be sized to fit a text
      console with the given dimensions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev ringbuf ,id=</b><i>id</i>
    <b>[,size=</b><i>size</i> <b>]</b></dt>
  <dd class="It-tag">Create a ring buffer with fixed size <b>size</b>.
      <i>size</i> must be a power of two and defaults to &quot;64K&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev file ,id=</b><i>id</i>
    <b>,path=</b><i>path</i></dt>
  <dd class="It-tag">Log all traffic received from the guest to a file.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>path</b> specifies the path of the file to be opened. This file will be
      created if it does not already exist, and overwritten if it does.
      <b>path</b> is required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev pipe ,id=</b><i>id</i>
    <b>,path=</b><i>path</i></dt>
  <dd class="It-tag">Create a two-way connection to the guest. The behaviour
      differs slightly between Windows hosts and other hosts:
    <div style="height: 1.00em;">&#x00A0;</div>
    On Windows, a single duplex pipe will be created at
      <i>\\.pipe\</i><b><i>path</i></b> <i></i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    On other hosts, 2 pipes will be created called
      <i></i><b><i>path</i></b><i>.in</i> and
      <i></i><b><i>path</i></b><i>.out</i>. Data written to
      <i></i><b><i>path</i></b> <i>.in</i> will be received by the guest. Data
      written by the guest can be read from
      <i></i><b><i>path</i></b><i>.out</i>. QEMU will not create these fifos,
      and requires them to be present.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>path</b> forms part of the pipe path as described above. <b>path</b> is
      required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev console ,id=</b><i>id</i></dt>
  <dd class="It-tag">Send traffic from the guest to QEMU's standard output.
      <b>console</b> does not take any options.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>console</b> is only available on Windows hosts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev serial ,id=</b><i>id</i>
    <b>,path=</b><b>path</b></dt>
  <dd class="It-tag">Send traffic from the guest to a serial device on the host.
    <div style="height: 1.00em;">&#x00A0;</div>
    On Unix hosts serial will actually accept any tty device, not only serial
      lines.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>path</b> specifies the name of the serial device to open.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev pty ,id=</b><i>id</i></dt>
  <dd class="It-tag">Create a new pseudo-terminal on the host and connect to it.
      <b>pty</b> does not take any options.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>pty</b> is not available on Windows hosts.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev stdio ,id=</b><i>id</i>
    <b>[,signal=on|off]</b></dt>
  <dd class="It-tag">Connect to standard input and standard output of the QEMU
      process.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>signal</b> controls if signals are enabled on the terminal, that
      includes exiting QEMU with the key sequence <b>Control-c</b>. This option
      is enabled by default, use <b>signal=off</b> to disable it.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev braille ,id=</b><i>id</i></dt>
  <dd class="It-tag">Connect to a local BrlAPI server. <b>braille</b> does not
      take any options.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev tty ,id=</b><i>id</i>
    <b>,path=</b><i>path</i></dt>
  <dd class="It-tag"><b>tty</b> is only available on Linux, Sun, FreeBSD,
      NetBSD, OpenBSD and DragonFlyBSD hosts. It is an alias for <b>serial</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>path</b> specifies the path to the tty. <b>path</b> is required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev parallel ,id=</b><i>id</i>
    <b>,path=</b><i>path</i></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev parport ,id=</b><i>id</i>
    <b>,path=</b><i>path</i></dt>
  <dd class="It-tag"><b>parallel</b> is only available on Linux, FreeBSD and
      DragonFlyBSD hosts.
    <div style="height: 1.00em;">&#x00A0;</div>
    Connect to a local parallel port.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>path</b> specifies the path to the parallel port device. <b>path</b> is
      required.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev spicevmc ,id=</b><i>id</i>
    <b>,debug=</b><i>debug</i> <b>, name=</b><i>name</i></dt>
  <dd class="It-tag"><b>spicevmc</b> is only available when spice support is
      built in.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>debug</b> debug level for spicevmc
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>name</b> name of spice channel to connect to
    <div style="height: 1.00em;">&#x00A0;</div>
    Connect to a spice virtual machine channel, such as vdiport.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chardev spiceport ,id=</b><i>id</i>
    <b>,debug=</b><i>debug</i> <b>, name=</b><i>name</i></dt>
  <dd class="It-tag"><b>spiceport</b> is only available when spice support is
      built in.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>debug</b> debug level for spicevmc
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>name</b> name of spice port to connect to
    <div style="height: 1.00em;">&#x00A0;</div>
    Connect to a spice port, allowing a Spice client to handle the traffic
      identified by a name (preferably a fqdn).</dd>
</dl>
<div class="Pp"></div>
<i>Device URL Syntax</i>
<div class="Pp"></div>
In addition to using normal file images for the emulated storage devices, QEMU
  can also use networked resources such as iSCSI devices. These are specified
  using a special URL syntax.
<dl class="Bl-tag">
  <dt class="It-tag"><b>iSCSI</b></dt>
  <dd class="It-tag">iSCSI support allows QEMU to access iSCSI resources
      directly and use as images for the guest storage. Both disk and cdrom
      images are supported.
    <div style="height: 1.00em;">&#x00A0;</div>
    Syntax for specifying iSCSI LUNs is
      &quot;iscsi://&lt;target-ip&gt;[:&lt;port&gt;]/&lt;target-iqn&gt;/&lt;lun&gt;&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    By default qemu will use the iSCSI initiator-name
      'iqn.2008-11.org.linux-kvm[:&lt;name&gt;]' but this can also be set from
      the command line or a configuration file.
    <div style="height: 1.00em;">&#x00A0;</div>
    Since version Qemu 2.4 it is possible to specify a iSCSI request timeout to
      detect stalled requests and force a reestablishment of the session. The
      timeout is specified in seconds. The default is 0 which means no timeout.
      Libiscsi 1.15.0 or greater is required for this feature.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example (without authentication):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 -iscsi initiator-name=iqn.2001-04.com.example:my-initiator \
        -cdrom iscsi://192.0.2.1/iqn.2001-04.com.example/2 \
        -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example (CHAP username/password via URL):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 -drive file=iscsi://user%password@192.0.2.1/iqn.2001-04.com.example/1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example (CHAP username/password via environment variables):
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        LIBISCSI_CHAP_USERNAME=&quot;user&quot; \
        LIBISCSI_CHAP_PASSWORD=&quot;password&quot; \
        qemu-system-i386 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    iSCSI support is an optional feature of QEMU and only available when
      compiled and linked against libiscsi.
    <div style="height: 1.00em;">&#x00A0;</div>
    iSCSI parameters such as username and password can also be specified via a
      configuration file. See qemu-doc for more information and examples.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>NBD</b></dt>
  <dd class="It-tag">QEMU supports NBD (Network Block Devices) both using TCP
      protocol as well as Unix Domain Sockets.
    <div style="height: 1.00em;">&#x00A0;</div>
    Syntax for specifying a NBD device using TCP
      &quot;nbd:&lt;server-ip&gt;:&lt;port&gt;[:exportname=&lt;export&gt;]&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Syntax for specifying a NBD device using Unix Domain Sockets
      &quot;nbd:unix:&lt;domain-socket&gt;[:exportname=&lt;export&gt;]&quot;
    <div style="height: 1.00em;">&#x00A0;</div>
    Example for TCP
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 --drive file=nbd:192.0.2.1:30000
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example for Unix Domain Sockets
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 --drive file=nbd:unix:/tmp/nbd-socket
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>SSH</b></dt>
  <dd class="It-tag">QEMU supports SSH (Secure Shell) access to remote disks.
    <div style="height: 1.00em;">&#x00A0;</div>
    Examples:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 -drive file=ssh://user@host/path/to/disk.img
        qemu-system-i386 -drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Currently authentication must be done using ssh-agent. Other authentication
      methods may be supported in future.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Sheepdog</b></dt>
  <dd class="It-tag">Sheepdog is a distributed storage system for QEMU. QEMU
      supports using either local sheepdog devices or remote networked devices.
    <div style="height: 1.00em;">&#x00A0;</div>
    Syntax for specifying a sheepdog device
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        sheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 --drive file=sheepdog://192.0.2.1:30000/MyVirtualMachine
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also &lt; <b>https://sheepdog.github.io/sheepdog/</b>&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>GlusterFS</b></dt>
  <dd class="It-tag">GlusterFS is a user space distributed file system. QEMU
      supports the use of GlusterFS volumes for hosting VM disk images using
      TCP, Unix Domain Sockets and RDMA transport protocols.
    <div style="height: 1.00em;">&#x00A0;</div>
    Syntax for specifying a VM disk image on GlusterFS volume is
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        URI:
        gluster[+type]://[host[:port]]/volume/path[?socket=...][,debug=N][,logfile=...]
        
        JSON:
        'json:{&quot;driver&quot;:&quot;qcow2&quot;,&quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,&quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,&quot;debug&quot;:N,&quot;logfile&quot;:&quot;...&quot;,
                                         &quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;...&quot;,&quot;port&quot;:&quot;...&quot;},
                                                   {&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;...&quot;}]}}'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Example
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        URI:
        qemu-system-x86_64 --drive file=gluster://192.0.2.1/testvol/a.img,
                                       file.debug=9,file.logfile=/var/log/qemu-gluster.log
        
        JSON:
        qemu-system-x86_64 'json:{&quot;driver&quot;:&quot;qcow2&quot;,
                                  &quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,
                                           &quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,
                                           &quot;debug&quot;:9,&quot;logfile&quot;:&quot;/var/log/qemu-gluster.log&quot;,
                                           &quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;1.2.3.4&quot;,&quot;port&quot;:24007},
                                                     {&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;/var/run/glusterd.socket&quot;}]}}'
        qemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
                                              file.debug=9,file.logfile=/var/log/qemu-gluster.log,
                                              file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
                                              file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    See also &lt; <b>http://www.gluster.org</b>&gt;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>HTTP/HTTPS/FTP/FTPS</b></dt>
  <dd class="It-tag">QEMU supports read-only access to files accessed over
      http(s) and ftp(s).
    <div style="height: 1.00em;">&#x00A0;</div>
    Syntax using a single filename:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        &lt;protocol&gt;://[&lt;username&gt;[:&lt;password&gt;]@]&lt;host&gt;/&lt;path&gt;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    where:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>protocol</b></dt>
  <dd class="It-tag">'http', 'https', 'ftp', or 'ftps'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>username</b></dt>
  <dd class="It-tag">Optional username for authentication to the remote
    server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>password</b></dt>
  <dd class="It-tag">Optional password for authentication to the remote
    server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>host</b></dt>
  <dd class="It-tag">Address of the remote server.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>path</b></dt>
  <dd class="It-tag">Path on the remote server, including any query string.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
The following options are also supported:
<dl class="Bl-tag">
  <dt class="It-tag"><b>url</b></dt>
  <dd class="It-tag">The full URL when passing options to the driver
    explicitly.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>readahead</b></dt>
  <dd class="It-tag">The amount of data to read ahead with each range request to
      the remote server. This value may optionally have the suffix 'T', 'G',
      'M', 'K', 'k' or 'b'. If it does not have a suffix, it will be assumed to
      be in bytes. The value must be a multiple of 512 bytes. It defaults to
      256k.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>sslverify</b></dt>
  <dd class="It-tag">Whether to verify the remote server's certificate when
      connecting over SSL. It can have the value 'on' or 'off'. It defaults to
      'on'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>cookie</b></dt>
  <dd class="It-tag">Send this cookie (it can also be a list of cookies
      separated by ';') with each outgoing request. Only supported when using
      protocols such as HTTP which support cookies, otherwise ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>timeout</b></dt>
  <dd class="It-tag">Set the timeout in seconds of the CURL connection. This
      timeout is the time that CURL waits for a response from the remote server
      to get the size of the image to be downloaded. If not set, the default
      timeout of 5 seconds is used.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
Note that when passing options to qemu explicitly, <b>driver</b> is the value of
  &lt;protocol&gt;.
<div style="height: 1.00em;">&#x00A0;</div>
Example: boot from a remote Fedora 20 live ISO image
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-system-x86_64 --drive media=cdrom,file=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
        
        qemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Example: boot from a remote Fedora 20 cloud image using a local overlay for
  writes, copy-on-read, and a readahead of 64k
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-img create -f qcow2 -o backing_file='json:{&quot;file.driver&quot;:&quot;http&quot;,, &quot;file.url&quot;:&quot;https://dl.fedoraproject.org/pub/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2&quot;,, &quot;file.readahead&quot;:&quot;64k&quot;}' /tmp/Fedora-x86_64-20-20131211.1-sda.qcow2
        
        qemu-system-x86_64 -drive file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on
</pre>
<div style="height: 1.00em;">&#x00A0;</div>
Example: boot from an image stored on a VMware vSphere server with a self-signed
  certificate using a local overlay for writes, a readahead of 64k and a timeout
  of 10 seconds.
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
        qemu-img create -f qcow2 -o backing_file='json:{&quot;file.driver&quot;:&quot;https&quot;,, &quot;file.url&quot;:&quot;https://user:password@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&amp;dsName=datastore1&quot;,, &quot;file.sslverify&quot;:&quot;off&quot;,, &quot;file.readahead&quot;:&quot;64k&quot;,, &quot;file.timeout&quot;:10}' /tmp/test.qcow2
        
        qemu-system-x86_64 -drive file=/tmp/test.qcow2
</pre>
</div>
<div class="Pp"></div>
<i>Bluetooth(R) options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bt hci[...]</b></dt>
  <dd class="It-tag">Defines the function of the corresponding Bluetooth HCI.
      -bt options are matched with the HCIs present in the chosen machine type.
      For example when emulating a machine with only one HCI built into it, only
      the first &quot;-bt hci[...]&quot; option is valid and defines the HCI's
      logic. The Transport Layer is decided by the machine type. Currently the
      machines &quot;n800&quot; and &quot;n810&quot; have one HCI and all other
      machines have none.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following three types are recognized:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bt hci,null</b></dt>
  <dd class="It-tag">(default) The corresponding Bluetooth HCI assumes no
      internal logic and will not respond to any HCI commands or emit
    events.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bt hci,host[:</b><i>id</i><b>]</b></dt>
  <dd class="It-tag">(&quot;bluez&quot; only) The corresponding HCI passes
      commands / events to / from the physical HCI identified by the name
      <i>id</i> (default: &quot;hci0&quot;) on the computer running QEMU. Only
      available on &quot;bluez&quot; capable systems like Linux.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bt hci[,vlan=</b><i>n</i><b>]</b></dt>
  <dd class="It-tag">Add a virtual, standard HCI that will participate in the
      Bluetooth scatternet <i>n</i> (default 0). Similarly to <b>-net</b> VLANs,
      devices inside a bluetooth network <i>n</i> can only communicate with
      other devices in the same network (scatternet).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bt vhci[,vlan=</b><i>n</i><b>]</b></dt>
  <dd class="It-tag">(Linux-host only) Create a HCI in scatternet <i>n</i>
      (default 0) attached to the host bluetooth stack instead of to the
      emulated target. This allows the host and target machines to participate
      in a common scatternet and communicate. Requires the Linux
      &quot;vhci&quot; driver installed. Can be used as following:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-i386 [...OPTIONS...] -bt hci,vlan=5 -bt vhci,vlan=5
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bt
    device:</b><i>dev</i><b>[,vlan=</b><i>n</i><b>]</b></dt>
  <dd class="It-tag">Emulate a bluetooth device <i>dev</i> and place it in
      network <i>n</i> (default 0). QEMU can only emulate one type of bluetooth
      devices currently:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>keyboard</b></dt>
  <dd class="It-tag">Virtual wireless keyboard implementing the HIDP bluetooth
      profile.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<div class="Pp"></div>
<i>TPM device options</i>
<div class="Pp"></div>
The general form of a TPM device option is:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-tpmdev</b> <i>backend</i> <b>,id=</b><i>id</i>
    <b>[,</b> <i>options</i><b>]</b></dt>
  <dd class="It-tag">Backend type must be: <b>passthrough</b>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The specific backend type will determine the applicable options. The
      &quot;-tpmdev&quot; option creates the TPM backend and requires a
      &quot;-device&quot; option that specifies the TPM frontend interface
      model.
    <div style="height: 1.00em;">&#x00A0;</div>
    Options to each backend are described below.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use 'help' to print all available TPM backend types.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu -tpmdev help
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-tpmdev passthrough, id=</b><i>id</i><b>,
    path=</b><i>path</i> <b>, cancel-path=</b><i>cancel-path</i></dt>
  <dd class="It-tag">(Linux-host only) Enable access to the host's TPM using the
      passthrough driver.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>path</b> specifies the path to the host's TPM device, i.e., on a Linux
      host this would be &quot;/dev/tpm0&quot;. <b>path</b> is optional and by
      default &quot;/dev/tpm0&quot; is used.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>cancel-path</b> specifies the path to the host TPM device's sysfs entry
      allowing for cancellation of an ongoing TPM command. <b>cancel-path</b> is
      optional and by default QEMU will search for the sysfs entry to use.
    <div style="height: 1.00em;">&#x00A0;</div>
    Some notes about using the host's TPM with the passthrough driver:
    <div style="height: 1.00em;">&#x00A0;</div>
    The TPM device accessed by the passthrough driver must not be used by any
      other application on the host.
    <div style="height: 1.00em;">&#x00A0;</div>
    Since the host's firmware (BIOS/UEFI) has already initialized the TPM, the
      VM's firmware (BIOS/UEFI) will not be able to initialize the TPM again and
      may therefore not show a TPM-specific menu that would otherwise allow the
      user to configure the TPM, e.g., allow the user to enable/disable or
      activate/deactivate the TPM. Further, if TPM ownership is released from
      within a VM then the host's TPM will get disabled and deactivated. To
      enable and activate the TPM again afterwards, the host has to be rebooted
      and the user is required to enter the firmware's menu to enable and
      activate the TPM. If the TPM is left disabled and/or deactivated most TPM
      commands will fail.
    <div style="height: 1.00em;">&#x00A0;</div>
    To create a passthrough TPM use the following two options:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the &quot;-tpmdev&quot; id is &quot;tpm0&quot; and is referenced
      by &quot;tpmdev=tpm0&quot; in the device option.</dd>
</dl>
<div class="Pp"></div>
<i>Linux/Multiboot boot specific</i>
<div class="Pp"></div>
When using these options, you can use a given Linux or Multiboot kernel without
  installing it in the disk image. It can be useful for easier testing of
  various kernels.
<dl class="Bl-tag">
  <dt class="It-tag"><b>-kernel</b> <i>bzImage</i></dt>
  <dd class="It-tag">Use <i>bzImage</i> as kernel image. The kernel can be
      either a Linux kernel or in multiboot format.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-append</b> <i>cmdline</i></dt>
  <dd class="It-tag">Use <i>cmdline</i> as kernel command line</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-initrd</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as initial ram disk.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-initrd &quot;</b><i>file1</i>
    <b>arg=foo,</b><i>file2</i> <b>&quot;</b></dt>
  <dd class="It-tag">This syntax is only available with multiboot.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use <i>file1</i> and <i>file2</i> as modules and pass arg=foo as parameter
      to the first module.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dtb</b> <i>file</i></dt>
  <dd class="It-tag">Use <i>file</i> as a device tree binary (dtb) image and
      pass it to the kernel on boot.</dd>
</dl>
<div class="Pp"></div>
<i>Debug/Expert options</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fw_cfg
    [name=]</b><i>name</i><b>,file=</b><i>file</i></dt>
  <dd class="It-tag">Add named fw_cfg entry with contents from file
    <i>file</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-fw_cfg
    [name=]</b><i>name</i><b>,string=</b><i>str</i></dt>
  <dd class="It-tag">Add named fw_cfg entry with contents from string
      <i>str</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    The terminating NUL character of the contents of <i>str</i> will not be
      included as part of the fw_cfg item data. To insert contents with embedded
      NUL characters, you have to use the <i>file</i> parameter.
    <div style="height: 1.00em;">&#x00A0;</div>
    The fw_cfg entries are passed by QEMU through to the guest.
    <div style="height: 1.00em;">&#x00A0;</div>
    Example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -fw_cfg name=opt/com.mycompany/blob,file=./my_blob.bin
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    creates an fw_cfg entry named opt/com.mycompany/blob with contents from
      ./my_blob.bin.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-serial</b> <i>dev</i></dt>
  <dd class="It-tag">Redirect the virtual serial port to host character device
      <i>dev</i>. The default device is &quot;vc&quot; in graphical mode and
      &quot;stdio&quot; in non graphical mode.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option can be used several times to simulate up to 4 serial ports.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use &quot;-serial none&quot; to disable all serial ports.
    <div style="height: 1.00em;">&#x00A0;</div>
    Available character devices are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>vc[:</b><i>W</i><b>x</b><i>H</i><b>]</b></dt>
  <dd class="It-tag">Virtual console. Optionally, a width and height can be
      given in pixel with
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        vc:800x600
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    It is also possible to specify width or height in characters:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        vc:80Cx24C
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pty</b></dt>
  <dd class="It-tag">[Linux only] Pseudo TTY (a new PTY is automatically
      allocated)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>none</b></dt>
  <dd class="It-tag">No device is allocated.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>null</b></dt>
  <dd class="It-tag">void device</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>chardev:</b><i>id</i></dt>
  <dd class="It-tag">Use a named character device defined with the
      &quot;-chardev&quot; option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/dev/XXX</b></dt>
  <dd class="It-tag">[Linux only] Use host tty, e.g. <i>/dev/ttyS0</i>. The host
      serial port parameters are set according to the emulated ones.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>/dev/parport</b><i>N</i></dt>
  <dd class="It-tag">[Linux only, parallel port only] Use host parallel port
      <i>N</i>. Currently SPP and EPP parallel port features can be used.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>file:</b><i>filename</i></dt>
  <dd class="It-tag">Write output to <i>filename</i>. No character can be
    read.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>stdio</b></dt>
  <dd class="It-tag">[Unix only] standard input/output</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>pipe:</b><i>filename</i></dt>
  <dd class="It-tag">name pipe <i>filename</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>COM</b><i>n</i></dt>
  <dd class="It-tag">[Windows only] Use host serial port <i>n</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>udp:[</b><i>remote_host</i><b>]:</b><i>remote_port</i><b>[@[</b><i>src_ip</i><b>]:</b><i>src_port</i><b>]</b></dt>
  <dd class="It-tag">This implements UDP Net Console. When <i>remote_host</i> or
      <i>src_ip</i> are not specified they default to 0.0.0.0. When not using a
      specified <i>src_port</i> a random port is automatically chosen.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you just want a simple readonly console you can use &quot;netcat&quot; or
      &quot;nc&quot;, by starting QEMU with: &quot;-serial udp::4555&quot; and
      nc as: &quot;nc -u -l -p 4555&quot;. Any time QEMU writes something to
      that port it will appear in the netconsole session.
    <div style="height: 1.00em;">&#x00A0;</div>
    If you plan to send characters back via netconsole or you want to stop and
      start QEMU a lot of times, you should have QEMU use the same source port
      each time by using something like &quot;-serial udp::4555@4556&quot; to
      QEMU. Another approach is to use a patched version of netcat which can
      listen to a TCP port and send and receive characters via udp. If you have
      a patched version of netcat which activates telnet remote echo and single
      char transfer, then you can use the following options to set up a netcat
      redirector to allow telnet on port 5555 to access the QEMU port.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&quot;QEMU Options:&quot;</dt>
  <dd class="It-tag">-serial udp::4555@4556</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;netcat options:&quot;</dt>
  <dd class="It-tag">-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;telnet options:&quot;</dt>
  <dd class="It-tag">localhost 5555</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>tcp:[</b><i>host</i><b>]:</b><i>port</i><b>[,</b><i>server</i><b>][,nowait][,nodelay][,reconnect=</b><i>seconds</i><b>]</b></dt>
  <dd class="It-tag">The TCP Net Console has two modes of operation. It can send
      the serial I/O to a location or wait for a connection from a location. By
      default the TCP Net Console is sent to <i>host</i> at the <i>port</i>. If
      you use the <i>server</i> option QEMU will wait for a client socket
      application to connect to the port before continuing, unless the
      &quot;nowait&quot; option was specified. The &quot;nodelay&quot; option
      disables the Nagle buffering algorithm. The &quot;reconnect&quot; option
      only applies if <i>noserver</i> is set, if the connection goes down it
      will attempt to reconnect at the given interval. If <i>host</i> is
      omitted, 0.0.0.0 is assumed. Only one TCP connection at a time is
      accepted. You can use &quot;telnet&quot; to connect to the corresponding
      character device.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&quot;Example to send tcp console to 192.168.0.2 port
    4444&quot;</dt>
  <dd class="It-tag">-serial tcp:192.168.0.2:4444</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;Example to listen and wait on port 4444 for
    connection&quot;</dt>
  <dd class="It-tag">-serial tcp::4444,server</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;Example to not wait and listen on ip 192.168.0.100
    port 4444&quot;</dt>
  <dd class="It-tag">-serial tcp:192.168.0.100:4444,server,nowait</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>telnet:</b><i>host</i><b>:</b><i>port</i><b>[,server][,nowait][,nodelay]</b></dt>
  <dd class="It-tag">The telnet protocol is used instead of raw tcp sockets. The
      options work the same as if you had specified &quot;-serial tcp&quot;. The
      difference is that the port acts like a telnet server or client using
      telnet option negotiation. This will also allow you to send the
      MAGIC_SYSRQ sequence if you use a telnet that supports sending the break
      sequence. Typically in unix telnet you do it with Control-] and then type
      &quot;send break&quot; followed by pressing the enter key.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>unix:</b><i>path</i><b>[,server][,nowait][,reconnect=</b><i>seconds</i><b>]</b></dt>
  <dd class="It-tag">A unix domain socket is used instead of a tcp socket. The
      option works the same as if you had specified &quot;-serial tcp&quot;
      except the unix domain socket <i>path</i> is used for connections.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>mon:</b><i>dev_string</i></dt>
  <dd class="It-tag">This is a special option to allow the monitor to be
      multiplexed onto another serial port. The monitor is accessed with key
      sequence of <b>Control-a</b> and then pressing <b>c</b>. <i>dev_string</i>
      should be any one of the serial devices specified above. An example to
      multiplex the monitor onto a telnet server listening on port 4444 would
      be:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&quot;-serial mon:telnet::4444,server,nowait&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">&#x00A0;</div>
When the monitor is multiplexed to stdio in this way, Ctrl+C will not terminate
  QEMU any more but will be passed to the guest instead.</div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>braille</b></dt>
  <dd class="It-tag">Braille device. This will use BrlAPI to display the braille
      output on a real or fake device.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>msmouse</b></dt>
  <dd class="It-tag">Three button serial mouse. Configure the guest to use
      Microsoft protocol.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-parallel</b> <i>dev</i></dt>
  <dd class="It-tag">Redirect the virtual parallel port to host device
      <i>dev</i> (same devices as the serial port). On Linux hosts,
      <i>/dev/parportN</i> can be used to use hardware devices connected on the
      corresponding host parallel port.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option can be used several times to simulate up to 3 parallel ports.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use &quot;-parallel none&quot; to disable all parallel ports.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-monitor</b> <i>dev</i></dt>
  <dd class="It-tag">Redirect the monitor to host device <i>dev</i> (same
      devices as the serial port). The default device is &quot;vc&quot; in
      graphical mode and &quot;stdio&quot; in non graphical mode. Use
      &quot;-monitor none&quot; to disable the default monitor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-qmp</b> <i>dev</i></dt>
  <dd class="It-tag">Like -monitor but opens in 'control' mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-qmp-pretty</b> <i>dev</i></dt>
  <dd class="It-tag">Like -qmp but uses pretty JSON formatting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-mon [chardev=]name[,mode=readline|control]</b></dt>
  <dd class="It-tag">Setup monitor on chardev <i>name</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-debugcon</b> <i>dev</i></dt>
  <dd class="It-tag">Redirect the debug console to host device <i>dev</i> (same
      devices as the serial port). The debug console is an I/O port which is
      typically port 0xe9; writing to that I/O port sends output to this device.
      The default device is &quot;vc&quot; in graphical mode and
      &quot;stdio&quot; in non graphical mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-pidfile</b> <i>file</i></dt>
  <dd class="It-tag">Store the QEMU process PID in <i>file</i>. It is useful if
      you launch QEMU from a script.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-singlestep</b></dt>
  <dd class="It-tag">Run the emulation in single step mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b></dt>
  <dd class="It-tag">Do not start CPU at startup (you must type 'c' in the
      monitor).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-realtime mlock=on|off</b></dt>
  <dd class="It-tag">Run qemu with realtime features. mlocking qemu and guest
      memory can be enabled via <b>mlock=on</b> (enabled by default).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-gdb</b> <i>dev</i></dt>
  <dd class="It-tag">Wait for gdb connection on device <i>dev</i>. Typical
      connections will likely be TCP-based, but also UDP, pseudo TTY, or even
      stdio are reasonable use case. The latter is allowing to start QEMU from
      within gdb and establish the connection via a pipe:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        (gdb) target remote | exec qemu-system-i386 -gdb stdio ...
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b></dt>
  <dd class="It-tag">Shorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP
      port 1234.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b> <i>item1</i><b>[,...]</b></dt>
  <dd class="It-tag">Enable logging of specified items. Use '-d help' for a list
      of log items.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-D</b> <i>logfile</i></dt>
  <dd class="It-tag">Output log in <i>logfile</i> instead of to stderr</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dfilter</b> <i>range1</i><b>[,...]</b></dt>
  <dd class="It-tag">Filter debug output to that relevant to a range of target
      addresses. The filter spec can be either <i>start</i>+<i>size</i>,
      <i>start</i>- <i>size</i> or <i>start</i>..<i>end</i> where <i>start</i>
      <i>end</i> and <i>size</i> are the addresses and sizes required. For
      example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        -dfilter 0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Will dump output for any code in the 0x1000 sized block starting at 0x8000
      and the 0x200 sized block starting at 0xffffffc000080000 and another
      0x1000 sized block starting at 0xffffffc00005f000.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-L</b> <i>path</i></dt>
  <dd class="It-tag">Set the directory for the BIOS, VGA BIOS and keymaps.
    <div style="height: 1.00em;">&#x00A0;</div>
    To list all the data directories, use &quot;-L help&quot;.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bios</b> <i>file</i></dt>
  <dd class="It-tag">Set the filename for the BIOS.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-enable-kvm</b></dt>
  <dd class="It-tag">Enable KVM full virtualization support. This option is only
      available if KVM support is enabled when compiling.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-enable-hax</b></dt>
  <dd class="It-tag">Enable HAX (Hardware-based Acceleration eXecution) support.
      This option is only available if HAX support is enabled when compiling.
      HAX is only applicable to MAC and Windows platform, and thus does not
      conflict with KVM.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-xen-domid</b> <i>id</i></dt>
  <dd class="It-tag">Specify xen guest domain <i>id</i> (XEN only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-xen-create</b></dt>
  <dd class="It-tag">Create domain using xen hypercalls, bypassing xend.
      Warning: should not be used when xend is in use (XEN only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-xen-attach</b></dt>
  <dd class="It-tag">Attach to existing xen domain. xend will use this when
      starting QEMU (XEN only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-reboot</b></dt>
  <dd class="It-tag">Exit instead of rebooting.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-shutdown</b></dt>
  <dd class="It-tag">Don't exit QEMU on guest shutdown, but instead only stop
      the emulation. This allows for instance switching to monitor to commit
      changes to the disk image.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-loadvm</b> <i>file</i></dt>
  <dd class="It-tag">Start right away with a saved state (&quot;loadvm&quot; in
      monitor)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-daemonize</b></dt>
  <dd class="It-tag">Daemonize the QEMU process after initialization. QEMU will
      not detach from standard IO until it is ready to receive connections on
      any of its devices. This option is a useful way for external programs to
      launch QEMU without having to cope with initialization race
    conditions.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-option-rom</b> <i>file</i></dt>
  <dd class="It-tag">Load the contents of <i>file</i> as an option ROM. This
      option is useful to load things like EtherBoot.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-rtc
    [base=utc|localtime|</b><i>date</i><b>][,clock=host|vm][,driftfix=none|slew]</b></dt>
  <dd class="It-tag">Specify <b>base</b> as &quot;utc&quot; or
      &quot;localtime&quot; to let the RTC start at the current UTC or local
      time, respectively. &quot;localtime&quot; is required for correct date in
      MS-DOS or Windows. To start at a specific point in time, provide
      <i>date</i> in the format &quot;2006-06-17T16:01:21&quot; or
      &quot;2006-06-17&quot;. The default base is UTC.
    <div style="height: 1.00em;">&#x00A0;</div>
    By default the RTC is driven by the host system time. This allows using of
      the RTC as accurate reference clock inside the guest, specifically if the
      host time is smoothly following an accurate external reference clock, e.g.
      via NTP. If you want to isolate the guest time from the host, you can set
      <b>clock</b> to &quot;rt&quot; instead. To even prevent it from
      progressing during suspension, you can set it to &quot;vm&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    Enable <b>driftfix</b> (i386 targets only) if you experience time drift
      problems, specifically with Windows' ACPI HAL. This option will try to
      figure out how many timer interrupts were not processed by the Windows
      guest and will re-inject them.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-icount
    [shift=</b><i>N</i><b>|auto][,rr=record|replay,rrfile=</b>
    <i>filename</i><b>,rrsnapshot=</b><i>snapshot</i><b>]</b></dt>
  <dd class="It-tag">Enable virtual instruction counter. The virtual cpu will
      execute one instruction every 2^ <i>N</i> ns of virtual time. If
      &quot;auto&quot; is specified then the virtual cpu speed will be
      automatically adjusted to keep virtual time within a few seconds of real
      time.
    <div style="height: 1.00em;">&#x00A0;</div>
    When the virtual cpu is sleeping, the virtual time will advance at default
      speed unless <b>sleep=on|off</b> is specified. With <b>sleep=on|off</b>,
      the virtual time will jump to the next timer deadline instantly whenever
      the virtual cpu goes to sleep mode and will not advance if no timer is
      enabled. This behavior give deterministic execution times from the guest
      point of view.
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that while this option can give deterministic behavior, it does not
      provide cycle accurate emulation. Modern CPUs contain superscalar out of
      order cores with complex cache hierarchies. The number of instructions
      executed often has little or no correlation with actual performance.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>align=on</b> will activate the delay algorithm which will try to
      synchronise the host clock and the virtual clock. The goal is to have a
      guest running at the real frequency imposed by the shift option. Whenever
      the guest clock is behind the host clock and if <b>align=on</b> is
      specified then we print a message to the user to inform about the delay.
      Currently this option does not work when <b>shift</b> is &quot;auto&quot;.
      Note: The sync algorithm will work for those shift values for which the
      guest clock runs ahead of the host clock. Typically this happens when the
      shift value is high (how high depends on the host machine).
    <div style="height: 1.00em;">&#x00A0;</div>
    When <b>rr</b> option is specified deterministic record/replay is enabled.
      Replay log is written into <i>filename</i> file in record mode and read
      from this file in replay mode.
    <div style="height: 1.00em;">&#x00A0;</div>
    Option rrsnapshot is used to create new vm snapshot named <i>snapshot</i> at
      the start of execution recording. In replay mode this option is used to
      load the initial VM state.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-watchdog</b> <i>model</i></dt>
  <dd class="It-tag">Create a virtual hardware watchdog device. Once enabled (by
      a guest action), the watchdog must be periodically polled by an agent
      inside the guest or else the guest will be restarted. Choose a model for
      which your guest has drivers.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>model</i> is the model of hardware watchdog to emulate. Use
      &quot;-watchdog help&quot; to list available hardware models. Only one
      watchdog can be enabled for a guest.
    <div style="height: 1.00em;">&#x00A0;</div>
    The following models may be available:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>ib700</b></dt>
  <dd class="It-tag">iBASE 700 is a very simple ISA watchdog with a single
      timer.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>i6300esb</b></dt>
  <dd class="It-tag">Intel 6300ESB I/O controller hub is a much more featureful
      PCI-based dual-timer watchdog.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>diag288</b></dt>
  <dd class="It-tag">A virtual watchdog for s390x backed by the diagnose 288
      hypercall (currently KVM only).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-watchdog-action</b> <i>action</i></dt>
  <dd class="It-tag">The <i>action</i> controls what QEMU will do when the
      watchdog timer expires. The default is &quot;reset&quot; (forcefully reset
      the guest). Other possible actions are: &quot;shutdown&quot; (attempt to
      gracefully shutdown the guest), &quot;poweroff&quot; (forcefully poweroff
      the guest), &quot;pause&quot; (pause the guest), &quot;debug&quot; (print
      a debug message and continue), or &quot;none&quot; (do nothing).
    <div style="height: 1.00em;">&#x00A0;</div>
    Note that the &quot;shutdown&quot; action requires that the guest responds
      to ACPI signals, which it may not be able to do in the sort of situations
      where the watchdog would have expired, and thus &quot;-watchdog-action
      shutdown&quot; is not recommended for production use.
    <div style="height: 1.00em;">&#x00A0;</div>
    Examples:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&quot;-watchdog i6300esb -watchdog-action pause&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;-watchdog ib700&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-echr</b> <i>numeric_ascii_value</i></dt>
  <dd class="It-tag">Change the escape character used for switching to the
      monitor when using monitor and serial sharing. The default is 0x01 when
      using the &quot;-nographic&quot; option. 0x01 is equal to pressing
      &quot;Control-a&quot;. You can select a different character from the ascii
      control keys where 1 through 26 map to Control-a through Control-z. For
      instance you could use the either of the following to change the escape
      character to Control-t.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">&quot;-echr 0x14&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&quot;-echr 20&quot;</dt>
  <dd class="It-tag"></dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-virtioconsole</b> <i>c</i></dt>
  <dd class="It-tag">Set virtio console.
    <div style="height: 1.00em;">&#x00A0;</div>
    This option is maintained for backward compatibility.
    <div style="height: 1.00em;">&#x00A0;</div>
    Please use &quot;-device virtconsole&quot; for the new way of
    invocation.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-show-cursor</b></dt>
  <dd class="It-tag">Show cursor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-tb-size</b> <i>n</i></dt>
  <dd class="It-tag">Set TB size.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-incoming
    tcp:[</b><i>host</i><b>]:</b><i>port</i><b>[,to=</b>
    <i>maxport</i><b>][,ipv4][,ipv6]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-incoming
    rdma:</b><i>host</i><b>:</b><i>port</i><b>[,ipv4][,ipv6]</b></dt>
  <dd class="It-tag">Prepare for incoming migration, listen on a given tcp
    port.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-incoming unix:</b><i>socketpath</i></dt>
  <dd class="It-tag">Prepare for incoming migration, listen on a given unix
      socket.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-incoming fd:</b><i>fd</i></dt>
  <dd class="It-tag">Accept incoming migration from a given filedescriptor.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-incoming exec:</b><i>cmdline</i></dt>
  <dd class="It-tag">Accept incoming migration as an output from specified
      external command.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-incoming defer</b></dt>
  <dd class="It-tag">Wait for the URI to be specified via migrate_incoming. The
      monitor can be used to change settings (such as migration parameters)
      prior to issuing the migrate_incoming to allow the migration to
    begin.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-only-migratable</b></dt>
  <dd class="It-tag">Only allow migratable devices. Devices will not be allowed
      to enter an unmigratable state.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-nodefaults</b></dt>
  <dd class="It-tag">Don't create default devices. Normally, QEMU sets the
      default devices like serial port, parallel port, virtual console, monitor
      device, VGA adapter, floppy and CD-ROM drive and others. The
      &quot;-nodefaults&quot; option will disable all those default
    devices.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-chroot</b> <i>dir</i></dt>
  <dd class="It-tag">Immediately before starting guest execution, chroot to the
      specified directory. Especially useful in combination with -runas.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-runas</b> <i>user</i></dt>
  <dd class="It-tag">Immediately before starting guest execution, drop root
      privileges, switching to the specified user.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-prom-env</b> <i>variable</i><b>=</b><i>value</i></dt>
  <dd class="It-tag">Set OpenBIOS nvram <i>variable</i> to given <i>value</i>
      (PPC, SPARC only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-semihosting</b></dt>
  <dd class="It-tag">Enable semihosting mode (ARM, M68K, Xtensa, MIPS
    only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-semihosting-config
    [enable=on|off][,target=native|gdb|auto][,arg=str[,...]]</b></dt>
  <dd class="It-tag">Enable and configure semihosting (ARM, M68K, Xtensa, MIPS
      only).</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>target=</b><b>&quot;native|gdb|auto&quot;</b><b></b></dt>
  <dd class="It-tag">Defines where the semihosting calls will be addressed, to
      QEMU (&quot;native&quot;) or to GDB (&quot;gdb&quot;). The default is
      &quot;auto&quot;, which means &quot;gdb&quot; during debug sessions and
      &quot;native&quot; otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>arg=</b><i>str1</i><b>,arg=</b><i>str2</i><b>,...</b></dt>
  <dd class="It-tag">Allows the user to pass input arguments, and can be used
      multiple times to build up a list. The old-style
      &quot;-kernel&quot;/&quot;-append&quot; method of passing a command line
      is still supported for backward compatibility. If both the
      &quot;--semihosting-config arg&quot; and the
      &quot;-kernel&quot;/&quot;-append&quot; are specified, the former is
      passed to semihosting as it always takes precedence.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-old-param</b></dt>
  <dd class="It-tag">Old param mode (ARM only).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-sandbox</b> <i>arg</i></dt>
  <dd class="It-tag">Enable Seccomp mode 2 system call filter. 'on' will enable
      syscall filtering and 'off' will disable it. The default is 'off'.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-readconfig</b> <i>file</i></dt>
  <dd class="It-tag">Read device configuration from <i>file</i>. This approach
      is useful when you want to spawn QEMU process with many command line
      options but you don't want to exceed the command line character
    limit.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-writeconfig</b> <i>file</i></dt>
  <dd class="It-tag">Write device configuration to <i>file</i>. The <i>file</i>
      can be either filename to save command line and device configuration into
      file or dash &quot;-&quot;) character to print the output to stdout. This
      can be later used as input file for &quot;-readconfig&quot; option.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-nodefconfig</b></dt>
  <dd class="It-tag">Normally QEMU loads configuration files from
      <i>sysconfdir</i> and <i>datadir</i> at startup. The
      &quot;-nodefconfig&quot; option will prevent QEMU from loading any of
      those config files.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-no-user-config</b></dt>
  <dd class="It-tag">The &quot;-no-user-config&quot; option makes QEMU not load
      any of the user-provided config files on <i>sysconfdir</i>, but won't make
      it skip the QEMU-provided config files from <i>datadir</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-trace
    [[enable=]</b><i>pattern</i><b>][,events=</b><i>file</i>
    <b>][,file=</b><i>file</i> <b>]</b></dt>
  <dd class="It-tag">Specify tracing options.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>[enable=]</b><i>pattern</i></dt>
  <dd class="It-tag">Immediately enable events matching <i>pattern</i>. The file
      must contain one event name (as listed in the <i>trace-events-all</i>
      file) per line; globbing patterns are accepted too. This option is only
      available if QEMU has been compiled with the <i>simple</i>, <i>log</i> or
      <i>ftrace</i> tracing backend. To specify multiple events or patterns,
      specify the <b>-trace</b> option multiple times.
    <div style="height: 1.00em;">&#x00A0;</div>
    Use &quot;-trace help&quot; to print a list of names of trace points.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>events=</b><i>file</i></dt>
  <dd class="It-tag">Immediately enable events listed in <i>file</i>. The file
      must contain one event name (as listed in the <i>trace-events-all</i>
      file) per line; globbing patterns are accepted too. This option is only
      available if QEMU has been compiled with the <i>simple</i>, <i>log</i> or
      <i>ftrace</i> tracing backend.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>file=</b><i>file</i></dt>
  <dd class="It-tag">Log output traces to <i>file</i>. This option is only
      available if QEMU has been compiled with the <i>simple</i> tracing
      backend.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-enable-fips</b></dt>
  <dd class="It-tag">Enable FIPS 140-2 compliance mode.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-msg timestamp[=on|off]</b></dt>
  <dd class="It-tag">prepend a timestamp to each log message.(default:on)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-dump-vmstate</b> <i>file</i></dt>
  <dd class="It-tag">Dump json-encoded vmstate information for current machine
      type to file in <i>file</i></dd>
</dl>
<div class="Pp"></div>
<i>Generic object creation</i>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object</b>
    <i>typename</i><b>[,</b><i>prop1</i><b>=</b><i>value1</i><b>,...]</b></dt>
  <dd class="It-tag">Create a new object of type <i>typename</i> setting
      properties in the order they are specified. Note that the 'id' property
      must be set. These objects are placed in the '/objects' path.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    memory-backend-file,id=</b><i>id</i><b>,size=</b>
    <i>size</i><b>,mem-path=</b> <i>dir</i><b>,share=</b><i>on|off</i></dt>
  <dd class="It-tag">Creates a memory file backend object, which can be used to
      back the guest RAM with huge pages. The <b>id</b> parameter is a unique ID
      that will be used to reference this memory region when configuring the
      <b>-numa</b> argument. The <b>size</b> option provides the size of the
      memory region, and accepts common suffixes, eg <b>500M</b>. The
      <b>mem-path</b> provides the path to either a shared memory or huge page
      filesystem mount. The <b>share</b> boolean option determines whether the
      memory region is marked as private to QEMU, or shared. The latter allows a
      co-operating external process to access the QEMU memory region.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    rng-random,id=</b><i>id</i><b>,filename=</b><i>/dev/random</i></dt>
  <dd class="It-tag">Creates a random number generator backend which obtains
      entropy from a device on the host. The <b>id</b> parameter is a unique ID
      that will be used to reference this entropy backend from the
      <b>virtio-rng</b> device. The <b>filename</b> parameter specifies which
      file to obtain entropy from and if omitted defaults to
    <b>/dev/random</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    rng-egd,id=</b><i>id</i><b>,chardev=</b><i>chardevid</i></dt>
  <dd class="It-tag">Creates a random number generator backend which obtains
      entropy from an external daemon running on the host. The <b>id</b>
      parameter is a unique ID that will be used to reference this entropy
      backend from the <b>virtio-rng</b> device. The <b>chardev</b> parameter is
      the unique ID of a character device backend that provides the connection
      to the RNG daemon.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    tls-creds-anon,id=</b><i>id</i><b>,endpoint=</b><i>endpoint</i><b>,dir=</b><i>/path/to/cred/dir</i><b>,verify-peer=</b><i>on|off</i></dt>
  <dd class="It-tag">Creates a TLS anonymous credentials object, which can be
      used to provide TLS support on network backends. The <b>id</b> parameter
      is a unique ID which network backends will use to access the credentials.
      The <b>endpoint</b> is either <b>server</b> or <b>client</b> depending on
      whether the QEMU network backend that uses the credentials will be acting
      as a client or as a server. If <b>verify-peer</b> is enabled (the default)
      then once the handshake is completed, the peer credentials will be
      verified, though this is a no-op for anonymous credentials.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>dir</i> parameter tells QEMU where to find the credential files. For
      server endpoints, this directory may contain a file <i>dh-params.pem</i>
      providing diffie-hellman parameters to use for the TLS server. If the file
      is missing, QEMU will generate a set of DH parameters at startup. This is
      a computationally expensive operation that consumes random pool entropy,
      so it is recommended that a persistent set of parameters be generated
      upfront and saved.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    tls-creds-x509,id=</b><i>id</i><b>,endpoint=</b><i>endpoint</i><b>,dir=</b><i>/path/to/cred/dir</i><b>,verify-peer=</b><i>on|off</i><b>,passwordid=</b><i>id</i></dt>
  <dd class="It-tag">Creates a TLS anonymous credentials object, which can be
      used to provide TLS support on network backends. The <b>id</b> parameter
      is a unique ID which network backends will use to access the credentials.
      The <b>endpoint</b> is either <b>server</b> or <b>client</b> depending on
      whether the QEMU network backend that uses the credentials will be acting
      as a client or as a server. If <b>verify-peer</b> is enabled (the default)
      then once the handshake is completed, the peer credentials will be
      verified. With x509 certificates, this implies that the clients must be
      provided with valid client certificates too.
    <div style="height: 1.00em;">&#x00A0;</div>
    The <i>dir</i> parameter tells QEMU where to find the credential files. For
      server endpoints, this directory may contain a file <i>dh-params.pem</i>
      providing diffie-hellman parameters to use for the TLS server. If the file
      is missing, QEMU will generate a set of DH parameters at startup. This is
      a computationally expensive operation that consumes random pool entropy,
      so it is recommended that a persistent set of parameters be generated
      upfront and saved.
    <div style="height: 1.00em;">&#x00A0;</div>
    For x509 certificate credentials the directory will contain further files
      providing the x509 certificates. The certificates must be stored in PEM
      format, in filenames <i>ca-cert.pem</i>, <i>ca-crl.pem</i> (optional),
      <i>server-cert.pem</i> (only servers), <i>server-key.pem</i> (only
      servers), <i>client-cert.pem</i> (only clients), and <i>client-key.pem</i>
      (only clients).
    <div style="height: 1.00em;">&#x00A0;</div>
    For the <i>server-key.pem</i> and <i>client-key.pem</i> files which contain
      sensitive private keys, it is possible to use an encrypted version by
      providing the <i>passwordid</i> parameter. This provides the ID of a
      previously created &quot;secret&quot; object containing the password for
      decryption.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    filter-buffer,id=</b><i>id</i><b>,netdev=</b><i>netdevid</i>
    <b>,interval=</b>
    <i>t</i><b>[,queue=</b><i>all|rx|tx</i><b>][,status=</b><i>on|off</i><b>]</b></dt>
  <dd class="It-tag">Interval <i>t</i> can't be 0, this filter batches the
      packet delivery: all packets arriving in a given interval on netdev
      <i>netdevid</i> are delayed until the end of the interval. Interval is in
      microseconds. <b>status</b> is optional that indicate whether the
      netfilter is on (enabled) or off (disabled), the default status for
      netfilter will be 'on'.
    <div style="height: 1.00em;">&#x00A0;</div>
    queue <i>all|rx|tx</i> is an option that can be applied to any netfilter.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>all</b>: the filter is attached both to the receive and the transmit
      queue of the netdev (default).
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>rx</b>: the filter is attached to the receive queue of the netdev, where
      it will receive packets sent to the netdev.
    <div style="height: 1.00em;">&#x00A0;</div>
     <b>tx</b>: the filter is attached to the transmit queue of the netdev,
      where it will receive packets sent by the netdev.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    filter-mirror,id=</b><i>id</i><b>,netdev=</b><i>netdevid</i>
    <b>,outdev=</b><i>chardevid</i><b>[,queue=</b><i>all|rx|tx</i><b>]</b></dt>
  <dd class="It-tag">filter-mirror on netdev <i>netdevid</i>,mirror net packet
      to chardev <i>chardevid</i></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    filter-redirector,id=</b><i>id</i><b>,netdev=</b>
    <i>netdevid</i><b>,indev=</b> <i>chardevid</i><b>,</b></dt>
  <dd class="It-tag">outdev=<i>chardevid</i>[,queue=<i>all|rx|tx</i>]
    <div style="height: 1.00em;">&#x00A0;</div>
    filter-redirector on netdev <i>netdevid</i>,redirect filter's net packet to
      chardev <i>chardevid</i>,and redirect indev's packet to filter. Create a
      filter-redirector we need to differ outdev id from indev id, id can not be
      the same. we can just use indev or outdev, but at least one of indev or
      outdev need to be specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    filter-rewriter,id=</b><i>id</i><b>,netdev=</b><i>netdevid</i><b>,rewriter-mode=</b><i>mode</i><b>[,queue=</b><i>all|rx|tx</i><b>]</b></dt>
  <dd class="It-tag">Filter-rewriter is a part of COLO project.It will rewrite
      tcp packet to secondary from primary to keep secondary tcp connection,and
      rewrite tcp packet to primary from secondary make tcp packet can be
      handled by client.
    <div style="height: 1.00em;">&#x00A0;</div>
    usage: colo secondary: -object
      filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0 -object
      filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1 -object
      filter-rewriter,id=rew0,netdev=hn0,queue=all</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    filter-dump,id=</b><i>id</i><b>,netdev=</b><i>dev</i>
    <b>[,file=</b><i>filename</i> <b>][,maxlen=</b><i>len</i><b>]</b></dt>
  <dd class="It-tag">Dump the network traffic on netdev <i>dev</i> to the file
      specified by <i>filename</i>. At most <i>len</i> bytes (64k by default)
      per packet are stored. The file format is libpcap, so it can be analyzed
      with tools such as tcpdump or Wireshark.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    colo-compare,id=</b><i>id</i><b>,primary_in=</b><i>chardevid</i><b>,secondary_in=</b><i>chardevid</i><b>,</b></dt>
  <dd class="It-tag">outdev=<i>chardevid</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    Colo-compare gets packet from primary_in <i>chardevid</i> and
      secondary_in<i>chardevid</i>, than compare primary packet with secondary
      packet. If the packets are same, we will output primary packet to outdev
      <i>chardevid</i>, else we will notify colo-frame do checkpoint and send
      primary packet to outdev <i>chardevid</i>.
    <div style="height: 1.00em;">&#x00A0;</div>
    we must use it with the help of filter-mirror and filter-redirector.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        primary:
        -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown
        -device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66
        -chardev socket,id=mirror0,host=3.3.3.3,port=9003,server,nowait
        -chardev socket,id=compare1,host=3.3.3.3,port=9004,server,nowait
        -chardev socket,id=compare0,host=3.3.3.3,port=9001,server,nowait
        -chardev socket,id=compare0-0,host=3.3.3.3,port=9001
        -chardev socket,id=compare_out,host=3.3.3.3,port=9005,server,nowait
        -chardev socket,id=compare_out0,host=3.3.3.3,port=9005
        -object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0
        -object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
        -object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
        -object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0
        
        secondary:
        -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown
        -device e1000,netdev=hn0,mac=52:a4:00:12:78:66
        -chardev socket,id=red0,host=3.3.3.3,port=9003
        -chardev socket,id=red1,host=3.3.3.3,port=9004
        -object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
        -object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you want to know the detail of above command line, you can read the
      colo-compare git log.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    cryptodev-backend-builtin,id=</b><i>id</i><b>[,queues=</b>
    <i>queues</i><b>]</b></dt>
  <dd class="It-tag">Creates a cryptodev backend which executes crypto opreation
      from the QEMU cipher APIS. The <i>id</i> parameter is a unique ID that
      will be used to reference this cryptodev backend from the
      <b>virtio-crypto</b> device. The <i>queues</i> parameter is optional,
      which specify the queue number of cryptodev backend, the default of
      <i>queues</i> is 1.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # qemu-system-x86_64 \
        [...] \
        -object cryptodev-backend-builtin,id=cryptodev0 \
        -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
        [...]
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    secret,id=</b><i>id</i><b>,data=</b><i>string</i>
    <b>,format=</b><i>raw|base64</i>
    <b>[,keyid=</b><i>secretid</i><b>,iv=</b><i>string</i><b>]</b></dt>
  <dd class="It-tag"></dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-object
    secret,id=</b><i>id</i><b>,file=</b><i>filename</i>
    <b>,format=</b><i>raw|base64</i>
    <b>[,keyid=</b><i>secretid</i><b>,iv=</b><i>string</i><b>]</b></dt>
  <dd class="It-tag">Defines a secret to store a password, encryption key, or
      some other sensitive data. The sensitive data can either be passed
      directly via the <i>data</i> parameter, or indirectly via the <i>file</i>
      parameter. Using the <i>data</i> parameter is insecure unless the
      sensitive data is encrypted.
    <div style="height: 1.00em;">&#x00A0;</div>
    The sensitive data can be provided in raw format (the default), or base64.
      When encoded as JSON, the raw format only supports valid UTF-8 characters,
      so base64 is recommended for sending binary data. QEMU will convert from
      which ever format is provided to the format it needs internally. eg, an
      RBD password can be provided in raw format, even though it will be base64
      encoded when passed onto the RBD sever.
    <div style="height: 1.00em;">&#x00A0;</div>
    For added protection, it is possible to encrypt the data associated with a
      secret using the AES-256-CBC cipher. Use of encryption is indicated by
      providing the <i>keyid</i> and <i>iv</i> parameters. The <i>keyid</i>
      parameter provides the ID of a previously defined secret that contains the
      AES-256 decryption key. This key should be 32-bytes long and be base64
      encoded. The <i>iv</i> parameter provides the random initialization vector
      used for encryption of this particular secret and should be a base64
      encrypted string of the 16-byte IV.
    <div style="height: 1.00em;">&#x00A0;</div>
    The simplest (insecure) usage is to provide the secret inline
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # $QEMU -object secret,id=sec0,data=letmein,format=raw
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The simplest secure usage is to provide the secret via a file
    <div style="height: 1.00em;">&#x00A0;</div>
    # echo -n &quot;letmein&quot; &gt; mypasswd.txt # $QEMU -object
      secret,id=sec0,file=mypasswd.txt,format=raw
    <div style="height: 1.00em;">&#x00A0;</div>
    For greater security, AES-256-CBC should be used. To illustrate usage,
      consider the openssl command line tool which can encrypt the data. Note
      that when encrypting, the plaintext must be padded to the cipher block
      size (32 bytes) using the standard PKCS#5/6 compatible padding algorithm.
    <div style="height: 1.00em;">&#x00A0;</div>
    First a master key needs to be created in base64 encoding:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # openssl rand -base64 32 &gt; key.b64
        # KEY=$(base64 -d key.b64 | hexdump  -v -e '/1 &quot;%02X&quot;')
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Each secret to be encrypted needs to have a random initialization vector
      generated. These do not need to be kept secret
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # openssl rand -base64 16 &gt; iv.b64
        # IV=$(base64 -d iv.b64 | hexdump  -v -e '/1 &quot;%02X&quot;')
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The secret to be defined can now be encrypted, in this case we're telling
      openssl to base64 encode the result, but it could be left as raw bytes if
      desired.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # SECRET=$(echo -n &quot;letmein&quot; |
        openssl enc -aes-256-cbc -a -K $KEY -iv $IV)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    When launching QEMU, create a master secret pointing to &quot;key.b64&quot;
      and specify that to be used to decrypt the user password. Pass the
      contents of &quot;iv.b64&quot; to the second secret
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        # $QEMU \
        -object secret,id=secmaster0,format=base64,file=key.b64 \
        -object secret,id=sec0,keyid=secmaster0,format=base64,\
        data=$SECRET,iv=$(&lt;iv.b64)
    </pre>
  </dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<div class="Pp"></div>
During the graphical emulation, you can use special key combinations to change
  modes. The default key mappings are shown below, but if you use
  &quot;-alt-grab&quot; then the modifier is Ctrl-Alt-Shift (instead of
  Ctrl-Alt) and if you use &quot;-ctrl-grab&quot; then the modifier is the right
  Ctrl key (instead of Ctrl-Alt):
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-Alt-f</b></dt>
  <dd class="It-tag">Toggle full screen</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-Alt-+</b></dt>
  <dd class="It-tag">Enlarge the screen</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-Alt--</b></dt>
  <dd class="It-tag">Shrink the screen</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-Alt-u</b></dt>
  <dd class="It-tag">Restore the screen's un-scaled dimensions</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-Alt-n</b></dt>
  <dd class="It-tag">Switch to virtual console 'n'. Standard console mappings
      are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><i>1</i></dt>
  <dd class="It-tag">Target system display</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>2</i></dt>
  <dd class="It-tag">Monitor</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><i>3</i></dt>
  <dd class="It-tag">Serial port</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;"></div>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-Alt</b></dt>
  <dd class="It-tag">Toggle mouse and keyboard grab.</dd>
</dl>
<div class="Pp"></div>
In the virtual consoles, you can use <b>Ctrl-Up</b>, <b>Ctrl-Down</b>,
  <b>Ctrl-PageUp</b> and <b>Ctrl-PageDown</b> to move in the back log.
<div class="Pp"></div>
During emulation, if you are using a character backend multiplexer (which is the
  default if you are using <b>-nographic</b>) then several commands are
  available via an escape sequence. These key sequences all start with an escape
  character, which is <b>Ctrl-a</b> by default, but can be changed with
  <b>-echr</b>. The list below assumes you're using the default.
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a h</b></dt>
  <dd class="It-tag">Print this help</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a x</b></dt>
  <dd class="It-tag">Exit emulator</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a s</b></dt>
  <dd class="It-tag">Save disk data back to file (if -snapshot)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a t</b></dt>
  <dd class="It-tag">Toggle console timestamps</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a b</b></dt>
  <dd class="It-tag">Send break (magic sysrq in Linux)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a c</b></dt>
  <dd class="It-tag">Rotate between the frontends connected to the multiplexer
      (usually this switches between the monitor and the console)</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>Ctrl-a Ctrl-a</b></dt>
  <dd class="It-tag">Send the escape character to the frontend</dd>
</dl>
<div class="Pp"></div>
The following options are specific to the PowerPC emulation:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>
    <i>W</i><b>x</b><i>H</i><b>[x</b><i>DEPTH</i><b>]</b></dt>
  <dd class="It-tag">Set the initial VGA graphic mode. The default is
      800x600x32.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-prom-env</b> <i>string</i></dt>
  <dd class="It-tag">Set OpenBIOS variables in NVRAM, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-ppc -prom-env 'auto-boot?=false' \
         -prom-env 'boot-device=hd:2,\yaboot' \
         -prom-env 'boot-args=conf=hd:2,\yaboot.conf'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    These variables are not used by Open Hack'Ware.</dd>
</dl>
<div class="Pp"></div>
The following options are specific to the Sparc32 emulation:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>
    <i>W</i><b>x</b><i>H</i><b>x[x</b><i>DEPTH</i><b>]</b></dt>
  <dd class="It-tag">Set the initial graphics mode. For TCX, the default is
      1024x768x8 with the option of 1024x768x24. For cgthree, the default is
      1024x768x8 with the option of 1152x900x8 for people who wish to use
    OBP.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-prom-env</b> <i>string</i></dt>
  <dd class="It-tag">Set OpenBIOS variables in NVRAM, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-sparc -prom-env 'auto-boot?=false' \
         -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M
    [SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic]
    [|SPARCbook]</b></dt>
  <dd class="It-tag">Set the emulated machine type. Default is SS-5.</dd>
</dl>
<div class="Pp"></div>
The following options are specific to the Sparc64 emulation:
<dl class="Bl-tag">
  <dt class="It-tag"><b>-prom-env</b> <i>string</i></dt>
  <dd class="It-tag">Set OpenBIOS variables in NVRAM, for example:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
        qemu-system-sparc64 -prom-env 'auto-boot?=false'
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-M [sun4u|sun4v|niagara]</b></dt>
  <dd class="It-tag">Set the emulated machine type. The default is sun4u.</dd>
</dl>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The HTML documentation of QEMU for more precise information and Linux user mode
  emulator invocation.
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Fabrice Bellard</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-08-16</td>
    <td class="foot-os"> </td>
  </tr>
</table>
</body>
</html>
