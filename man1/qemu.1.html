<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:34:34 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>QEMU.1(1) QEMU.1(1)</p>

<p style="margin-top: 1em">NAME <br>
qemu-doc - QEMU Emulator User Documentation</p>

<p style="margin-top: 1em">SYNOPSIS <br>
qemu-system-i386 [options] [disk_image]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The QEMU PC System emulator simulates the following
peripherals:</p>

<p style="margin-top: 1em">- i440FX host PCI bridge and
PIIX3 PCI to ISA bridge</p>

<p style="margin-top: 1em">- Cirrus CLGD 5446 PCI VGA card
or dummy VGA card with Bochs VESA extensions (hardware
level, including all non standard modes).</p>

<p style="margin-top: 1em">- PS/2 mouse and keyboard</p>

<p style="margin-top: 1em">- 2 PCI IDE interfaces with hard
disk and CD-ROM support</p>

<p style="margin-top: 1em">- Floppy disk</p>

<p style="margin-top: 1em">- PCI and ISA network
adapters</p>

<p style="margin-top: 1em">- Serial ports</p>

<p style="margin-top: 1em">- IPMI BMC, either and internal
or external one</p>

<p style="margin-top: 1em">- Creative SoundBlaster 16 sound
card</p>

<p style="margin-top: 1em">- ENSONIQ AudioPCI ES1370 sound
card</p>

<p style="margin-top: 1em">- Intel 82801AA AC97 Audio
compatible sound card</p>

<p style="margin-top: 1em">- Intel HD Audio Controller and
HDA codec</p>

<p style="margin-top: 1em">- Adlib (OPL2) - Yamaha YM3812
compatible chip</p>

<p style="margin-top: 1em">- Gravis Ultrasound GF1 sound
card</p>

<p style="margin-top: 1em">- CS4231A compatible sound
card</p>

<p style="margin-top: 1em">- PCI UHCI USB controller and a
virtual USB hub.</p>

<p style="margin-top: 1em">SMP is supported with up to 255
CPUs.</p>

<p style="margin-top: 1em">QEMU uses the PC BIOS from the
Seabios project and the Plex86/Bochs LGPL VGA BIOS.</p>

<p style="margin-top: 1em">QEMU uses YM3812 emulation by
Tatsuyuki Satoh.</p>

<p style="margin-top: 1em">QEMU uses GUS emulation
(GUSEMU32 &lt;http://www.deinmeister.de/gusemu/&gt;) by
Tibor &quot;TS&quot; Sch&Atilde;&frac14;tz.</p>

<p style="margin-top: 1em">Note that, by default, GUS
shares IRQ(7) with parallel ports and so QEMU must be told
to not have parallel ports to have working GUS.</p>

<p style="margin-top: 1em">qemu-system-i386 dos.img
-soundhw gus -parallel none</p>

<p style="margin-top: 1em">Alternatively:</p>

<p style="margin-top: 1em">qemu-system-i386 dos.img -device
gus,irq=5</p>

<p style="margin-top: 1em">Or some other unclaimed IRQ.</p>

<p style="margin-top: 1em">CS4231A is the chip used in
Windows Sound System and GUSMAX products</p>

<p style="margin-top: 1em">OPTIONS <br>
disk_image is a raw hard disk image for IDE hard disk 0.
Some targets do not need a disk image.</p>

<p style="margin-top: 1em">Standard options</p>

<p style="margin-top: 1em">-h Display help and exit</p>

<p style="margin-top: 1em">-version <br>
Display version information and exit</p>

<p style="margin-top: 1em">-machine
[type=]name[,prop=value[,...]] <br>
Select the emulated machine by name. Use &quot;-machine
help&quot; to list available machines. Supported machine
properties are:</p>

<p style="margin-top: 1em">accel=accels1[:accels2[:...]]
<br>
This is used to enable an accelerator. Depending on the
target architecture, kvm, xen, or tcg can be available. By
default, tcg is used. If there is more than one <br>
accelerator specified, the next one is used if the previous
one fails to initialize.</p>

<p style="margin-top: 1em">kernel_irqchip=on|off <br>
Controls in-kernel irqchip support for the chosen
accelerator when available.</p>

<p style="margin-top: 1em">gfx_passthru=on|off <br>
Enables IGD GFX passthrough support for the chosen machine
when available.</p>

<p style="margin-top: 1em">vmport=on|off|auto <br>
Enables emulation of VMWare IO port, for vmmouse etc. auto
says to select the value based on accel. For accel=xen the
default is off otherwise the default is on.</p>

<p style="margin-top: 1em">kvm_shadow_mem=size <br>
Defines the size of the KVM shadow MMU.</p>

<p style="margin-top: 1em">dump-guest-core=on|off <br>
Include guest memory in a core dump. The default is on.</p>

<p style="margin-top: 1em">mem-merge=on|off <br>
Enables or disables memory merge support. This feature, when
supported by the host, de-duplicates identical memory pages
among VMs instances (enabled by default).</p>

<p style="margin-top: 1em">aes-key-wrap=on|off <br>
Enables or disables AES key wrapping support on s390-ccw
hosts. This feature controls whether AES wrapping keys will
be created to allow execution of AES cryptographic <br>
functions. The default is on.</p>

<p style="margin-top: 1em">dea-key-wrap=on|off <br>
Enables or disables DEA key wrapping support on s390-ccw
hosts. This feature controls whether DEA wrapping keys will
be created to allow execution of DEA cryptographic <br>
functions. The default is on.</p>

<p style="margin-top: 1em">nvdimm=on|off <br>
Enables or disables NVDIMM support. The default is off.</p>

<p style="margin-top: 1em">-cpu model <br>
Select CPU model (&quot;-cpu help&quot; for list and
additional feature selection)</p>

<p style="margin-top: 1em">-accel name[,prop=value[,...]]
<br>
This is used to enable an accelerator. Depending on the
target architecture, kvm, xen, or tcg can be available. By
default, tcg is used. If there is more than one accelerator
<br>
specified, the next one is used if the previous one fails to
initialize.</p>

<p style="margin-top: 1em">thread=single|multi <br>
Controls number of TCG threads. When the TCG is
multi-threaded there will be one thread per vCPU therefor
taking advantage of additional host cores. The default is to
<br>
enable multi-threading where both the back-end and
front-ends support it and no incompatible TCG features have
been enabled (e.g. icount/replay).</p>

<p style="margin-top: 1em">-smp
[cpus=]n[,cores=cores][,threads=threads][,sockets=sockets][,maxcpus=maxcpus]
<br>
Simulate an SMP system with n CPUs. On the PC target, up to
255 CPUs are supported. On Sparc32 target, Linux limits the
number of usable CPUs to 4. For the PC target, the <br>
number of cores per socket, the number of threads per cores
and the total number of sockets can be specified. Missing
values will be computed. If any on the three values is <br>
given, the total number of CPUs n can be omitted. maxcpus
specifies the maximum number of hotpluggable CPUs.</p>

<p style="margin-top: 1em">-numa
node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node] <br>
-numa
node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node]
<br>
Define a NUMA node and assign RAM and VCPUs to it.</p>

<p style="margin-top: 1em">firstcpu and lastcpu are CPU
indexes. Each cpus option represent a contiguous range of
CPU indexes (or a single VCPU if lastcpu is omitted). A
non-contiguous set of VCPUs can <br>
be represented by providing multiple cpus options. If cpus
is omitted on all nodes, VCPUs are automatically split
between them.</p>

<p style="margin-top: 1em">For example, the following
option assigns VCPUs 0, 1, 2 and 5 to a NUMA node:</p>

<p style="margin-top: 1em">-numa node,cpus=0-2,cpus=5</p>

<p style="margin-top: 1em">mem assigns a given RAM amount
to a node. memdev assigns RAM from a given memory backend
device to a node. If mem and memdev are omitted in all
nodes, RAM is split equally <br>
between them.</p>

<p style="margin-top: 1em">mem and memdev are mutually
exclusive. Furthermore, if one node uses memdev, all of them
have to use it.</p>

<p style="margin-top: 1em">Note that the -numa option
doesn&rsquo;t allocate any of the specified resources, it
just assigns existing resources to NUMA nodes. This means
that one still has to use the -m, <br>
-smp options to allocate RAM and VCPUs respectively.</p>

<p style="margin-top: 1em">-add-fd
fd=fd,set=set[,opaque=opaque] <br>
Add a file descriptor to an fd set. Valid options are:</p>

<p style="margin-top: 1em">fd=fd <br>
This option defines the file descriptor of which a duplicate
is added to fd set. The file descriptor cannot be stdin,
stdout, or stderr.</p>

<p style="margin-top: 1em">set=set <br>
This option defines the ID of the fd set to add the file
descriptor to.</p>

<p style="margin-top: 1em">opaque=opaque <br>
This option defines a free-form string that can be used to
describe fd.</p>

<p style="margin-top: 1em">You can open an image using
pre-opened file descriptors from an fd set:</p>

<p style="margin-top: 1em">qemu-system-i386 <br>
-add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
<br>
-add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
<br>
-drive file=/dev/fdset/2,index=0,media=disk</p>

<p style="margin-top: 1em">-set group.id.arg=value <br>
Set parameter arg for item id of type group</p>

<p style="margin-top: 1em">-global driver.prop=value <br>
-global driver=driver,property=property,value=value <br>
Set default value of driver&rsquo;s property prop to value,
e.g.:</p>

<p style="margin-top: 1em">qemu-system-i386 -global
ide-drive.physical_block_size=4096 -drive
file=file,if=ide,index=0,media=disk</p>

<p style="margin-top: 1em">In particular, you can use this
to set driver properties for devices which are created
automatically by the machine model. To create a device which
is not created <br>
automatically and set properties on it, use -device.</p>

<p style="margin-top: 1em">-global driver.prop=value is
shorthand for -global
driver=driver,property=prop,value=value. The longhand syntax
works even when driver contains a dot.</p>

<p style="margin-top: 1em">-boot
[order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]
<br>
Specify boot order drives as a string of drive letters.
Valid drive letters depend on the target architecture. The
x86 PC uses: a, b (floppy 1 and 2), c (first hard disk), d
<br>
(first CD-ROM), n-p (Etherboot from network adapter 1-4),
hard disk boot is the default. To apply a particular boot
order only on the first startup, specify it via once. Note
<br>
that the order or once parameter should not be used together
with the bootindex property of devices, since the firmware
implementations normally do not support both at the <br>
same time.</p>

<p style="margin-top: 1em">Interactive boot menus/prompts
can be enabled via menu=on as far as firmware/BIOS supports
them. The default is non-interactive boot.</p>

<p style="margin-top: 1em">A splash picture could be passed
to bios, enabling user to show it as logo, when option
splash=sp_name is given and menu=on, If firmware/BIOS
supports them. Currently Seabios <br>
for X86 system support it. limitation: The splash file could
be a jpeg file or a BMP file in 24 BPP format(true color).
The resolution should be supported by the SVGA mode, <br>
so the recommended is 320x240, 640x480, 800x640.</p>

<p style="margin-top: 1em">A timeout could be passed to
bios, guest will pause for rb_timeout ms when boot failed,
then reboot. If rb_timeout is &rsquo;-1&rsquo;, guest will
not reboot, qemu passes &rsquo;-1&rsquo; to bios by <br>
default. Currently Seabios for X86 system support it.</p>

<p style="margin-top: 1em">Do strict boot via strict=on as
far as firmware/BIOS supports it. This only effects when
boot priority is changed by bootindex options. The default
is non-strict boot.</p>

<p style="margin-top: 1em"># try to boot from network
first, then from hard disk <br>
qemu-system-i386 -boot order=nc <br>
# boot from CD-ROM first, switch back to default order after
reboot <br>
qemu-system-i386 -boot once=d <br>
# boot with a splash picture for 5 seconds. <br>
qemu-system-i386 -boot
menu=on,splash=/root/boot.bmp,splash-time=5000</p>

<p style="margin-top: 1em">Note: The legacy format
&rsquo;-boot drives&rsquo; is still supported but its use is
discouraged as it may be removed from future versions.</p>

<p style="margin-top: 1em">-m
[size=]megs[,slots=n,maxmem=size] <br>
Sets guest startup RAM size to megs megabytes. Default is
128 MiB. Optionally, a suffix of &quot;M&quot; or
&quot;G&quot; can be used to signify a value in megabytes or
gigabytes respectively. <br>
Optional pair slots, maxmem could be used to set amount of
hotpluggable memory slots and maximum amount of memory. Note
that maxmem must be aligned to the page size.</p>

<p style="margin-top: 1em">For example, the following
command-line sets the guest startup RAM size to 1GB, creates
3 slots to hotplug additional memory and sets the maximum
memory the guest can reach <br>
to 4GB:</p>

<p style="margin-top: 1em">qemu-system-x86_64 -m
1G,slots=3,maxmem=4G</p>

<p style="margin-top: 1em">If slots and maxmem are not
specified, memory hotplug won&rsquo;t be enabled and the
guest startup RAM will never increase.</p>

<p style="margin-top: 1em">-mem-path path <br>
Allocate guest RAM from a temporarily created file in
path.</p>

<p style="margin-top: 1em">-mem-prealloc <br>
Preallocate memory when using -mem-path.</p>

<p style="margin-top: 1em">-k language <br>
Use keyboard layout language (for example &quot;fr&quot; for
French). This option is only needed where it is not easy to
get raw PC keycodes (e.g. on Macs, with some X11 servers or
<br>
with a VNC or curses display). You don&rsquo;t normally need
to use it on PC/Linux or PC/Windows hosts.</p>

<p style="margin-top: 1em">The available layouts are:</p>

<p style="margin-top: 1em">ar de-ch es fo fr-ca hu ja mk no
pt-br sv <br>
da en-gb et fr fr-ch is lt nl pl ru th <br>
de en-us fi fr-be hr it lv nl-be pt sl tr</p>

<p style="margin-top: 1em">The default is
&quot;en-us&quot;.</p>

<p style="margin-top: 1em">-audio-help <br>
Will show the audio subsystem help: list of drivers, tunable
parameters.</p>

<p style="margin-top: 1em">-soundhw card1[,card2,...] or
-soundhw all <br>
Enable audio and selected sound hardware. Use
&rsquo;help&rsquo; to print all available sound
hardware.</p>

<p style="margin-top: 1em">qemu-system-i386 -soundhw
sb16,adlib disk.img <br>
qemu-system-i386 -soundhw es1370 disk.img <br>
qemu-system-i386 -soundhw ac97 disk.img <br>
qemu-system-i386 -soundhw hda disk.img <br>
qemu-system-i386 -soundhw all disk.img <br>
qemu-system-i386 -soundhw help</p>

<p style="margin-top: 1em">Note that Linux&rsquo;s
i810_audio OSS kernel (for AC97) module might require
manually specifying clocking.</p>

<p style="margin-top: 1em">modprobe i810_audio
clocking=48000</p>

<p style="margin-top: 1em">-balloon none <br>
Disable balloon device.</p>

<p style="margin-top: 1em">-balloon virtio[,addr=addr] <br>
Enable virtio balloon device (default), optionally with PCI
address addr.</p>

<p style="margin-top: 1em">-device
driver[,prop[=value][,...]] <br>
Add device driver. prop=value sets driver properties. Valid
properties depend on the driver. To get help on possible
drivers and properties, use &quot;-device help&quot; and
<br>
&quot;-device driver,help&quot;.</p>

<p style="margin-top: 1em">Some drivers are:</p>

<p style="margin-top: 1em">-device
ipmi-bmc-sim,id=id[,slave_addr=val] <br>
Add an IPMI BMC. This is a simulation of a hardware
management interface processor that normally sits on a
system. It provides a watchdog and the ability to reset and
power <br>
control the system. You need to connect this to an IPMI
interface to make it useful</p>

<p style="margin-top: 1em">The IPMI slave address to use
for the BMC. The default is 0x20. This address is the
BMC&rsquo;s address on the I2C network of management
controllers. If you don&rsquo;t know what this <br>
means, it is safe to ignore it.</p>

<p style="margin-top: 1em">-device
ipmi-bmc-extern,id=id,chardev=id[,slave_addr=val] <br>
Add a connection to an external IPMI BMC simulator. Instead
of locally emulating the BMC like the above item, instead
connect to an external entity that provides the IPMI <br>
services.</p>

<p style="margin-top: 1em">A connection is made to an
external BMC simulator. If you do this, it is strongly
recommended that you use the &quot;reconnect=&quot; chardev
option to reconnect to the simulator if <br>
the connection is lost. Note that if this is not used
carefully, it can be a security issue, as the interface has
the ability to send resets, NMIs, and power off the VM. <br>
It&rsquo;s best if QEMU makes a connection to an external
simulator running on a secure port on localhost, so neither
the simulator nor QEMU is exposed to any outside
network.</p>

<p style="margin-top: 1em">See the
&quot;lanserv/README.vm&quot; file in the OpenIPMI library
for more details on the external interface.</p>

<p style="margin-top: 1em">-device
isa-ipmi-kcs,bmc=id[,ioport=val][,irq=val] <br>
Add a KCS IPMI interafce on the ISA bus. This also adds a
corresponding ACPI and SMBIOS entries, if appropriate.</p>

<p style="margin-top: 1em">bmc=id <br>
The BMC to connect to, one of ipmi-bmc-sim or
ipmi-bmc-extern above.</p>

<p style="margin-top: 1em">ioport=val <br>
Define the I/O address of the interface. The default is
0xca0 for KCS.</p>

<p style="margin-top: 1em">irq=val <br>
Define the interrupt to use. The default is 5. To disable
interrupts, set this to 0.</p>

<p style="margin-top: 1em">-device
isa-ipmi-bt,bmc=id[,ioport=val][,irq=val] <br>
Like the KCS interface, but defines a BT interface. The
default port is 0xe4 and the default interrupt is 5.</p>

<p style="margin-top: 1em">-name name <br>
Sets the name of the guest. This name will be displayed in
the SDL window caption. The name will also be used for the
VNC server. Also optionally set the top visible <br>
process name in Linux. Naming of individual threads can also
be enabled on Linux to aid debugging.</p>

<p style="margin-top: 1em">-uuid uuid <br>
Set system UUID.</p>

<p style="margin-top: 1em">Block device options</p>

<p style="margin-top: 1em">-fda file <br>
-fdb file <br>
Use file as floppy disk 0/1 image.</p>

<p style="margin-top: 1em">-hda file <br>
-hdb file <br>
-hdc file <br>
-hdd file <br>
Use file as hard disk 0, 1, 2 or 3 image.</p>

<p style="margin-top: 1em">-cdrom file <br>
Use file as CD-ROM image (you cannot use -hdc and -cdrom at
the same time). You can use the host CD-ROM by using
/dev/cdrom as filename.</p>

<p style="margin-top: 1em">-drive
option[,option[,option[,...]]] <br>
Define a new drive. Valid options are:</p>

<p style="margin-top: 1em">file=file <br>
This option defines which disk image to use with this drive.
If the filename contains comma, you must double it (for
instance, &quot;file=my,,file&quot; to use file
&quot;my,file&quot;).</p>

<p style="margin-top: 1em">Special files such as iSCSI
devices can be specified using protocol specific URLs. See
the section for &quot;Device URL Syntax&quot; for more
information.</p>

<p style="margin-top: 1em">if=interface <br>
This option defines on which type on interface the drive is
connected. Available types are: ide, scsi, sd, mtd, floppy,
pflash, virtio.</p>

<p style="margin-top: 1em">bus=bus,unit=unit <br>
These options define where is connected the drive by
defining the bus number and the unit id.</p>

<p style="margin-top: 1em">index=index <br>
This option defines where is connected the drive by using an
index in the list of available connectors of a given
interface type.</p>

<p style="margin-top: 1em">media=media <br>
This option defines the type of the media: disk or
cdrom.</p>

<p style="margin-top: 1em">cyls=c,heads=h,secs=s[,trans=t]
<br>
These options have the same definition as they have in
-hdachs.</p>

<p style="margin-top: 1em">snapshot=snapshot <br>
snapshot is &quot;on&quot; or &quot;off&quot; and controls
snapshot mode for the given drive (see -snapshot).</p>

<p style="margin-top: 1em">cache=cache <br>
cache is &quot;none&quot;, &quot;writeback&quot;,
&quot;unsafe&quot;, &quot;directsync&quot; or
&quot;writethrough&quot; and controls how the host cache is
used to access block data.</p>

<p style="margin-top: 1em">aio=aio <br>
aio is &quot;threads&quot;, or &quot;native&quot; and
selects between pthread based disk I/O and native Linux
AIO.</p>

<p style="margin-top: 1em">discard=discard <br>
discard is one of &quot;ignore&quot; (or &quot;off&quot;) or
&quot;unmap&quot; (or &quot;on&quot;) and controls whether
discard (also known as trim or unmap) requests are ignored
or passed to the filesystem. <br>
Some machine types may not support discard requests.</p>

<p style="margin-top: 1em">format=format <br>
Specify which disk format will be used rather than detecting
the format. Can be used to specify format=raw to avoid
interpreting an untrusted format header.</p>

<p style="margin-top: 1em">serial=serial <br>
This option specifies the serial number to assign to the
device.</p>

<p style="margin-top: 1em">addr=addr <br>
Specify the controller&rsquo;s PCI address (if=virtio
only).</p>

<p style="margin-top: 1em">werror=action,rerror=action <br>
Specify which action to take on write and read errors. Valid
actions are: &quot;ignore&quot; (ignore the error and try to
continue), &quot;stop&quot; (pause QEMU), &quot;report&quot;
(report the error <br>
to the guest), &quot;enospc&quot; (pause QEMU only if the
host disk is full; report the error to the guest otherwise).
The default setting is werror=enospc and rerror=report.</p>

<p style="margin-top: 1em">readonly <br>
Open drive file as read-only. Guest write attempts will
fail.</p>

<p style="margin-top: 1em">copy-on-read=copy-on-read <br>
copy-on-read is &quot;on&quot; or &quot;off&quot; and
enables whether to copy read backing file sectors into the
image file.</p>

<p style="margin-top: 1em">detect-zeroes=detect-zeroes <br>
detect-zeroes is &quot;off&quot;, &quot;on&quot; or
&quot;unmap&quot; and enables the automatic conversion of
plain zero writes by the OS to driver specific optimized
zero write commands. You may even <br>
choose &quot;unmap&quot; if discard is set to
&quot;unmap&quot; to allow a zero write to be converted to
an UNMAP operation.</p>

<p style="margin-top: 1em">By default, the cache=writeback
mode is used. It will report data writes as completed as
soon as the data is present in the host page cache. This is
safe as long as your <br>
guest OS makes sure to correctly flush disk caches where
needed. If your guest OS does not handle volatile disk write
caches correctly and your host crashes or loses power, <br>
then the guest may experience data corruption.</p>

<p style="margin-top: 1em">For such guests, you should
consider using cache=writethrough. This means that the host
page cache will be used to read and write data, but write
notification will be sent to <br>
the guest only after QEMU has made sure to flush each write
to the disk. Be aware that this has a major impact on
performance.</p>

<p style="margin-top: 1em">The host page cache can be
avoided entirely with cache=none. This will attempt to do
disk IO directly to the guest&rsquo;s memory. QEMU may still
perform an internal copy of the <br>
data. Note that this is considered a writeback mode and the
guest OS must handle the disk write cache correctly in order
to avoid data corruption on host crashes.</p>

<p style="margin-top: 1em">The host page cache can be
avoided while only sending write notifications to the guest
when the data has been flushed to the disk using
cache=directsync.</p>

<p style="margin-top: 1em">In case you don&rsquo;t care
about data integrity over host failures, use cache=unsafe.
This option tells QEMU that it never needs to write any data
to the disk but can instead <br>
keep things in cache. If anything goes wrong, like your host
losing power, the disk storage getting disconnected
accidentally, etc. your image will most probably be rendered
<br>
unusable. When using the -snapshot option, unsafe caching is
always used.</p>

<p style="margin-top: 1em">Copy-on-read avoids accessing
the same backing file sectors repeatedly and is useful when
the backing file is over a slow network. By default
copy-on-read is off.</p>

<p style="margin-top: 1em">Instead of -cdrom you can
use:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
file=file,index=2,media=cdrom</p>

<p style="margin-top: 1em">Instead of -hda, -hdb, -hdc,
-hdd, you can use:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
file=file,index=0,media=disk <br>
qemu-system-i386 -drive file=file,index=1,media=disk <br>
qemu-system-i386 -drive file=file,index=2,media=disk <br>
qemu-system-i386 -drive file=file,index=3,media=disk</p>

<p style="margin-top: 1em">You can open an image using
pre-opened file descriptors from an fd set:</p>

<p style="margin-top: 1em">qemu-system-i386 <br>
-add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot;
<br>
-add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot;
<br>
-drive file=/dev/fdset/2,index=0,media=disk</p>

<p style="margin-top: 1em">You can connect a CDROM to the
slave of ide0:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
file=file,if=ide,index=1,media=cdrom</p>

<p style="margin-top: 1em">If you don&rsquo;t specify the
&quot;file=&quot; argument, you define an empty drive:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
if=ide,index=1,media=cdrom</p>

<p style="margin-top: 1em">Instead of -fda, -fdb, you can
use:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
file=file,index=0,if=floppy <br>
qemu-system-i386 -drive file=file,index=1,if=floppy</p>

<p style="margin-top: 1em">By default, interface is
&quot;ide&quot; and index is automatically incremented:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive file=a
-drive file=b&quot;</p>

<p style="margin-top: 1em">is interpreted like:</p>

<p style="margin-top: 1em">qemu-system-i386 -hda a -hdb
b</p>

<p style="margin-top: 1em">-mtdblock file <br>
Use file as on-board Flash memory image.</p>

<p style="margin-top: 1em">-sd file <br>
Use file as SecureDigital card image.</p>

<p style="margin-top: 1em">-pflash file <br>
Use file as a parallel flash image.</p>

<p style="margin-top: 1em">-snapshot <br>
Write to temporary files instead of disk image files. In
this case, the raw disk image you use is not written back.
You can however force the write back by pressing C-a s.</p>

<p style="margin-top: 1em">-hdachs c,h,s,[,t] <br>
Force hard disk 0 physical geometry (1 &lt;= c &lt;= 16383,
1 &lt;= h &lt;= 16, 1 &lt;= s &lt;= 63) and optionally force
the BIOS translation mode (t=none, lba or auto). Usually
QEMU can guess <br>
all those parameters. This option is useful for old MS-DOS
disk images.</p>

<p style="margin-top: 1em">-fsdev
fsdriver,id=id,path=path,[security_model=security_model][,writeout=writeout][,readonly][,socket=socket|sock_fd=sock_fd]
<br>
Define a new file system device. Valid options are:</p>

<p style="margin-top: 1em">fsdriver <br>
This option specifies the fs driver backend to use.
Currently &quot;local&quot;, &quot;handle&quot; and
&quot;proxy&quot; file system drivers are supported.</p>

<p style="margin-top: 1em">id=id <br>
Specifies identifier for this device</p>

<p style="margin-top: 1em">path=path <br>
Specifies the export path for the file system device. Files
under this path will be available to the 9p client on the
guest.</p>

<p style="margin-top: 1em">security_model=security_model
<br>
Specifies the security model to be used for this export
path. Supported security models are &quot;passthrough&quot;,
&quot;mapped-xattr&quot;, &quot;mapped-file&quot; and
&quot;none&quot;. In &quot;passthrough&quot; <br>
security model, files are stored using the same credentials
as they are created on the guest. This requires QEMU to run
as root. In &quot;mapped-xattr&quot; security model, some of
<br>
the file attributes like uid, gid, mode bits and link target
are stored as file attributes. For &quot;mapped-file&quot;
these attributes are stored in the hidden .virtfs_metadata
<br>
directory. Directories exported by this security model
cannot interact with other unix tools. &quot;none&quot;
security model is same as passthrough except the sever
won&rsquo;t report <br>
failures if it fails to set file attributes like ownership.
Security model is mandatory only for local fsdriver. Other
fsdrivers (like handle, proxy) don&rsquo;t take security
<br>
model as a parameter.</p>

<p style="margin-top: 1em">writeout=writeout <br>
This is an optional argument. The only supported value is
&quot;immediate&quot;. This means that host page cache will
be used to read and write data but write notification will
be <br>
sent to the guest only when the data has been reported as
written by the storage subsystem.</p>

<p style="margin-top: 1em">readonly <br>
Enables exporting 9p share as a readonly mount for guests.
By default read-write access is given.</p>

<p style="margin-top: 1em">socket=socket <br>
Enables proxy filesystem driver to use passed socket file
for communicating with virtfs-proxy-helper</p>

<p style="margin-top: 1em">sock_fd=sock_fd <br>
Enables proxy filesystem driver to use passed socket
descriptor for communicating with virtfs-proxy-helper.
Usually a helper like libvirt will create socketpair and
pass <br>
one of the fds as sock_fd</p>

<p style="margin-top: 1em">-fsdev option is used along with
-device driver &quot;virtio-9p-pci&quot;.</p>

<p style="margin-top: 1em">-device
virtio-9p-pci,fsdev=id,mount_tag=mount_tag <br>
Options for virtio-9p-pci driver are:</p>

<p style="margin-top: 1em">fsdev=id <br>
Specifies the id value specified along with -fsdev
option</p>

<p style="margin-top: 1em">mount_tag=mount_tag <br>
Specifies the tag name to be used by the guest to mount this
export point</p>

<p style="margin-top: 1em">-virtfs
fsdriver[,path=path],mount_tag=mount_tag[,security_model=security_model][,writeout=writeout][,readonly][,socket=socket|sock_fd=sock_fd]
<br>
The general form of a Virtual File system pass-through
options are:</p>

<p style="margin-top: 1em">fsdriver <br>
This option specifies the fs driver backend to use.
Currently &quot;local&quot;, &quot;handle&quot; and
&quot;proxy&quot; file system drivers are supported.</p>

<p style="margin-top: 1em">id=id <br>
Specifies identifier for this device</p>

<p style="margin-top: 1em">path=path <br>
Specifies the export path for the file system device. Files
under this path will be available to the 9p client on the
guest.</p>

<p style="margin-top: 1em">security_model=security_model
<br>
Specifies the security model to be used for this export
path. Supported security models are &quot;passthrough&quot;,
&quot;mapped-xattr&quot;, &quot;mapped-file&quot; and
&quot;none&quot;. In &quot;passthrough&quot; <br>
security model, files are stored using the same credentials
as they are created on the guest. This requires QEMU to run
as root. In &quot;mapped-xattr&quot; security model, some of
<br>
the file attributes like uid, gid, mode bits and link target
are stored as file attributes. For &quot;mapped-file&quot;
these attributes are stored in the hidden .virtfs_metadata
<br>
directory. Directories exported by this security model
cannot interact with other unix tools. &quot;none&quot;
security model is same as passthrough except the sever
won&rsquo;t report <br>
failures if it fails to set file attributes like ownership.
Security model is mandatory only for local fsdriver. Other
fsdrivers (like handle, proxy) don&rsquo;t take security
<br>
model as a parameter.</p>

<p style="margin-top: 1em">writeout=writeout <br>
This is an optional argument. The only supported value is
&quot;immediate&quot;. This means that host page cache will
be used to read and write data but write notification will
be <br>
sent to the guest only when the data has been reported as
written by the storage subsystem.</p>

<p style="margin-top: 1em">readonly <br>
Enables exporting 9p share as a readonly mount for guests.
By default read-write access is given.</p>

<p style="margin-top: 1em">socket=socket <br>
Enables proxy filesystem driver to use passed socket file
for communicating with virtfs-proxy-helper. Usually a helper
like libvirt will create socketpair and pass one of <br>
the fds as sock_fd</p>

<p style="margin-top: 1em">sock_fd <br>
Enables proxy filesystem driver to use passed
&rsquo;sock_fd&rsquo; as the socket descriptor for
interfacing with virtfs-proxy-helper</p>

<p style="margin-top: 1em">-virtfs_synth <br>
Create synthetic file system image</p>

<p style="margin-top: 1em">USB options</p>

<p style="margin-top: 1em">-usb <br>
Enable the USB driver (will be the default soon)</p>

<p style="margin-top: 1em">-usbdevice devname <br>
Add the USB device devname.</p>

<p style="margin-top: 1em">mouse <br>
Virtual Mouse. This will override the PS/2 mouse emulation
when activated.</p>

<p style="margin-top: 1em">tablet <br>
Pointer device that uses absolute coordinates (like a
touchscreen). This means QEMU is able to report the mouse
position without having to grab the mouse. Also overrides
<br>
the PS/2 mouse emulation when activated.</p>

<p style="margin-top: 1em">disk:[format=format]:file <br>
Mass storage device based on file. The optional format
argument will be used rather than detecting the format. Can
be used to specify &quot;format=raw&quot; to avoid
interpreting <br>
an untrusted format header.</p>

<p style="margin-top: 1em">host:bus.addr <br>
Pass through the host device identified by bus.addr (Linux
only).</p>

<p style="margin-top: 1em">host:vendor_id:product_id <br>
Pass through the host device identified by
vendor_id:product_id (Linux only).</p>


<p style="margin-top: 1em">serial:[vendorid=vendor_id][,productid=product_id]:dev
<br>
Serial converter to host character device dev, see
&quot;-serial&quot; for the available devices.</p>

<p style="margin-top: 1em">braille <br>
Braille device. This will use BrlAPI to display the braille
output on a real or fake device.</p>

<p style="margin-top: 1em">net:options <br>
Network adapter that supports CDC ethernet and RNDIS
protocols.</p>

<p style="margin-top: 1em">Display options</p>

<p style="margin-top: 1em">-display type <br>
Select type of display to use. This option is a replacement
for the old style -sdl/-curses/... options. Valid values for
type are</p>

<p style="margin-top: 1em">sdl Display video output via SDL
(usually in a separate graphics window; see the SDL
documentation for other possibilities).</p>

<p style="margin-top: 1em">curses <br>
Display video output via curses. For graphics device models
which support a text mode, QEMU can display this output
using a curses/ncurses interface. Nothing is displayed <br>
when the graphics device is in graphical mode or if the
graphics device does not support a text mode. Generally only
the VGA device models support text mode.</p>

<p style="margin-top: 1em">none <br>
Do not display video output. The guest will still see an
emulated graphics card, but its output will not be displayed
to the QEMU user. This option differs from the <br>
-nographic option in that it only affects what is done with
video output; -nographic also changes the destination of the
serial and parallel port data.</p>

<p style="margin-top: 1em">gtk Display video output in a
GTK window. This interface provides drop-down menus and
other UI elements to configure and control the VM during
runtime.</p>

<p style="margin-top: 1em">vnc Start a VNC server on
display &lt;arg&gt;</p>

<p style="margin-top: 1em">-nographic <br>
Normally, if QEMU is compiled with graphical window support,
it displays output such as guest graphics, guest console,
and the QEMU monitor in a window. With this option, you <br>
can totally disable graphical output so that QEMU is a
simple command line application. The emulated serial port is
redirected on the console and muxed with the monitor <br>
(unless redirected elsewhere explicitly). Therefore, you can
still use QEMU to debug a Linux kernel with a serial
console. Use C-a h for help on switching between the console
<br>
and monitor.</p>

<p style="margin-top: 1em">-curses <br>
Normally, if QEMU is compiled with graphical window support,
it displays output such as guest graphics, guest console,
and the QEMU monitor in a window. With this option, <br>
QEMU can display the VGA output when in text mode using a
curses/ncurses interface. Nothing is displayed in graphical
mode.</p>

<p style="margin-top: 1em">-no-frame <br>
Do not use decorations for SDL windows and start them using
the whole available screen space. This makes the using QEMU
in a dedicated desktop workspace more convenient.</p>

<p style="margin-top: 1em">-alt-grab <br>
Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note
that this also affects the special keys (for fullscreen,
monitor-mode switching, etc).</p>

<p style="margin-top: 1em">-ctrl-grab <br>
Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note
that this also affects the special keys (for fullscreen,
monitor-mode switching, etc).</p>

<p style="margin-top: 1em">-no-quit <br>
Disable SDL window close capability.</p>

<p style="margin-top: 1em">-sdl <br>
Enable SDL.</p>

<p style="margin-top: 1em">-spice option[,option[,...]]
<br>
Enable the spice remote desktop protocol. Valid options
are</p>

<p style="margin-top: 1em">port=&lt;nr&gt; <br>
Set the TCP port spice is listening on for plaintext
channels.</p>

<p style="margin-top: 1em">addr=&lt;addr&gt; <br>
Set the IP address spice is listening on. Default is any
address.</p>

<p style="margin-top: 1em">ipv4 <br>
ipv6 <br>
unix <br>
Force using the specified IP version.</p>

<p style="margin-top: 1em">password=&lt;secret&gt; <br>
Set the password you need to authenticate.</p>

<p style="margin-top: 1em">sasl <br>
Require that the client use SASL to authenticate with the
spice. The exact choice of authentication method used is
controlled from the system / user&rsquo;s SASL configuration
<br>
file for the &rsquo;qemu&rsquo; service. This is typically
found in /etc/sasl2/qemu.conf. If running QEMU as an
unprivileged user, an environment variable SASL_CONF_PATH
can be used <br>
to make it search alternate locations for the service
config. While some SASL auth methods can also provide data
encryption (eg GSSAPI), it is recommended that SASL <br>
always be combined with the &rsquo;tls&rsquo; and
&rsquo;x509&rsquo; settings to enable use of SSL and server
certificates. This ensures a data encryption preventing
compromise of authentication <br>
credentials.</p>

<p style="margin-top: 1em">disable-ticketing <br>
Allow client connects without authentication.</p>

<p style="margin-top: 1em">disable-copy-paste <br>
Disable copy paste between the client and the guest.</p>

<p style="margin-top: 1em">disable-agent-file-xfer <br>
Disable spice-vdagent based file-xfer between the client and
the guest.</p>

<p style="margin-top: 1em">tls-port=&lt;nr&gt; <br>
Set the TCP port spice is listening on for encrypted
channels.</p>

<p style="margin-top: 1em">x509-dir=&lt;dir&gt; <br>
Set the x509 file directory. Expects same filenames as -vnc
$display,x509=$dir</p>

<p style="margin-top: 1em">x509-key-file=&lt;file&gt; <br>
x509-key-password=&lt;file&gt; <br>
x509-cert-file=&lt;file&gt; <br>
x509-cacert-file=&lt;file&gt; <br>
x509-dh-key-file=&lt;file&gt; <br>
The x509 file names can also be configured individually.</p>

<p style="margin-top: 1em">tls-ciphers=&lt;list&gt; <br>
Specify which ciphers to use.</p>


<p style="margin-top: 1em">tls-channel=[main|display|cursor|inputs|record|playback]
<br>

plaintext-channel=[main|display|cursor|inputs|record|playback]
<br>
Force specific channel to be used with or without TLS
encryption. The options can be specified multiple times to
configure multiple channels. The special name
&quot;default&quot; <br>
can be used to set the default mode. For channels which are
not explicitly forced into one mode the spice client is
allowed to pick tls/plaintext as he pleases.</p>


<p style="margin-top: 1em">image-compression=[auto_glz|auto_lz|quic|glz|lz|off]
<br>
Configure image compression (lossless). Default is
auto_glz.</p>


<p style="margin-top: 1em">jpeg-wan-compression=[auto|never|always]
<br>
zlib-glz-wan-compression=[auto|never|always] <br>
Configure wan image compression (lossy for slow links).
Default is auto.</p>


<p style="margin-top: 1em">streaming-video=[off|all|filter]
<br>
Configure video stream detection. Default is off.</p>

<p style="margin-top: 1em">agent-mouse=[on|off] <br>
Enable/disable passing mouse events via vdagent. Default is
on.</p>

<p style="margin-top: 1em">playback-compression=[on|off]
<br>
Enable/disable audio stream compression (using celt 0.5.1).
Default is on.</p>

<p style="margin-top: 1em">seamless-migration=[on|off] <br>
Enable/disable spice seamless migration. Default is off.</p>

<p style="margin-top: 1em">gl=[on|off] <br>
Enable/disable OpenGL context. Default is off.</p>

<p style="margin-top: 1em">rendernode=&lt;file&gt; <br>
DRM render node for OpenGL rendering. If not specified, it
will pick the first available. (Since 2.9)</p>

<p style="margin-top: 1em">-portrait <br>
Rotate graphical output 90 deg left (only PXA LCD).</p>

<p style="margin-top: 1em">-rotate deg <br>
Rotate graphical output some deg left (only PXA LCD).</p>

<p style="margin-top: 1em">-vga type <br>
Select type of VGA card to emulate. Valid values for type
are</p>

<p style="margin-top: 1em">cirrus <br>
Cirrus Logic GD5446 Video card. All Windows versions
starting from Windows 95 should recognize and use this
graphic card. For optimal performances, use 16 bit color
depth <br>
in the guest and the host OS. (This card was the default
before QEMU 2.2)</p>

<p style="margin-top: 1em">std Standard VGA card with Bochs
VBE extensions. If your guest OS supports the VESA 2.0 VBE
extensions (e.g. Windows XP) and if you want to use high
resolution modes (&gt;= <br>
1280x1024x16) then you should use this option. (This card is
the default since QEMU 2.2)</p>

<p style="margin-top: 1em">vmware <br>
VMWare SVGA-II compatible adapter. Use it if you have
sufficiently recent XFree86/XOrg server or Windows guest
with a driver for this card.</p>

<p style="margin-top: 1em">qxl QXL paravirtual graphic
card. It is VGA compatible (including VESA 2.0 VBE support).
Works best with qxl guest drivers installed though.
Recommended choice when using <br>
the spice protocol.</p>

<p style="margin-top: 1em">tcx (sun4m only) Sun TCX
framebuffer. This is the default framebuffer for sun4m
machines and offers both 8-bit and 24-bit colour depths at a
fixed resolution of 1024x768.</p>

<p style="margin-top: 1em">cg3 (sun4m only) Sun cgthree
framebuffer. This is a simple 8-bit framebuffer for sun4m
machines available in both 1024x768 (OpenBIOS) and 1152x900
(OBP) resolutions aimed at <br>
people wishing to run older Solaris versions.</p>

<p style="margin-top: 1em">virtio <br>
Virtio VGA card.</p>

<p style="margin-top: 1em">none <br>
Disable VGA card.</p>

<p style="margin-top: 1em">-full-screen <br>
Start in full screen.</p>

<p style="margin-top: 1em">-g widthxheight[xdepth] <br>
Set the initial graphical resolution and depth (PPC, SPARC
only).</p>

<p style="margin-top: 1em">-vnc
display[,option[,option[,...]]] <br>
Normally, if QEMU is compiled with graphical window support,
it displays output such as guest graphics, guest console,
and the QEMU monitor in a window. With this option, you <br>
can have QEMU listen on VNC display display and redirect the
VGA display over the VNC session. It is very useful to
enable the usb tablet device when using this option <br>
(option -usbdevice tablet). When using the VNC display, you
must use the -k parameter to set the keyboard layout if you
are not using en-us. Valid syntax for the display is</p>

<p style="margin-top: 1em">to=L <br>
With this option, QEMU will try next available VNC displays,
until the number L, if the origianlly defined &quot;-vnc
display&quot; is not available, e.g. port 5900+display is
<br>
already used by another application. By default, to=0.</p>

<p style="margin-top: 1em">host:d <br>
TCP connections will only be allowed from host on display d.
By convention the TCP port is 5900+d. Optionally, host can
be omitted in which case the server will accept <br>
connections from any host.</p>

<p style="margin-top: 1em">unix:path <br>
Connections will be allowed over UNIX domain sockets where
path is the location of a unix socket to listen for
connections on.</p>

<p style="margin-top: 1em">none <br>
VNC is initialized but not started. The monitor
&quot;change&quot; command can be used to later start the
VNC server.</p>

<p style="margin-top: 1em">Following the display value
there may be one or more option flags separated by commas.
Valid options are</p>

<p style="margin-top: 1em">reverse <br>
Connect to a listening VNC client via a &quot;reverse&quot;
connection. The client is specified by the display. For
reverse network connections (host:d,&quot;reverse&quot;),
the d argument <br>
is a TCP port number, not a display number.</p>

<p style="margin-top: 1em">websocket <br>
Opens an additional TCP listening port dedicated to VNC
Websocket connections. If a bare websocket option is given,
the Websocket port is 5700+display. An alternative <br>
port can be specified with the syntax
&quot;websocket&quot;=port.</p>

<p style="margin-top: 1em">If host is specified connections
will only be allowed from this host. It is possible to
control the websocket listen address independently, using
the syntax <br>
&quot;websocket&quot;=host:port.</p>

<p style="margin-top: 1em">If no TLS credentials are
provided, the websocket connection runs in unencrypted mode.
If TLS credentials are provided, the websocket connection
requires encrypted client <br>
connections.</p>

<p style="margin-top: 1em">password <br>
Require that password based authentication is used for
client connections.</p>

<p style="margin-top: 1em">The password must be set
separately using the &quot;set_password&quot; command in the
pcsys_monitor. The syntax to change your password is:
&quot;set_password &lt;protocol&gt; &lt;password&gt;&quot;
<br>
where &lt;protocol&gt; could be either &quot;vnc&quot; or
&quot;spice&quot;.</p>

<p style="margin-top: 1em">If you would like to change
&lt;protocol&gt; password expiration, you should use
&quot;expire_password &lt;protocol&gt;
&lt;expiration-time&gt;&quot; where expiration time could be
one of the <br>
following options: now, never, +seconds or UNIX time of
expiration, e.g. +60 to make password expire in 60 seconds,
or 1335196800 to make password expire on &quot;Mon Apr 23
<br>
12:00:00 EDT 2012&quot; (UNIX time for this date and
time).</p>

<p style="margin-top: 1em">You can also use keywords
&quot;now&quot; or &quot;never&quot; for the expiration time
to allow &lt;protocol&gt; password to expire immediately or
never expire.</p>

<p style="margin-top: 1em">tls-creds=ID <br>
Provides the ID of a set of TLS credentials to use to secure
the VNC server. They will apply to both the normal VNC
server socket and the websocket socket (if enabled). <br>
Setting TLS credentials will cause the VNC server socket to
enable the VeNCrypt auth mechanism. The credentials should
have been previously created using the -object <br>
tls-creds argument.</p>

<p style="margin-top: 1em">The tls-creds parameter
obsoletes the tls, x509, and x509verify options, and as such
it is not permitted to set both new and old type options at
the same time.</p>

<p style="margin-top: 1em">tls Require that client use TLS
when communicating with the VNC server. This uses anonymous
TLS credentials so is susceptible to a man-in-the-middle
attack. It is recommended <br>
that this option be combined with either the x509 or
x509verify options.</p>

<p style="margin-top: 1em">This option is now deprecated in
favor of using the tls-creds argument.</p>

<p style="margin-top: 1em">x509=/path/to/certificate/dir
<br>
Valid if tls is specified. Require that x509 credentials are
used for negotiating the TLS session. The server will send
its x509 certificate to the client. It is <br>
recommended that a password be set on the VNC server to
provide authentication of the client when this is used. The
path following this option specifies where the x509 <br>
certificates are to be loaded from. See the vnc_security
section for details on generating certificates.</p>

<p style="margin-top: 1em">This option is now deprecated in
favour of using the tls-creds argument.</p>


<p style="margin-top: 1em">x509verify=/path/to/certificate/dir
<br>
Valid if tls is specified. Require that x509 credentials are
used for negotiating the TLS session. The server will send
its x509 certificate to the client, and request <br>
that the client send its own x509 certificate. The server
will validate the client&rsquo;s certificate against the CA
certificate, and reject clients when validation fails. If
<br>
the certificate authority is trusted, this is a sufficient
authentication mechanism. You may still wish to set a
password on the VNC server as a second authentication <br>
layer. The path following this option specifies where the
x509 certificates are to be loaded from. See the
vnc_security section for details on generating
certificates.</p>

<p style="margin-top: 1em">This option is now deprecated in
favour of using the tls-creds argument.</p>

<p style="margin-top: 1em">sasl <br>
Require that the client use SASL to authenticate with the
VNC server. The exact choice of authentication method used
is controlled from the system / user&rsquo;s SASL <br>
configuration file for the &rsquo;qemu&rsquo; service. This
is typically found in /etc/sasl2/qemu.conf. If running QEMU
as an unprivileged user, an environment variable <br>
SASL_CONF_PATH can be used to make it search alternate
locations for the service config. While some SASL auth
methods can also provide data encryption (eg GSSAPI), it is
<br>
recommended that SASL always be combined with the
&rsquo;tls&rsquo; and &rsquo;x509&rsquo; settings to enable
use of SSL and server certificates. This ensures a data
encryption preventing <br>
compromise of authentication credentials. See the
vnc_security section for details on using SASL
authentication.</p>

<p style="margin-top: 1em">acl Turn on access control lists
for checking of the x509 client certificate and SASL party.
For x509 certs, the ACL check is made against the
certificate&rsquo;s distinguished <br>
name. This is something that looks like
&quot;C=GB,O=ACME,L=Boston,CN=bob&quot;. For SASL party, the
ACL check is made against the username, which depending on
the SASL plugin, may <br>
include a realm component, eg &quot;bob&quot; or
&quot;bob@EXAMPLE.COM&quot;. When the acl flag is set, the
initial access list will be empty, with a &quot;deny&quot;
policy. Thus no one will be <br>
allowed to use the VNC server until the ACLs have been
loaded. This can be achieved using the &quot;acl&quot;
monitor command.</p>

<p style="margin-top: 1em">lossy <br>
Enable lossy compression methods (gradient, JPEG, ...). If
this option is set, VNC client may receive lossy framebuffer
updates depending on its encoding settings. <br>
Enabling this option can save a lot of bandwidth at the
expense of quality.</p>

<p style="margin-top: 1em">non-adaptive <br>
Disable adaptive encodings. Adaptive encodings are enabled
by default. An adaptive encoding will try to detect
frequently updated screen regions, and send updates in <br>
these regions using a lossy encoding (like JPEG). This can
be really helpful to save bandwidth when playing videos.
Disabling adaptive encodings restores the original <br>
static behavior of encodings like Tight.</p>


<p style="margin-top: 1em">share=[allow-exclusive|force-shared|ignore]
<br>
Set display sharing policy. &rsquo;allow-exclusive&rsquo;
allows clients to ask for exclusive access. As suggested by
the rfb spec this is implemented by dropping other <br>
connections. Connecting multiple clients in parallel
requires all clients asking for a shared session (vncviewer:
-shared switch). This is the default.
&rsquo;force-shared&rsquo; <br>
disables exclusive client access. Useful for shared desktop
sessions, where you don&rsquo;t want someone forgetting
specify -shared disconnect everybody else.
&rsquo;ignore&rsquo; <br>
completely ignores the shared flag and allows everybody
connect unconditionally. Doesn&rsquo;t conform to the rfb
spec but is traditional QEMU behavior.</p>

<p style="margin-top: 1em">key-delay-ms <br>
Set keyboard delay, for key down and key up events, in
milliseconds. Default is 10. Keyboards are low-bandwidth
devices, so this slowdown can help the device and guest <br>
to keep up and not lose events in case events are arriving
in bulk. Possible causes for the latter are flaky network
connections, or scripts for automated testing.</p>

<p style="margin-top: 1em">i386 target only</p>

<p style="margin-top: 1em">-win2k-hack <br>
Use it when installing Windows 2000 to avoid a disk full
bug. After Windows 2000 is installed, you no longer need
this option (this option slows down the IDE transfers).</p>

<p style="margin-top: 1em">-no-fd-bootchk <br>
Disable boot signature checking for floppy disks in BIOS.
May be needed to boot from old floppy disks.</p>

<p style="margin-top: 1em">-no-acpi <br>
Disable ACPI (Advanced Configuration and Power Interface)
support. Use it if your guest OS complains about ACPI
problems (PC target machine only).</p>

<p style="margin-top: 1em">-no-hpet <br>
Disable HPET support.</p>

<p style="margin-top: 1em">-acpitable
[sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n]
[,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]...]
<br>
Add ACPI table with specified header fields and context from
specified files. For file=, take whole ACPI table from the
specified files, including all ACPI headers (possible <br>
overridden by other options). For data=, only data portion
of the table is used, all header information is specified in
the command line. If a SLIC table is supplied to <br>
QEMU, then the SLIC&rsquo;s oem_id and oem_table_id fields
will override the same in the RSDT and the FADT (a.k.a.
FACP), in order to ensure the field matches required by the
<br>
Microsoft SLIC spec and the ACPI spec.</p>

<p style="margin-top: 1em">-smbios file=binary <br>
Load SMBIOS entry from binary file.</p>

<p style="margin-top: 1em">-smbios
type=0[,vendor=str][,version=str][,date=str][,release=%d.%d][,uefi=on|off]
<br>
Specify SMBIOS type 0 fields</p>

<p style="margin-top: 1em">-smbios
type=1[,manufacturer=str][,product=str][,version=str][,serial=str][,uuid=uuid][,sku=str][,family=str]
<br>
Specify SMBIOS type 1 fields</p>

<p style="margin-top: 1em">-smbios
type=2[,manufacturer=str][,product=str][,version=str][,serial=str][,asset=str][,location=str][,family=str]
<br>
Specify SMBIOS type 2 fields</p>

<p style="margin-top: 1em">-smbios
type=3[,manufacturer=str][,version=str][,serial=str][,asset=str][,sku=str]
<br>
Specify SMBIOS type 3 fields</p>

<p style="margin-top: 1em">-smbios
type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str][,asset=str][,part=str]
<br>
Specify SMBIOS type 4 fields</p>

<p style="margin-top: 1em">-smbios
type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str][,asset=str][,part=str][,speed=%d]
<br>
Specify SMBIOS type 17 fields</p>

<p style="margin-top: 1em">Network options</p>

<p style="margin-top: 1em">-net
nic[,vlan=n][,macaddr=mac][,model=type]
[,name=name][,addr=addr][,vectors=v] <br>
Create a new Network Interface Card and connect it to VLAN n
(n = 0 is the default). The NIC is an e1000 by default on
the PC target. Optionally, the MAC address can be <br>
changed to mac, the device address set to addr (PCI cards
only), and a name can be assigned for use in monitor
commands. Optionally, for PCI cards, you can specify the
<br>
number v of MSI-X vectors that the card should have; this
option currently only affects virtio cards; set v = 0 to
disable MSI-X. If no -net option is specified, a single NIC
<br>
is created. QEMU can emulate several different models of
network card. Valid values for type are &quot;virtio&quot;,
&quot;i82551&quot;, &quot;i82557b&quot;,
&quot;i82559er&quot;, &quot;ne2k_pci&quot;,
&quot;ne2k_isa&quot;, &quot;pcnet&quot;, <br>
&quot;rtl8139&quot;, &quot;e1000&quot;,
&quot;smc91c111&quot;, &quot;lance&quot; and
&quot;mcf_fec&quot;. Not all devices are supported on all
targets. Use &quot;-net nic,model=help&quot; for a list of
available devices for your <br>
target.</p>

<p style="margin-top: 1em">-netdev
user,id=id[,option][,option][,...] <br>
-net user[,option][,option][,...] <br>
Use the user mode network stack which requires no
administrator privilege to run. Valid options are:</p>

<p style="margin-top: 1em">vlan=n <br>
Connect user mode stack to VLAN n (n = 0 is the
default).</p>

<p style="margin-top: 1em">id=id <br>
name=name <br>
Assign symbolic name for use in monitor commands.</p>

<p style="margin-top: 1em">ipv4 and ipv6 specify that
either IPv4 or IPv6 must be enabled. If neither is specified
both protocols are enabled.</p>

<p style="margin-top: 1em">net=addr[/mask] <br>
Set IP network address the guest will see. Optionally
specify the netmask, either in the form a.b.c.d or as number
of valid top-most bits. Default is 10.0.2.0/24.</p>

<p style="margin-top: 1em">host=addr <br>
Specify the guest-visible address of the host. Default is
the 2nd IP in the guest network, i.e. x.x.x.2.</p>

<p style="margin-top: 1em">ipv6-net=addr[/int] <br>
Set IPv6 network address the guest will see (default is
fec0::/64). The network prefix is given in the usual
hexadecimal IPv6 address notation. The prefix size is <br>
optional, and is given as the number of valid top-most bits
(default is 64).</p>

<p style="margin-top: 1em">ipv6-host=addr <br>
Specify the guest-visible IPv6 address of the host. Default
is the 2nd IPv6 in the guest network, i.e. xxxx::2.</p>

<p style="margin-top: 1em">restrict=on|off <br>
If this option is enabled, the guest will be isolated, i.e.
it will not be able to contact the host and no guest IP
packets will be routed over the host to the outside. <br>
This option does not affect any explicitly set forwarding
rules.</p>

<p style="margin-top: 1em">hostname=name <br>
Specifies the client hostname reported by the built-in DHCP
server.</p>

<p style="margin-top: 1em">dhcpstart=addr <br>
Specify the first of the 16 IPs the built-in DHCP server can
assign. Default is the 15th to 31st IP in the guest network,
i.e. x.x.x.15 to x.x.x.31.</p>

<p style="margin-top: 1em">dns=addr <br>
Specify the guest-visible address of the virtual nameserver.
The address must be different from the host address. Default
is the 3rd IP in the guest network, i.e. <br>
x.x.x.3.</p>

<p style="margin-top: 1em">ipv6-dns=addr <br>
Specify the guest-visible address of the IPv6 virtual
nameserver. The address must be different from the host
address. Default is the 3rd IP in the guest network, i.e.
<br>
xxxx::3.</p>

<p style="margin-top: 1em">dnssearch=domain <br>
Provides an entry for the domain-search list sent by the
built-in DHCP server. More than one domain suffix can be
transmitted by specifying this option multiple times. If
<br>
supported, this will cause the guest to automatically try to
append the given domain suffix(es) in case a domain name can
not be resolved.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">qemu -net
user,dnssearch=mgmt.example.org,dnssearch=example.org
[...]</p>

<p style="margin-top: 1em">tftp=dir <br>
When using the user mode network stack, activate a built-in
TFTP server. The files in dir will be exposed as the root of
a TFTP server. The TFTP client on the guest must <br>
be configured in binary mode (use the command
&quot;bin&quot; of the Unix TFTP client).</p>

<p style="margin-top: 1em">bootfile=file <br>
When using the user mode network stack, broadcast file as
the BOOTP filename. In conjunction with tftp, this can be
used to network boot a guest from a local directory.</p>

<p style="margin-top: 1em">Example (using pxelinux):</p>

<p style="margin-top: 1em">qemu-system-i386 -hda linux.img
-boot n -net
user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0</p>

<p style="margin-top: 1em">smb=dir[,smbserver=addr] <br>
When using the user mode network stack, activate a built-in
SMB server so that Windows OSes can access to the host files
in dir transparently. The IP address of the SMB <br>
server can be set to addr. By default the 4th IP in the
guest network is used, i.e. x.x.x.4.</p>

<p style="margin-top: 1em">In the guest Windows OS, the
line:</p>

<p style="margin-top: 1em">10.0.2.4 smbserver</p>

<p style="margin-top: 1em">must be added in the file
C:WINDOWSOSTS (for windows 9x/Me) or C:WINNTTEM32STCOSTS
(Windows NT/2000).</p>

<p style="margin-top: 1em">Then dir can be accessed in
\smbserverqemu.</p>

<p style="margin-top: 1em">Note that a SAMBA server must be
installed on the host OS. QEMU was tested successfully with
smbd versions from Red Hat 9, Fedora Core 3 and OpenSUSE
11.x.</p>


<p style="margin-top: 1em">hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport
<br>
Redirect incoming TCP or UDP connections to the host port
hostport to the guest IP address guestaddr on guest port
guestport. If guestaddr is not specified, its value is <br>
x.x.x.15 (default first address given by the built-in DHCP
server). By specifying hostaddr, the rule can be bound to a
specific host interface. If no connection type is <br>
set, TCP is used. This option can be given multiple
times.</p>

<p style="margin-top: 1em">For example, to redirect host
X11 connection from screen 1 to guest screen 0, use the
following:</p>

<p style="margin-top: 1em"># on the host <br>
qemu-system-i386 -net user,hostfwd=tcp:127.0.0.1:6001-:6000
[...] <br>
# this host xterm should open in the guest X11 server <br>
xterm -display :1</p>

<p style="margin-top: 1em">To redirect telnet connections
from host port 5555 to telnet port on the guest, use the
following:</p>

<p style="margin-top: 1em"># on the host <br>
qemu-system-i386 -net user,hostfwd=tcp::5555-:23 [...] <br>
telnet localhost 5555</p>

<p style="margin-top: 1em">Then when you use on the host
&quot;telnet localhost 5555&quot;, you connect to the guest
telnet server.</p>

<p style="margin-top: 1em">guestfwd=[tcp]:server:port-dev
<br>
guestfwd=[tcp]:server:port-cmd:command <br>
Forward guest TCP connections to the IP address server on
port port to the character device dev or to a program
executed by cmd:command which gets spawned for each <br>
connection. This option can be given multiple times.</p>

<p style="margin-top: 1em">You can either use a chardev
directly and have that one used throughout QEMU&rsquo;s
lifetime, like in the following example:</p>

<p style="margin-top: 1em"># open 10.10.1.1:4321 on bootup,
connect 10.0.2.100:1234 to it whenever <br>
# the guest accesses it <br>
qemu -net
user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321
[...]</p>

<p style="margin-top: 1em">Or you can execute a command on
every TCP connection established by the guest, so that QEMU
behaves similar to an inetd process for that virtual
server:</p>

<p style="margin-top: 1em"># call &quot;netcat 10.10.1.1
4321&quot; on every TCP connection to 10.0.2.100:1234 <br>
# and connect the TCP stream to its stdin/stdout <br>
qemu -net
&rsquo;user,guestfwd=tcp:10.0.2.100:1234-cmd:netcat
10.10.1.1 4321&rsquo;</p>

<p style="margin-top: 1em">Note: Legacy stand-alone options
-tftp, -bootp, -smb and -redir are still processed and
applied to -net user. Mixing them with the new configuration
syntax gives undefined <br>
results. Their use for new applications is discouraged as
they will be removed from future versions.</p>

<p style="margin-top: 1em">-netdev
tap,id=id[,fd=h][,ifname=name][,script=file][,downscript=dfile][,br=bridge][,helper=helper]
<br>
-net
tap[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile][,br=bridge][,helper=helper]
<br>
Connect the host TAP network interface name to VLAN n.</p>

<p style="margin-top: 1em">Use the network script file to
configure it and the network script dfile to deconfigure it.
If name is not provided, the OS automatically provides one.
The default network <br>
configure script is /etc/qemu-ifup and the default network
deconfigure script is /etc/qemu-ifdown. Use script=no or
downscript=no to disable script execution.</p>

<p style="margin-top: 1em">If running QEMU as an
unprivileged user, use the network helper helper to
configure the TAP interface and attach it to the bridge. The
default network helper executable is <br>
/path/to/qemu-bridge-helper and the default bridge device is
br0.</p>

<p style="margin-top: 1em">fd=h can be used to specify the
handle of an already opened host TAP interface.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network script <br>
qemu-system-i386 linux.img -net nic -net tap</p>

<p style="margin-top: 1em">#launch a QEMU instance with two
NICs, each one connected <br>
#to a TAP device <br>
qemu-system-i386 linux.img -net nic,vlan=0 -net
tap,vlan=0,ifname=tap0 -net nic,vlan=1 -net
tap,vlan=1,ifname=tap1</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network helper to <br>
#connect a TAP device to bridge br0 <br>
qemu-system-i386 linux.img -net nic -net
tap,&quot;helper=/path/to/qemu-bridge-helper&quot;</p>

<p style="margin-top: 1em">-netdev
bridge,id=id[,br=bridge][,helper=helper] <br>
-net bridge[,vlan=n][,name=name][,br=bridge][,helper=helper]
<br>
Connect a host TAP network interface to a host bridge
device.</p>

<p style="margin-top: 1em">Use the network helper helper to
configure the TAP interface and attach it to the bridge. The
default network helper executable is
/path/to/qemu-bridge-helper and the default <br>
bridge device is br0.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network helper to <br>
#connect a TAP device to bridge br0 <br>
qemu-system-i386 linux.img -net bridge -net
nic,model=virtio</p>

<p style="margin-top: 1em">#launch a QEMU instance with the
default network helper to <br>
#connect a TAP device to bridge qemubr0 <br>
qemu-system-i386 linux.img -net bridge,br=qemubr0 -net
nic,model=virtio</p>

<p style="margin-top: 1em">-netdev
socket,id=id[,fd=h][,listen=[host]:port][,connect=host:port]
<br>
-net socket[,vlan=n][,name=name][,fd=h]
[,listen=[host]:port][,connect=host:port] <br>
Connect the VLAN n to a remote VLAN in another QEMU virtual
machine using a TCP socket connection. If listen is
specified, QEMU waits for incoming connections on port (host
<br>
is optional). connect is used to connect to another QEMU
instance using the listen option. fd=h specifies an already
opened TCP socket.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># launch a first QEMU instance
<br>
qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:56 -net socket,listen=:1234 <br>
# connect the VLAN 0 of this instance to the VLAN 0 <br>
# of the first instance <br>
qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:57 -net
socket,connect=127.0.0.1:1234</p>

<p style="margin-top: 1em">-netdev
socket,id=id[,fd=h][,mcast=maddr:port[,localaddr=addr]] <br>
-net
socket[,vlan=n][,name=name][,fd=h][,mcast=maddr:port[,localaddr=addr]]
<br>
Create a VLAN n shared with another QEMU virtual machines
using a UDP multicast socket, effectively making a bus for
every QEMU with same multicast address maddr and port. <br>
NOTES:</p>

<p style="margin-top: 1em">1. Several QEMU can be running
on different hosts and share same bus (assuming correct
multicast setup for these hosts).</p>

<p style="margin-top: 1em">2. mcast support is compatible
with User Mode Linux (argument ethN=mcast), see
&lt;http://user-mode-linux.sf.net&gt;.</p>

<p style="margin-top: 1em">3. Use fd=h to specify an
already opened UDP multicast socket.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># launch one QEMU instance <br>
qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:56 -net
socket,mcast=230.0.0.1:1234 <br>
# launch another QEMU instance on same &quot;bus&quot; <br>
qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:57 -net
socket,mcast=230.0.0.1:1234 <br>
# launch yet another QEMU instance on same &quot;bus&quot;
<br>
qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:58 -net
socket,mcast=230.0.0.1:1234</p>

<p style="margin-top: 1em">Example (User Mode Linux
compat.):</p>

<p style="margin-top: 1em"># launch QEMU instance (note
mcast address selected <br>
# is UML&rsquo;s default) <br>
qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:56 -net
socket,mcast=239.192.168.1:1102 <br>
# launch UML <br>
/path/to/linux ubd0=/path/to/root_fs eth0=mcast</p>

<p style="margin-top: 1em">Example (send packets from
host&rsquo;s 1.2.3.4):</p>

<p style="margin-top: 1em">qemu-system-i386 linux.img -net
nic,macaddr=52:54:00:12:34:56 -net
socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4</p>

<p style="margin-top: 1em">-netdev <br>

l2tpv3,id=id,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]
<br>
-net <br>

l2tpv3[,vlan=n][,name=name],src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]
<br>
Connect VLAN n to L2TPv3 pseudowire. L2TPv3 (RFC3391) is a
popular protocol to transport Ethernet (and other Layer 2)
data frames between two systems. It is present in <br>
routers, firewalls and the Linux kernel (from version 3.3
onwards).</p>

<p style="margin-top: 1em">This transport allows a VM to
communicate to another VM, router or firewall directly.</p>

<p style="margin-top: 1em">src=srcaddr <br>
source address (mandatory)</p>

<p style="margin-top: 1em">dst=dstaddr <br>
destination address (mandatory)</p>

<p style="margin-top: 1em">udp select udp encapsulation
(default is ip).</p>

<p style="margin-top: 1em">srcport=srcport <br>
source udp port.</p>

<p style="margin-top: 1em">dstport=dstport <br>
destination udp port.</p>

<p style="margin-top: 1em">ipv6 <br>
force v6, otherwise defaults to v4.</p>

<p style="margin-top: 1em">rxcookie=rxcookie <br>
txcookie=txcookie <br>
Cookies are a weak form of security in the l2tpv3
specification. Their function is mostly to prevent
misconfiguration. By default they are 32 bit.</p>

<p style="margin-top: 1em">cookie64 <br>
Set cookie size to 64 bit instead of the default 32</p>

<p style="margin-top: 1em">counter=off <br>
Force a &rsquo;cut-down&rsquo; L2TPv3 with no counter as in
draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00</p>

<p style="margin-top: 1em">pincounter=on <br>
Work around broken counter handling in peer. This may also
help on networks which have packet reorder.</p>

<p style="margin-top: 1em">offset=offset <br>
Add an extra offset between header and data</p>

<p style="margin-top: 1em">For example, to attach a VM
running on host 4.3.2.1 via L2TPv3 to the bridge br-lan on
the remote Linux host 1.2.3.4:</p>

<p style="margin-top: 1em"># Setup tunnel on linux host
using raw ip as encapsulation <br>
# on 1.2.3.4 <br>
ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1
peer_tunnel_id 1 encap udp udp_sport 16384 udp_dport 16384
<br>
ip l2tp add session tunnel_id 1 name vmtunnel0 session_id
0xFFFFFFFF peer_session_id 0xFFFFFFFF <br>
ifconfig vmtunnel0 mtu 1500 <br>
ifconfig vmtunnel0 up <br>
brctl addif br-lan vmtunnel0</p>

<p style="margin-top: 1em"># on 4.3.2.1 <br>
# launch QEMU instance - if your network has reorder or is
very lossy add ,pincounter</p>

<p style="margin-top: 1em">qemu-system-i386 linux.img -net
nic -net
l2tpv3,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter</p>

<p style="margin-top: 1em">-netdev
vde,id=id[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]
<br>
-net vde[,vlan=n][,name=name][,sock=socketpath]
[,port=n][,group=groupname][,mode=octalmode] <br>
Connect VLAN n to PORT n of a vde switch running on host and
listening for incoming connections on socketpath. Use GROUP
groupname and MODE octalmode to change default <br>
ownership and permissions for communication port. This
option is only available if QEMU has been compiled with vde
support enabled.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em"># launch vde switch <br>
vde_switch -F -sock /tmp/myswitch <br>
# launch QEMU instance <br>
qemu-system-i386 linux.img -net nic -net
vde,sock=/tmp/myswitch</p>

<p style="margin-top: 1em">-netdev
hubport,id=id,hubid=hubid <br>
Create a hub port on QEMU &quot;vlan&quot; hubid.</p>

<p style="margin-top: 1em">The hubport netdev lets you
connect a NIC to a QEMU &quot;vlan&quot; instead of a single
netdev. &quot;-net&quot; and &quot;-device&quot; with
parameter vlan create the required hub automatically.</p>

<p style="margin-top: 1em">-netdev
vhost-user,chardev=id[,vhostforce=on|off][,queues=n] <br>
Establish a vhost-user netdev, backed by a chardev id. The
chardev should be a unix domain socket backed one. The
vhost-user uses a specifically defined protocol to pass <br>
vhost ioctl replacement messages to an application on the
other end of the socket. On non-MSIX guests, the feature can
be forced with vhostforce. Use &rsquo;queues=n&rsquo; to
specify <br>
the number of queues to be created for multiqueue
vhost-user.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">qemu -m 512 -object
memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on
-numa node,memdev=mem -chardev
socket,id=chr0,path=/path/to/socket -netdev
type=vhost-user,id=net0,chardev=chr0 -device
virtio-net-pci,netdev=net0</p>

<p style="margin-top: 1em">-net
dump[,vlan=n][,file=file][,len=len] <br>
Dump network traffic on VLAN n to file file (qemu-vlan0.pcap
by default). At most len bytes (64k by default) per packet
are stored. The file format is libpcap, so it can be <br>
analyzed with tools such as tcpdump or Wireshark. Note: For
devices created with &rsquo;-netdev&rsquo;, use
&rsquo;-object filter-dump,...&rsquo; instead.</p>

<p style="margin-top: 1em">-net none <br>
Indicate that no network devices should be configured. It is
used to override the default configuration (-net nic -net
user) which is activated if no -net options are <br>
provided.</p>

<p style="margin-top: 1em">Character device options</p>

<p style="margin-top: 1em">The general form of a character
device option is:</p>

<p style="margin-top: 1em">-chardev backend ,id=id
[,mux=on|off] [,options] <br>
Backend is one of: null, socket, udp, msmouse, vc, ringbuf,
file, pipe, console, serial, pty, stdio, braille, tty,
parallel, parport, spicevmc. spiceport. The specific <br>
backend will determine the applicable options.</p>

<p style="margin-top: 1em">Use &quot;-chardev help&quot; to
print all available chardev backend types.</p>

<p style="margin-top: 1em">All devices must have an id,
which can be any string up to 127 characters long. It is
used to uniquely identify this device in other command line
directives.</p>

<p style="margin-top: 1em">A character device may be used
in multiplexing mode by multiple front-ends. Specify mux=on
to enable this mode. A multiplexer is a &quot;1:N&quot;
device, and here the &quot;1&quot; end is <br>
your specified chardev backend, and the &quot;N&quot; end is
the various parts of QEMU that can talk to a chardev. If you
create a chardev with id=myid and mux=on, QEMU will create a
<br>
multiplexer with your specified ID, and you can then
configure multiple front ends to use that chardev ID for
their input/output. Up to four different front ends can be
<br>
connected to a single multiplexed chardev. (Without
multiplexing enabled, a chardev can only be used by a single
front end.) For instance you could use this to allow a <br>
single stdio chardev to be used by two serial ports and the
QEMU monitor:</p>

<p style="margin-top: 1em">-chardev stdio,mux=on,id=char0
-mon chardev=char0,mode=readline -serial chardev:char0
-serial chardev:char0</p>

<p style="margin-top: 1em">You can have more than one
multiplexer in a system configuration; for instance you
could have a TCP port multiplexed between UART 0 and UART 1,
and stdio multiplexed between <br>
the QEMU monitor and a parallel port:</p>

<p style="margin-top: 1em">-chardev stdio,mux=on,id=char0
-mon chardev=char0,mode=readline -parallel chardev:char0
-chardev tcp,...,mux=on,id=char1 -serial chardev:char1
-serial chardev:char1</p>

<p style="margin-top: 1em">When you&rsquo;re using a
multiplexed character device, some escape sequences are
interpreted in the input.</p>

<p style="margin-top: 1em">Note that some other command
line options may implicitly create multiplexed character
backends; for instance -serial mon:stdio creates a
multiplexed stdio backend connected <br>
to the serial port and the QEMU monitor, and -nographic also
multiplexes the console and the monitor to stdio.</p>

<p style="margin-top: 1em">There is currently no support
for multiplexing in the other direction (where a single QEMU
front end takes input and output from multiple
chardevs).</p>

<p style="margin-top: 1em">Every backend supports the
logfile option, which supplies the path to a file to record
all data transmitted via the backend. The logappend option
controls whether the log <br>
file will be truncated or appended to when opened.</p>

<p style="margin-top: 1em">Further options to each backend
are described below.</p>

<p style="margin-top: 1em">-chardev null ,id=id <br>
A void device. This device will not emit any data, and will
drop any data it receives. The null backend does not take
any options.</p>

<p style="margin-top: 1em">-chardev socket ,id=id [TCP
options or unix options] [,server] [,nowait] [,telnet]
[,reconnect=seconds] [,tls-creds=id] <br>
Create a two-way stream socket, which can be either a TCP or
a unix socket. A unix socket will be created if path is
specified. Behaviour is undefined if TCP options are <br>
specified for a unix socket.</p>

<p style="margin-top: 1em">server specifies that the socket
shall be a listening socket.</p>

<p style="margin-top: 1em">nowait specifies that QEMU
should not block waiting for a client to connect to a
listening socket.</p>

<p style="margin-top: 1em">telnet specifies that traffic on
the socket should interpret telnet escape sequences.</p>

<p style="margin-top: 1em">reconnect sets the timeout for
reconnecting on non-server sockets when the remote end goes
away. qemu will delay this many seconds and then attempt to
reconnect. Zero <br>
disables reconnecting, and is the default.</p>

<p style="margin-top: 1em">tls-creds requests enablement of
the TLS protocol for encryption, and specifies the id of the
TLS credentials to use for the handshake. The credentials
must be previously <br>
created with the -object tls-creds argument.</p>

<p style="margin-top: 1em">TCP and unix socket options are
given below:</p>

<p style="margin-top: 1em">TCP options: port=port
[,host=host] [,to=to] [,ipv4] [,ipv6] [,nodelay] <br>
host for a listening socket specifies the local address to
be bound. For a connecting socket species the remote host to
connect to. host is optional for listening <br>
sockets. If not specified it defaults to 0.0.0.0.</p>

<p style="margin-top: 1em">port for a listening socket
specifies the local port to be bound. For a connecting
socket specifies the port on the remote host to connect to.
port can be given as <br>
either a port number or a service name. port is
required.</p>

<p style="margin-top: 1em">to is only relevant to listening
sockets. If it is specified, and port cannot be bound, QEMU
will attempt to bind to subsequent ports up to and including
to until it <br>
succeeds. to must be specified as a port number.</p>

<p style="margin-top: 1em">ipv4 and ipv6 specify that
either IPv4 or IPv6 must be used. If neither is specified
the socket may use either protocol.</p>

<p style="margin-top: 1em">nodelay disables the Nagle
algorithm.</p>

<p style="margin-top: 1em">unix options: path=path <br>
path specifies the local path of the unix socket. path is
required.</p>

<p style="margin-top: 1em">-chardev udp ,id=id [,host=host]
,port=port [,localaddr=localaddr] [,localport=localport]
[,ipv4] [,ipv6] <br>
Sends all traffic from the guest to a remote host over
UDP.</p>

<p style="margin-top: 1em">host specifies the remote host
to connect to. If not specified it defaults to
&quot;localhost&quot;.</p>

<p style="margin-top: 1em">port specifies the port on the
remote host to connect to. port is required.</p>

<p style="margin-top: 1em">localaddr specifies the local
address to bind to. If not specified it defaults to
0.0.0.0.</p>

<p style="margin-top: 1em">localport specifies the local
port to bind to. If not specified any available local port
will be used.</p>

<p style="margin-top: 1em">ipv4 and ipv6 specify that
either IPv4 or IPv6 must be used. If neither is specified
the device may use either protocol.</p>

<p style="margin-top: 1em">-chardev msmouse ,id=id <br>
Forward QEMU&rsquo;s emulated msmouse events to the guest.
msmouse does not take any options.</p>

<p style="margin-top: 1em">-chardev vc ,id=id
[[,width=width] [,height=height]] [[,cols=cols]
[,rows=rows]] <br>
Connect to a QEMU text console. vc may optionally be given a
specific size.</p>

<p style="margin-top: 1em">width and height specify the
width and height respectively of the console, in pixels.</p>

<p style="margin-top: 1em">cols and rows specify that the
console be sized to fit a text console with the given
dimensions.</p>

<p style="margin-top: 1em">-chardev ringbuf ,id=id
[,size=size] <br>
Create a ring buffer with fixed size size. size must be a
power of two and defaults to &quot;64K&quot;.</p>

<p style="margin-top: 1em">-chardev file ,id=id ,path=path
<br>
Log all traffic received from the guest to a file.</p>

<p style="margin-top: 1em">path specifies the path of the
file to be opened. This file will be created if it does not
already exist, and overwritten if it does. path is
required.</p>

<p style="margin-top: 1em">-chardev pipe ,id=id ,path=path
<br>
Create a two-way connection to the guest. The behaviour
differs slightly between Windows hosts and other hosts:</p>

<p style="margin-top: 1em">On Windows, a single duplex pipe
will be created at \.pipeath.</p>

<p style="margin-top: 1em">On other hosts, 2 pipes will be
created called path.in and path.out. Data written to path.in
will be received by the guest. Data written by the guest can
be read from <br>
path.out. QEMU will not create these fifos, and requires
them to be present.</p>

<p style="margin-top: 1em">path forms part of the pipe path
as described above. path is required.</p>

<p style="margin-top: 1em">-chardev console ,id=id <br>
Send traffic from the guest to QEMU&rsquo;s standard output.
console does not take any options.</p>

<p style="margin-top: 1em">console is only available on
Windows hosts.</p>

<p style="margin-top: 1em">-chardev serial ,id=id
,path=path <br>
Send traffic from the guest to a serial device on the
host.</p>

<p style="margin-top: 1em">On Unix hosts serial will
actually accept any tty device, not only serial lines.</p>

<p style="margin-top: 1em">path specifies the name of the
serial device to open.</p>

<p style="margin-top: 1em">-chardev pty ,id=id <br>
Create a new pseudo-terminal on the host and connect to it.
pty does not take any options.</p>

<p style="margin-top: 1em">pty is not available on Windows
hosts.</p>

<p style="margin-top: 1em">-chardev stdio ,id=id
[,signal=on|off] <br>
Connect to standard input and standard output of the QEMU
process.</p>

<p style="margin-top: 1em">signal controls if signals are
enabled on the terminal, that includes exiting QEMU with the
key sequence Control-c. This option is enabled by default,
use signal=off to <br>
disable it.</p>

<p style="margin-top: 1em">-chardev braille ,id=id <br>
Connect to a local BrlAPI server. braille does not take any
options.</p>

<p style="margin-top: 1em">-chardev tty ,id=id ,path=path
<br>
tty is only available on Linux, Sun, FreeBSD, NetBSD,
OpenBSD and DragonFlyBSD hosts. It is an alias for
serial.</p>

<p style="margin-top: 1em">path specifies the path to the
tty. path is required.</p>

<p style="margin-top: 1em">-chardev parallel ,id=id
,path=path <br>
-chardev parport ,id=id ,path=path <br>
parallel is only available on Linux, FreeBSD and
DragonFlyBSD hosts.</p>

<p style="margin-top: 1em">Connect to a local parallel
port.</p>

<p style="margin-top: 1em">path specifies the path to the
parallel port device. path is required.</p>

<p style="margin-top: 1em">-chardev spicevmc ,id=id
,debug=debug, name=name <br>
spicevmc is only available when spice support is built
in.</p>

<p style="margin-top: 1em">debug debug level for
spicevmc</p>

<p style="margin-top: 1em">name name of spice channel to
connect to</p>

<p style="margin-top: 1em">Connect to a spice virtual
machine channel, such as vdiport.</p>

<p style="margin-top: 1em">-chardev spiceport ,id=id
,debug=debug, name=name <br>
spiceport is only available when spice support is built
in.</p>

<p style="margin-top: 1em">debug debug level for
spicevmc</p>

<p style="margin-top: 1em">name name of spice port to
connect to</p>

<p style="margin-top: 1em">Connect to a spice port,
allowing a Spice client to handle the traffic identified by
a name (preferably a fqdn).</p>

<p style="margin-top: 1em">Device URL Syntax</p>

<p style="margin-top: 1em">In addition to using normal file
images for the emulated storage devices, QEMU can also use
networked resources such as iSCSI devices. These are
specified using a special URL <br>
syntax.</p>

<p style="margin-top: 1em">iSCSI <br>
iSCSI support allows QEMU to access iSCSI resources directly
and use as images for the guest storage. Both disk and cdrom
images are supported.</p>

<p style="margin-top: 1em">Syntax for specifying iSCSI LUNs
is
&quot;iscsi://&lt;target-ip&gt;[:&lt;port&gt;]/&lt;target-iqn&gt;/&lt;lun&gt;&quot;</p>

<p style="margin-top: 1em">By default qemu will use the
iSCSI initiator-name
&rsquo;iqn.2008-11.org.linux-kvm[:&lt;name&gt;]&rsquo; but
this can also be set from the command line or a
configuration file.</p>

<p style="margin-top: 1em">Since version Qemu 2.4 it is
possible to specify a iSCSI request timeout to detect
stalled requests and force a reestablishment of the session.
The timeout is specified in <br>
seconds. The default is 0 which means no timeout. Libiscsi
1.15.0 or greater is required for this feature.</p>

<p style="margin-top: 1em">Example (without
authentication):</p>

<p style="margin-top: 1em">qemu-system-i386 -iscsi
initiator-name=iqn.2001-04.com.example:my-initiator -cdrom
iscsi://192.0.2.1/iqn.2001-04.com.example/2 -drive
file=iscsi://192.0.2.1/iqn.2001-04.com.example/1</p>

<p style="margin-top: 1em">Example (CHAP username/password
via URL):</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
file=iscsi://user%password@192.0.2.1/iqn.2001-04.com.example/1</p>

<p style="margin-top: 1em">Example (CHAP username/password
via environment variables):</p>


<p style="margin-top: 1em">LIBISCSI_CHAP_USERNAME=&quot;user&quot;
LIBISCSI_CHAP_PASSWORD=&quot;password&quot; qemu-system-i386
-drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1</p>

<p style="margin-top: 1em">iSCSI support is an optional
feature of QEMU and only available when compiled and linked
against libiscsi.</p>

<p style="margin-top: 1em">iSCSI parameters such as
username and password can also be specified via a
configuration file. See qemu-doc for more information and
examples.</p>

<p style="margin-top: 1em">NBD QEMU supports NBD (Network
Block Devices) both using TCP protocol as well as Unix
Domain Sockets.</p>

<p style="margin-top: 1em">Syntax for specifying a NBD
device using TCP
&quot;nbd:&lt;server-ip&gt;:&lt;port&gt;[:exportname=&lt;export&gt;]&quot;</p>

<p style="margin-top: 1em">Syntax for specifying a NBD
device using Unix Domain Sockets
&quot;nbd:unix:&lt;domain-socket&gt;[:exportname=&lt;export&gt;]&quot;</p>

<p style="margin-top: 1em">Example for TCP</p>

<p style="margin-top: 1em">qemu-system-i386 --drive
file=nbd:192.0.2.1:30000</p>

<p style="margin-top: 1em">Example for Unix Domain
Sockets</p>

<p style="margin-top: 1em">qemu-system-i386 --drive
file=nbd:unix:/tmp/nbd-socket</p>

<p style="margin-top: 1em">SSH QEMU supports SSH (Secure
Shell) access to remote disks.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">qemu-system-i386 -drive
file=ssh://user@host/path/to/disk.img <br>
qemu-system-i386 -drive
file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img</p>

<p style="margin-top: 1em">Currently authentication must be
done using ssh-agent. Other authentication methods may be
supported in future.</p>

<p style="margin-top: 1em">Sheepdog <br>
Sheepdog is a distributed storage system for QEMU. QEMU
supports using either local sheepdog devices or remote
networked devices.</p>

<p style="margin-top: 1em">Syntax for specifying a sheepdog
device</p>


<p style="margin-top: 1em">sheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">qemu-system-i386 --drive
file=sheepdog://192.0.2.1:30000/MyVirtualMachine</p>

<p style="margin-top: 1em">See also
&lt;https://sheepdog.github.io/sheepdog/&gt;.</p>

<p style="margin-top: 1em">GlusterFS <br>
GlusterFS is a user space distributed file system. QEMU
supports the use of GlusterFS volumes for hosting VM disk
images using TCP, Unix Domain Sockets and RDMA transport
<br>
protocols.</p>

<p style="margin-top: 1em">Syntax for specifying a VM disk
image on GlusterFS volume is</p>

<p style="margin-top: 1em">URI: <br>

gluster[+type]://[host[:port]]/volume/path[?socket=...][,debug=N][,logfile=...]</p>

<p style="margin-top: 1em">JSON: <br>

&rsquo;json:{&quot;driver&quot;:&quot;qcow2&quot;,&quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,&quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,&quot;debug&quot;:N,&quot;logfile&quot;:&quot;...&quot;,
<br>

&quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;...&quot;,&quot;port&quot;:&quot;...&quot;},
<br>

{&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;...&quot;}]}}&rsquo;</p>

<p style="margin-top: 1em">Example</p>

<p style="margin-top: 1em">URI: <br>
qemu-system-x86_64 --drive
file=gluster://192.0.2.1/testvol/a.img, <br>
file.debug=9,file.logfile=/var/log/qemu-gluster.log</p>

<p style="margin-top: 1em">JSON: <br>
qemu-system-x86_64
&rsquo;json:{&quot;driver&quot;:&quot;qcow2&quot;, <br>
&quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,
<br>

&quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,
<br>

&quot;debug&quot;:9,&quot;logfile&quot;:&quot;/var/log/qemu-gluster.log&quot;,
<br>

&quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;1.2.3.4&quot;,&quot;port&quot;:24007},
<br>

{&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;/var/run/glusterd.socket&quot;}]}}&rsquo;
<br>
qemu-system-x86_64 -drive
driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
<br>
file.debug=9,file.logfile=/var/log/qemu-gluster.log, <br>

file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
<br>

file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket</p>

<p style="margin-top: 1em">See also
&lt;http://www.gluster.org&gt;.</p>

<p style="margin-top: 1em">HTTP/HTTPS/FTP/FTPS <br>
QEMU supports read-only access to files accessed over
http(s) and ftp(s).</p>

<p style="margin-top: 1em">Syntax using a single
filename:</p>


<p style="margin-top: 1em">&lt;protocol&gt;://[&lt;username&gt;[:&lt;password&gt;]@]&lt;host&gt;/&lt;path&gt;</p>

<p style="margin-top: 1em">where:</p>

<p style="margin-top: 1em">protocol <br>
&rsquo;http&rsquo;, &rsquo;https&rsquo;, &rsquo;ftp&rsquo;,
or &rsquo;ftps&rsquo;.</p>

<p style="margin-top: 1em">username <br>
Optional username for authentication to the remote
server.</p>

<p style="margin-top: 1em">password <br>
Optional password for authentication to the remote
server.</p>

<p style="margin-top: 1em">host <br>
Address of the remote server.</p>

<p style="margin-top: 1em">path <br>
Path on the remote server, including any query string.</p>

<p style="margin-top: 1em">The following options are also
supported:</p>

<p style="margin-top: 1em">url The full URL when passing
options to the driver explicitly.</p>

<p style="margin-top: 1em">readahead <br>
The amount of data to read ahead with each range request to
the remote server. This value may optionally have the suffix
&rsquo;T&rsquo;, &rsquo;G&rsquo;, &rsquo;M&rsquo;,
&rsquo;K&rsquo;, &rsquo;k&rsquo; or &rsquo;b&rsquo;. If it
does not <br>
have a suffix, it will be assumed to be in bytes. The value
must be a multiple of 512 bytes. It defaults to 256k.</p>

<p style="margin-top: 1em">sslverify <br>
Whether to verify the remote server&rsquo;s certificate when
connecting over SSL. It can have the value &rsquo;on&rsquo;
or &rsquo;off&rsquo;. It defaults to &rsquo;on&rsquo;.</p>

<p style="margin-top: 1em">cookie <br>
Send this cookie (it can also be a list of cookies separated
by &rsquo;;&rsquo;) with each outgoing request. Only
supported when using protocols such as HTTP which support
cookies, <br>
otherwise ignored.</p>

<p style="margin-top: 1em">timeout <br>
Set the timeout in seconds of the CURL connection. This
timeout is the time that CURL waits for a response from the
remote server to get the size of the image to be <br>
downloaded. If not set, the default timeout of 5 seconds is
used.</p>

<p style="margin-top: 1em">Note that when passing options
to qemu explicitly, driver is the value of
&lt;protocol&gt;.</p>

<p style="margin-top: 1em">Example: boot from a remote
Fedora 20 live ISO image</p>

<p style="margin-top: 1em">qemu-system-x86_64 --drive
media=cdrom,file=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly</p>

<p style="margin-top: 1em">qemu-system-x86_64 --drive
media=cdrom,file.driver=http,file.url=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly</p>

<p style="margin-top: 1em">Example: boot from a remote
Fedora 20 cloud image using a local overlay for writes,
copy-on-read, and a readahead of 64k</p>

<p style="margin-top: 1em">qemu-img create -f qcow2 -o
backing_file=&rsquo;json:{&quot;file.driver&quot;:&quot;http&quot;,,
&quot;file.url&quot;:&quot;https://dl.fedoraproject.org/pub/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2&quot;,,
&quot;file.readahead&quot;:&quot;64k&quot;}&rsquo;
/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2</p>

<p style="margin-top: 1em">qemu-system-x86_64 -drive
file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on</p>

<p style="margin-top: 1em">Example: boot from an image
stored on a VMware vSphere server with a self-signed
certificate using a local overlay for writes, a readahead of
64k and a timeout of 10 seconds.</p>

<p style="margin-top: 1em">qemu-img create -f qcow2 -o
backing_file=&rsquo;json:{&quot;file.driver&quot;:&quot;https&quot;,,
&quot;file.url&quot;:&quot;https://user:password@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&amp;dsName=datastore1&quot;,,
&quot;file.sslverify&quot;:&quot;off&quot;,,
&quot;file.readahead&quot;:&quot;64k&quot;,,
&quot;file.timeout&quot;:10}&rsquo; /tmp/test.qcow2</p>

<p style="margin-top: 1em">qemu-system-x86_64 -drive
file=/tmp/test.qcow2</p>

<p style="margin-top: 1em">Bluetooth(R) options</p>

<p style="margin-top: 1em">-bt hci[...] <br>
Defines the function of the corresponding Bluetooth HCI. -bt
options are matched with the HCIs present in the chosen
machine type. For example when emulating a machine with <br>
only one HCI built into it, only the first &quot;-bt
hci[...]&quot; option is valid and defines the HCI&rsquo;s
logic. The Transport Layer is decided by the machine type.
Currently the <br>
machines &quot;n800&quot; and &quot;n810&quot; have one HCI
and all other machines have none.</p>

<p style="margin-top: 1em">The following three types are
recognized:</p>

<p style="margin-top: 1em">-bt hci,null <br>
(default) The corresponding Bluetooth HCI assumes no
internal logic and will not respond to any HCI commands or
emit events.</p>

<p style="margin-top: 1em">-bt hci,host[:id] <br>
(&quot;bluez&quot; only) The corresponding HCI passes
commands / events to / from the physical HCI identified by
the name id (default: &quot;hci0&quot;) on the computer
running QEMU. Only <br>
available on &quot;bluez&quot; capable systems like
Linux.</p>

<p style="margin-top: 1em">-bt hci[,vlan=n] <br>
Add a virtual, standard HCI that will participate in the
Bluetooth scatternet n (default 0). Similarly to -net VLANs,
devices inside a bluetooth network n can only <br>
communicate with other devices in the same network
(scatternet).</p>

<p style="margin-top: 1em">-bt vhci[,vlan=n] <br>
(Linux-host only) Create a HCI in scatternet n (default 0)
attached to the host bluetooth stack instead of to the
emulated target. This allows the host and target machines
<br>
to participate in a common scatternet and communicate.
Requires the Linux &quot;vhci&quot; driver installed. Can be
used as following:</p>

<p style="margin-top: 1em">qemu-system-i386 [...OPTIONS...]
-bt hci,vlan=5 -bt vhci,vlan=5</p>

<p style="margin-top: 1em">-bt device:dev[,vlan=n] <br>
Emulate a bluetooth device dev and place it in network n
(default 0). QEMU can only emulate one type of bluetooth
devices currently:</p>

<p style="margin-top: 1em">keyboard <br>
Virtual wireless keyboard implementing the HIDP bluetooth
profile.</p>

<p style="margin-top: 1em">TPM device options</p>

<p style="margin-top: 1em">The general form of a TPM device
option is:</p>

<p style="margin-top: 1em">-tpmdev backend ,id=id
[,options] <br>
Backend type must be: passthrough.</p>

<p style="margin-top: 1em">The specific backend type will
determine the applicable options. The &quot;-tpmdev&quot;
option creates the TPM backend and requires a
&quot;-device&quot; option that specifies the TPM frontend
<br>
interface model.</p>

<p style="margin-top: 1em">Options to each backend are
described below.</p>

<p style="margin-top: 1em">Use &rsquo;help&rsquo; to print
all available TPM backend types.</p>

<p style="margin-top: 1em">qemu -tpmdev help</p>

<p style="margin-top: 1em">-tpmdev passthrough, id=id,
path=path, cancel-path=cancel-path <br>
(Linux-host only) Enable access to the host&rsquo;s TPM
using the passthrough driver.</p>

<p style="margin-top: 1em">path specifies the path to the
host&rsquo;s TPM device, i.e., on a Linux host this would be
&quot;/dev/tpm0&quot;. path is optional and by default
&quot;/dev/tpm0&quot; is used.</p>

<p style="margin-top: 1em">cancel-path specifies the path
to the host TPM device&rsquo;s sysfs entry allowing for
cancellation of an ongoing TPM command. cancel-path is
optional and by default QEMU will <br>
search for the sysfs entry to use.</p>

<p style="margin-top: 1em">Some notes about using the
host&rsquo;s TPM with the passthrough driver:</p>

<p style="margin-top: 1em">The TPM device accessed by the
passthrough driver must not be used by any other application
on the host.</p>

<p style="margin-top: 1em">Since the host&rsquo;s firmware
(BIOS/UEFI) has already initialized the TPM, the VM&rsquo;s
firmware (BIOS/UEFI) will not be able to initialize the TPM
again and may therefore not show a <br>
TPM-specific menu that would otherwise allow the user to
configure the TPM, e.g., allow the user to enable/disable or
activate/deactivate the TPM. Further, if TPM ownership <br>
is released from within a VM then the host&rsquo;s TPM will
get disabled and deactivated. To enable and activate the TPM
again afterwards, the host has to be rebooted and the user
<br>
is required to enter the firmware&rsquo;s menu to enable and
activate the TPM. If the TPM is left disabled and/or
deactivated most TPM commands will fail.</p>

<p style="margin-top: 1em">To create a passthrough TPM use
the following two options:</p>

<p style="margin-top: 1em">-tpmdev passthrough,id=tpm0
-device tpm-tis,tpmdev=tpm0</p>

<p style="margin-top: 1em">Note that the
&quot;-tpmdev&quot; id is &quot;tpm0&quot; and is referenced
by &quot;tpmdev=tpm0&quot; in the device option.</p>

<p style="margin-top: 1em">Linux/Multiboot boot
specific</p>

<p style="margin-top: 1em">When using these options, you
can use a given Linux or Multiboot kernel without installing
it in the disk image. It can be useful for easier testing of
various kernels.</p>

<p style="margin-top: 1em">-kernel bzImage <br>
Use bzImage as kernel image. The kernel can be either a
Linux kernel or in multiboot format.</p>

<p style="margin-top: 1em">-append cmdline <br>
Use cmdline as kernel command line</p>

<p style="margin-top: 1em">-initrd file <br>
Use file as initial ram disk.</p>

<p style="margin-top: 1em">-initrd &quot;file1
arg=foo,file2&quot; <br>
This syntax is only available with multiboot.</p>

<p style="margin-top: 1em">Use file1 and file2 as modules
and pass arg=foo as parameter to the first module.</p>

<p style="margin-top: 1em">-dtb file <br>
Use file as a device tree binary (dtb) image and pass it to
the kernel on boot.</p>

<p style="margin-top: 1em">Debug/Expert options</p>

<p style="margin-top: 1em">-fw_cfg [name=]name,file=file
<br>
Add named fw_cfg entry with contents from file file.</p>

<p style="margin-top: 1em">-fw_cfg [name=]name,string=str
<br>
Add named fw_cfg entry with contents from string str.</p>

<p style="margin-top: 1em">The terminating NUL character of
the contents of str will not be included as part of the
fw_cfg item data. To insert contents with embedded NUL
characters, you have to use <br>
the file parameter.</p>

<p style="margin-top: 1em">The fw_cfg entries are passed by
QEMU through to the guest.</p>

<p style="margin-top: 1em">Example:</p>

<p style="margin-top: 1em">-fw_cfg
name=opt/com.mycompany/blob,file=./my_blob.bin</p>

<p style="margin-top: 1em">creates an fw_cfg entry named
opt/com.mycompany/blob with contents from ./my_blob.bin.</p>

<p style="margin-top: 1em">-serial dev <br>
Redirect the virtual serial port to host character device
dev. The default device is &quot;vc&quot; in graphical mode
and &quot;stdio&quot; in non graphical mode.</p>

<p style="margin-top: 1em">This option can be used several
times to simulate up to 4 serial ports.</p>

<p style="margin-top: 1em">Use &quot;-serial none&quot; to
disable all serial ports.</p>

<p style="margin-top: 1em">Available character devices
are:</p>

<p style="margin-top: 1em">vc[:WxH] <br>
Virtual console. Optionally, a width and height can be given
in pixel with</p>

<p style="margin-top: 1em">vc:800x600</p>

<p style="margin-top: 1em">It is also possible to specify
width or height in characters:</p>

<p style="margin-top: 1em">vc:80Cx24C</p>

<p style="margin-top: 1em">pty [Linux only] Pseudo TTY (a
new PTY is automatically allocated)</p>

<p style="margin-top: 1em">none <br>
No device is allocated.</p>

<p style="margin-top: 1em">null <br>
void device</p>

<p style="margin-top: 1em">chardev:id <br>
Use a named character device defined with the
&quot;-chardev&quot; option.</p>

<p style="margin-top: 1em">/dev/XXX <br>
[Linux only] Use host tty, e.g. /dev/ttyS0. The host serial
port parameters are set according to the emulated ones.</p>

<p style="margin-top: 1em">/dev/parportN <br>
[Linux only, parallel port only] Use host parallel port N.
Currently SPP and EPP parallel port features can be
used.</p>

<p style="margin-top: 1em">file:filename <br>
Write output to filename. No character can be read.</p>

<p style="margin-top: 1em">stdio <br>
[Unix only] standard input/output</p>

<p style="margin-top: 1em">pipe:filename <br>
name pipe filename</p>

<p style="margin-top: 1em">COMn <br>
[Windows only] Use host serial port n</p>


<p style="margin-top: 1em">udp:[remote_host]:remote_port[@[src_ip]:src_port]
<br>
This implements UDP Net Console. When remote_host or src_ip
are not specified they default to 0.0.0.0. When not using a
specified src_port a random port is <br>
automatically chosen.</p>

<p style="margin-top: 1em">If you just want a simple
readonly console you can use &quot;netcat&quot; or
&quot;nc&quot;, by starting QEMU with: &quot;-serial
udp::4555&quot; and nc as: &quot;nc -u -l -p 4555&quot;. Any
time QEMU writes <br>
something to that port it will appear in the netconsole
session.</p>

<p style="margin-top: 1em">If you plan to send characters
back via netconsole or you want to stop and start QEMU a lot
of times, you should have QEMU use the same source port each
time by using <br>
something like &quot;-serial udp::4555@4556&quot; to QEMU.
Another approach is to use a patched version of netcat which
can listen to a TCP port and send and receive characters via
<br>
udp. If you have a patched version of netcat which activates
telnet remote echo and single char transfer, then you can
use the following options to set up a netcat <br>
redirector to allow telnet on port 5555 to access the QEMU
port.</p>

<p style="margin-top: 1em">&quot;QEMU Options:&quot; <br>
-serial udp::4555@4556</p>

<p style="margin-top: 1em">&quot;netcat options:&quot; <br>
-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T</p>

<p style="margin-top: 1em">&quot;telnet options:&quot; <br>
localhost 5555</p>


<p style="margin-top: 1em">tcp:[host]:port[,server][,nowait][,nodelay][,reconnect=seconds]
<br>
The TCP Net Console has two modes of operation. It can send
the serial I/O to a location or wait for a connection from a
location. By default the TCP Net Console is <br>
sent to host at the port. If you use the server option QEMU
will wait for a client socket application to connect to the
port before continuing, unless the &quot;nowait&quot; <br>
option was specified. The &quot;nodelay&quot; option
disables the Nagle buffering algorithm. The
&quot;reconnect&quot; option only applies if noserver is
set, if the connection goes down <br>
it will attempt to reconnect at the given interval. If host
is omitted, 0.0.0.0 is assumed. Only one TCP connection at a
time is accepted. You can use &quot;telnet&quot; to <br>
connect to the corresponding character device.</p>

<p style="margin-top: 1em">&quot;Example to send tcp
console to 192.168.0.2 port 4444&quot; <br>
-serial tcp:192.168.0.2:4444</p>

<p style="margin-top: 1em">&quot;Example to listen and wait
on port 4444 for connection&quot; <br>
-serial tcp::4444,server</p>

<p style="margin-top: 1em">&quot;Example to not wait and
listen on ip 192.168.0.100 port 4444&quot; <br>
-serial tcp:192.168.0.100:4444,server,nowait</p>


<p style="margin-top: 1em">telnet:host:port[,server][,nowait][,nodelay]
<br>
The telnet protocol is used instead of raw tcp sockets. The
options work the same as if you had specified &quot;-serial
tcp&quot;. The difference is that the port acts like a <br>
telnet server or client using telnet option negotiation.
This will also allow you to send the MAGIC_SYSRQ sequence if
you use a telnet that supports sending the break <br>
sequence. Typically in unix telnet you do it with Control-]
and then type &quot;send break&quot; followed by pressing
the enter key.</p>


<p style="margin-top: 1em">unix:path[,server][,nowait][,reconnect=seconds]
<br>
A unix domain socket is used instead of a tcp socket. The
option works the same as if you had specified &quot;-serial
tcp&quot; except the unix domain socket path is used for
<br>
connections.</p>

<p style="margin-top: 1em">mon:dev_string <br>
This is a special option to allow the monitor to be
multiplexed onto another serial port. The monitor is
accessed with key sequence of Control-a and then pressing c.
<br>
dev_string should be any one of the serial devices specified
above. An example to multiplex the monitor onto a telnet
server listening on port 4444 would be:</p>

<p style="margin-top: 1em">&quot;-serial
mon:telnet::4444,server,nowait&quot;</p>

<p style="margin-top: 1em">When the monitor is multiplexed
to stdio in this way, Ctrl+C will not terminate QEMU any
more but will be passed to the guest instead.</p>

<p style="margin-top: 1em">braille <br>
Braille device. This will use BrlAPI to display the braille
output on a real or fake device.</p>

<p style="margin-top: 1em">msmouse <br>
Three button serial mouse. Configure the guest to use
Microsoft protocol.</p>

<p style="margin-top: 1em">-parallel dev <br>
Redirect the virtual parallel port to host device dev (same
devices as the serial port). On Linux hosts, /dev/parportN
can be used to use hardware devices connected on the <br>
corresponding host parallel port.</p>

<p style="margin-top: 1em">This option can be used several
times to simulate up to 3 parallel ports.</p>

<p style="margin-top: 1em">Use &quot;-parallel none&quot;
to disable all parallel ports.</p>

<p style="margin-top: 1em">-monitor dev <br>
Redirect the monitor to host device dev (same devices as the
serial port). The default device is &quot;vc&quot; in
graphical mode and &quot;stdio&quot; in non graphical mode.
Use &quot;-monitor <br>
none&quot; to disable the default monitor.</p>

<p style="margin-top: 1em">-qmp dev <br>
Like -monitor but opens in &rsquo;control&rsquo; mode.</p>

<p style="margin-top: 1em">-qmp-pretty dev <br>
Like -qmp but uses pretty JSON formatting.</p>

<p style="margin-top: 1em">-mon
[chardev=]name[,mode=readline|control] <br>
Setup monitor on chardev name.</p>

<p style="margin-top: 1em">-debugcon dev <br>
Redirect the debug console to host device dev (same devices
as the serial port). The debug console is an I/O port which
is typically port 0xe9; writing to that I/O port <br>
sends output to this device. The default device is
&quot;vc&quot; in graphical mode and &quot;stdio&quot; in
non graphical mode.</p>

<p style="margin-top: 1em">-pidfile file <br>
Store the QEMU process PID in file. It is useful if you
launch QEMU from a script.</p>

<p style="margin-top: 1em">-singlestep <br>
Run the emulation in single step mode.</p>

<p style="margin-top: 1em">-S Do not start CPU at startup
(you must type &rsquo;c&rsquo; in the monitor).</p>

<p style="margin-top: 1em">-realtime mlock=on|off <br>
Run qemu with realtime features. mlocking qemu and guest
memory can be enabled via mlock=on (enabled by default).</p>

<p style="margin-top: 1em">-gdb dev <br>
Wait for gdb connection on device dev. Typical connections
will likely be TCP-based, but also UDP, pseudo TTY, or even
stdio are reasonable use case. The latter is allowing <br>
to start QEMU from within gdb and establish the connection
via a pipe:</p>

<p style="margin-top: 1em">(gdb) target remote | exec
qemu-system-i386 -gdb stdio ...</p>

<p style="margin-top: 1em">-s Shorthand for -gdb tcp::1234,
i.e. open a gdbserver on TCP port 1234.</p>

<p style="margin-top: 1em">-d item1[,...] <br>
Enable logging of specified items. Use &rsquo;-d help&rsquo;
for a list of log items.</p>

<p style="margin-top: 1em">-D logfile <br>
Output log in logfile instead of to stderr</p>

<p style="margin-top: 1em">-dfilter range1[,...] <br>
Filter debug output to that relevant to a range of target
addresses. The filter spec can be either start+size,
start-size or start..end where start end and size are the
<br>
addresses and sizes required. For example:</p>

<p style="margin-top: 1em">-dfilter
0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000</p>

<p style="margin-top: 1em">Will dump output for any code in
the 0x1000 sized block starting at 0x8000 and the 0x200
sized block starting at 0xffffffc000080000 and another
0x1000 sized block starting at <br>
0xffffffc00005f000.</p>

<p style="margin-top: 1em">-L path <br>
Set the directory for the BIOS, VGA BIOS and keymaps.</p>

<p style="margin-top: 1em">To list all the data
directories, use &quot;-L help&quot;.</p>

<p style="margin-top: 1em">-bios file <br>
Set the filename for the BIOS.</p>

<p style="margin-top: 1em">-enable-kvm <br>
Enable KVM full virtualization support. This option is only
available if KVM support is enabled when compiling.</p>

<p style="margin-top: 1em">-enable-hax <br>
Enable HAX (Hardware-based Acceleration eXecution) support.
This option is only available if HAX support is enabled when
compiling. HAX is only applicable to MAC and Windows <br>
platform, and thus does not conflict with KVM.</p>

<p style="margin-top: 1em">-xen-domid id <br>
Specify xen guest domain id (XEN only).</p>

<p style="margin-top: 1em">-xen-create <br>
Create domain using xen hypercalls, bypassing xend. Warning:
should not be used when xend is in use (XEN only).</p>

<p style="margin-top: 1em">-xen-attach <br>
Attach to existing xen domain. xend will use this when
starting QEMU (XEN only).</p>

<p style="margin-top: 1em">-no-reboot <br>
Exit instead of rebooting.</p>

<p style="margin-top: 1em">-no-shutdown <br>
Don&rsquo;t exit QEMU on guest shutdown, but instead only
stop the emulation. This allows for instance switching to
monitor to commit changes to the disk image.</p>

<p style="margin-top: 1em">-loadvm file <br>
Start right away with a saved state (&quot;loadvm&quot; in
monitor)</p>

<p style="margin-top: 1em">-daemonize <br>
Daemonize the QEMU process after initialization. QEMU will
not detach from standard IO until it is ready to receive
connections on any of its devices. This option is a <br>
useful way for external programs to launch QEMU without
having to cope with initialization race conditions.</p>

<p style="margin-top: 1em">-option-rom file <br>
Load the contents of file as an option ROM. This option is
useful to load things like EtherBoot.</p>

<p style="margin-top: 1em">-rtc
[base=utc|localtime|date][,clock=host|vm][,driftfix=none|slew]
<br>
Specify base as &quot;utc&quot; or &quot;localtime&quot; to
let the RTC start at the current UTC or local time,
respectively. &quot;localtime&quot; is required for correct
date in MS-DOS or Windows. To <br>
start at a specific point in time, provide date in the
format &quot;2006-06-17T16:01:21&quot; or
&quot;2006-06-17&quot;. The default base is UTC.</p>

<p style="margin-top: 1em">By default the RTC is driven by
the host system time. This allows using of the RTC as
accurate reference clock inside the guest, specifically if
the host time is smoothly <br>
following an accurate external reference clock, e.g. via
NTP. If you want to isolate the guest time from the host,
you can set clock to &quot;rt&quot; instead. To even prevent
it <br>
from progressing during suspension, you can set it to
&quot;vm&quot;.</p>

<p style="margin-top: 1em">Enable driftfix (i386 targets
only) if you experience time drift problems, specifically
with Windows&rsquo; ACPI HAL. This option will try to figure
out how many timer interrupts <br>
were not processed by the Windows guest and will re-inject
them.</p>

<p style="margin-top: 1em">-icount
[shift=N|auto][,rr=record|replay,rrfile=filename,rrsnapshot=snapshot]
<br>
Enable virtual instruction counter. The virtual cpu will
execute one instruction every 2^N ns of virtual time. If
&quot;auto&quot; is specified then the virtual cpu speed
will be <br>
automatically adjusted to keep virtual time within a few
seconds of real time.</p>

<p style="margin-top: 1em">When the virtual cpu is
sleeping, the virtual time will advance at default speed
unless sleep=on|off is specified. With sleep=on|off, the
virtual time will jump to the next <br>
timer deadline instantly whenever the virtual cpu goes to
sleep mode and will not advance if no timer is enabled. This
behavior give deterministic execution times from the <br>
guest point of view.</p>

<p style="margin-top: 1em">Note that while this option can
give deterministic behavior, it does not provide cycle
accurate emulation. Modern CPUs contain superscalar out of
order cores with complex <br>
cache hierarchies. The number of instructions executed often
has little or no correlation with actual performance.</p>

<p style="margin-top: 1em">align=on will activate the delay
algorithm which will try to synchronise the host clock and
the virtual clock. The goal is to have a guest running at
the real frequency <br>
imposed by the shift option. Whenever the guest clock is
behind the host clock and if align=on is specified then we
print a message to the user to inform about the delay. <br>
Currently this option does not work when shift is
&quot;auto&quot;. Note: The sync algorithm will work for
those shift values for which the guest clock runs ahead of
the host clock. <br>
Typically this happens when the shift value is high (how
high depends on the host machine).</p>

<p style="margin-top: 1em">When rr option is specified
deterministic record/replay is enabled. Replay log is
written into filename file in record mode and read from this
file in replay mode.</p>

<p style="margin-top: 1em">Option rrsnapshot is used to
create new vm snapshot named snapshot at the start of
execution recording. In replay mode this option is used to
load the initial VM state.</p>

<p style="margin-top: 1em">-watchdog model <br>
Create a virtual hardware watchdog device. Once enabled (by
a guest action), the watchdog must be periodically polled by
an agent inside the guest or else the guest will be <br>
restarted. Choose a model for which your guest has
drivers.</p>

<p style="margin-top: 1em">The model is the model of
hardware watchdog to emulate. Use &quot;-watchdog help&quot;
to list available hardware models. Only one watchdog can be
enabled for a guest.</p>

<p style="margin-top: 1em">The following models may be
available:</p>

<p style="margin-top: 1em">ib700 <br>
iBASE 700 is a very simple ISA watchdog with a single
timer.</p>

<p style="margin-top: 1em">i6300esb <br>
Intel 6300ESB I/O controller hub is a much more featureful
PCI-based dual-timer watchdog.</p>

<p style="margin-top: 1em">diag288 <br>
A virtual watchdog for s390x backed by the diagnose 288
hypercall (currently KVM only).</p>

<p style="margin-top: 1em">-watchdog-action action <br>
The action controls what QEMU will do when the watchdog
timer expires. The default is &quot;reset&quot; (forcefully
reset the guest). Other possible actions are:
&quot;shutdown&quot; (attempt <br>
to gracefully shutdown the guest), &quot;poweroff&quot;
(forcefully poweroff the guest), &quot;pause&quot; (pause
the guest), &quot;debug&quot; (print a debug message and
continue), or &quot;none&quot; (do <br>
nothing).</p>

<p style="margin-top: 1em">Note that the
&quot;shutdown&quot; action requires that the guest responds
to ACPI signals, which it may not be able to do in the sort
of situations where the watchdog would have <br>
expired, and thus &quot;-watchdog-action shutdown&quot; is
not recommended for production use.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">&quot;-watchdog i6300esb
-watchdog-action pause&quot; <br>
&quot;-watchdog ib700&quot; <br>
-echr numeric_ascii_value <br>
Change the escape character used for switching to the
monitor when using monitor and serial sharing. The default
is 0x01 when using the &quot;-nographic&quot; option. 0x01
is equal <br>
to pressing &quot;Control-a&quot;. You can select a
different character from the ascii control keys where 1
through 26 map to Control-a through Control-z. For instance
you could use <br>
the either of the following to change the escape character
to Control-t.</p>

<p style="margin-top: 1em">&quot;-echr 0x14&quot; <br>
&quot;-echr 20&quot; <br>
-virtioconsole c <br>
Set virtio console.</p>

<p style="margin-top: 1em">This option is maintained for
backward compatibility.</p>

<p style="margin-top: 1em">Please use &quot;-device
virtconsole&quot; for the new way of invocation.</p>

<p style="margin-top: 1em">-show-cursor <br>
Show cursor.</p>

<p style="margin-top: 1em">-tb-size n <br>
Set TB size.</p>

<p style="margin-top: 1em">-incoming
tcp:[host]:port[,to=maxport][,ipv4][,ipv6] <br>
-incoming rdma:host:port[,ipv4][,ipv6] <br>
Prepare for incoming migration, listen on a given tcp
port.</p>

<p style="margin-top: 1em">-incoming unix:socketpath <br>
Prepare for incoming migration, listen on a given unix
socket.</p>

<p style="margin-top: 1em">-incoming fd:fd <br>
Accept incoming migration from a given filedescriptor.</p>

<p style="margin-top: 1em">-incoming exec:cmdline <br>
Accept incoming migration as an output from specified
external command.</p>

<p style="margin-top: 1em">-incoming defer <br>
Wait for the URI to be specified via migrate_incoming. The
monitor can be used to change settings (such as migration
parameters) prior to issuing the migrate_incoming to <br>
allow the migration to begin.</p>

<p style="margin-top: 1em">-only-migratable <br>
Only allow migratable devices. Devices will not be allowed
to enter an unmigratable state.</p>

<p style="margin-top: 1em">-nodefaults <br>
Don&rsquo;t create default devices. Normally, QEMU sets the
default devices like serial port, parallel port, virtual
console, monitor device, VGA adapter, floppy and CD-ROM
drive <br>
and others. The &quot;-nodefaults&quot; option will disable
all those default devices.</p>

<p style="margin-top: 1em">-chroot dir <br>
Immediately before starting guest execution, chroot to the
specified directory. Especially useful in combination with
-runas.</p>

<p style="margin-top: 1em">-runas user <br>
Immediately before starting guest execution, drop root
privileges, switching to the specified user.</p>

<p style="margin-top: 1em">-prom-env variable=value <br>
Set OpenBIOS nvram variable to given value (PPC, SPARC
only).</p>

<p style="margin-top: 1em">-semihosting <br>
Enable semihosting mode (ARM, M68K, Xtensa, MIPS only).</p>

<p style="margin-top: 1em">-semihosting-config
[enable=on|off][,target=native|gdb|auto][,arg=str[,...]]
<br>
Enable and configure semihosting (ARM, M68K, Xtensa, MIPS
only).</p>


<p style="margin-top: 1em">target=&quot;native|gdb|auto&quot;
<br>
Defines where the semihosting calls will be addressed, to
QEMU (&quot;native&quot;) or to GDB (&quot;gdb&quot;). The
default is &quot;auto&quot;, which means &quot;gdb&quot;
during debug sessions and &quot;native&quot; <br>
otherwise.</p>

<p style="margin-top: 1em">arg=str1,arg=str2,... <br>
Allows the user to pass input arguments, and can be used
multiple times to build up a list. The old-style
&quot;-kernel&quot;/&quot;-append&quot; method of passing a
command line is still <br>
supported for backward compatibility. If both the
&quot;--semihosting-config arg&quot; and the
&quot;-kernel&quot;/&quot;-append&quot; are specified, the
former is passed to semihosting as it always <br>
takes precedence.</p>

<p style="margin-top: 1em">-old-param <br>
Old param mode (ARM only).</p>

<p style="margin-top: 1em">-sandbox arg <br>
Enable Seccomp mode 2 system call filter. &rsquo;on&rsquo;
will enable syscall filtering and &rsquo;off&rsquo; will
disable it. The default is &rsquo;off&rsquo;.</p>

<p style="margin-top: 1em">-readconfig file <br>
Read device configuration from file. This approach is useful
when you want to spawn QEMU process with many command line
options but you don&rsquo;t want to exceed the command line
<br>
character limit.</p>

<p style="margin-top: 1em">-writeconfig file <br>
Write device configuration to file. The file can be either
filename to save command line and device configuration into
file or dash &quot;-&quot;) character to print the output to
<br>
stdout. This can be later used as input file for
&quot;-readconfig&quot; option.</p>

<p style="margin-top: 1em">-nodefconfig <br>
Normally QEMU loads configuration files from sysconfdir and
datadir at startup. The &quot;-nodefconfig&quot; option will
prevent QEMU from loading any of those config files.</p>

<p style="margin-top: 1em">-no-user-config <br>
The &quot;-no-user-config&quot; option makes QEMU not load
any of the user-provided config files on sysconfdir, but
won&rsquo;t make it skip the QEMU-provided config files from
datadir.</p>

<p style="margin-top: 1em">-trace
[[enable=]pattern][,events=file][,file=file] <br>
Specify tracing options.</p>

<p style="margin-top: 1em">[enable=]pattern <br>
Immediately enable events matching pattern. The file must
contain one event name (as listed in the trace-events-all
file) per line; globbing patterns are accepted too. <br>
This option is only available if QEMU has been compiled with
the simple, log or ftrace tracing backend. To specify
multiple events or patterns, specify the -trace option <br>
multiple times.</p>

<p style="margin-top: 1em">Use &quot;-trace help&quot; to
print a list of names of trace points.</p>

<p style="margin-top: 1em">events=file <br>
Immediately enable events listed in file. The file must
contain one event name (as listed in the trace-events-all
file) per line; globbing patterns are accepted too. <br>
This option is only available if QEMU has been compiled with
the simple, log or ftrace tracing backend.</p>

<p style="margin-top: 1em">file=file <br>
Log output traces to file. This option is only available if
QEMU has been compiled with the simple tracing backend.</p>

<p style="margin-top: 1em">-enable-fips <br>
Enable FIPS 140-2 compliance mode.</p>

<p style="margin-top: 1em">-msg timestamp[=on|off] <br>
prepend a timestamp to each log message.(default:on)</p>

<p style="margin-top: 1em">-dump-vmstate file <br>
Dump json-encoded vmstate information for current machine
type to file in file</p>

<p style="margin-top: 1em">Generic object creation</p>

<p style="margin-top: 1em">-object
typename[,prop1=value1,...] <br>
Create a new object of type typename setting properties in
the order they are specified. Note that the &rsquo;id&rsquo;
property must be set. These objects are placed in the
&rsquo;/objects&rsquo; <br>
path.</p>

<p style="margin-top: 1em">-object
memory-backend-file,id=id,size=size,mem-path=dir,share=on|off
<br>
Creates a memory file backend object, which can be used to
back the guest RAM with huge pages. The id parameter is a
unique ID that will be used to reference this memory <br>
region when configuring the -numa argument. The size option
provides the size of the memory region, and accepts common
suffixes, eg 500M. The mem-path provides the path <br>
to either a shared memory or huge page filesystem mount. The
share boolean option determines whether the memory region is
marked as private to QEMU, or shared. The <br>
latter allows a co-operating external process to access the
QEMU memory region.</p>

<p style="margin-top: 1em">-object
rng-random,id=id,filename=/dev/random <br>
Creates a random number generator backend which obtains
entropy from a device on the host. The id parameter is a
unique ID that will be used to reference this entropy <br>
backend from the virtio-rng device. The filename parameter
specifies which file to obtain entropy from and if omitted
defaults to /dev/random.</p>

<p style="margin-top: 1em">-object
rng-egd,id=id,chardev=chardevid <br>
Creates a random number generator backend which obtains
entropy from an external daemon running on the host. The id
parameter is a unique ID that will be used to <br>
reference this entropy backend from the virtio-rng device.
The chardev parameter is the unique ID of a character device
backend that provides the connection to the RNG <br>
daemon.</p>

<p style="margin-top: 1em">-object
tls-creds-anon,id=id,endpoint=endpoint,dir=/path/to/cred/dir,verify-peer=on|off
<br>
Creates a TLS anonymous credentials object, which can be
used to provide TLS support on network backends. The id
parameter is a unique ID which network backends will use
<br>
to access the credentials. The endpoint is either server or
client depending on whether the QEMU network backend that
uses the credentials will be acting as a client or <br>
as a server. If verify-peer is enabled (the default) then
once the handshake is completed, the peer credentials will
be verified, though this is a no-op for anonymous <br>
credentials.</p>

<p style="margin-top: 1em">The dir parameter tells QEMU
where to find the credential files. For server endpoints,
this directory may contain a file dh-params.pem providing
diffie-hellman parameters <br>
to use for the TLS server. If the file is missing, QEMU will
generate a set of DH parameters at startup. This is a
computationally expensive operation that consumes <br>
random pool entropy, so it is recommended that a persistent
set of parameters be generated upfront and saved.</p>

<p style="margin-top: 1em">-object
tls-creds-x509,id=id,endpoint=endpoint,dir=/path/to/cred/dir,verify-peer=on|off,passwordid=id
<br>
Creates a TLS anonymous credentials object, which can be
used to provide TLS support on network backends. The id
parameter is a unique ID which network backends will use
<br>
to access the credentials. The endpoint is either server or
client depending on whether the QEMU network backend that
uses the credentials will be acting as a client or <br>
as a server. If verify-peer is enabled (the default) then
once the handshake is completed, the peer credentials will
be verified. With x509 certificates, this implies <br>
that the clients must be provided with valid client
certificates too.</p>

<p style="margin-top: 1em">The dir parameter tells QEMU
where to find the credential files. For server endpoints,
this directory may contain a file dh-params.pem providing
diffie-hellman parameters <br>
to use for the TLS server. If the file is missing, QEMU will
generate a set of DH parameters at startup. This is a
computationally expensive operation that consumes <br>
random pool entropy, so it is recommended that a persistent
set of parameters be generated upfront and saved.</p>

<p style="margin-top: 1em">For x509 certificate credentials
the directory will contain further files providing the x509
certificates. The certificates must be stored in PEM format,
in filenames <br>
ca-cert.pem, ca-crl.pem (optional), server-cert.pem (only
servers), server-key.pem (only servers), client-cert.pem
(only clients), and client-key.pem (only clients).</p>

<p style="margin-top: 1em">For the server-key.pem and
client-key.pem files which contain sensitive private keys,
it is possible to use an encrypted version by providing the
passwordid parameter. <br>
This provides the ID of a previously created
&quot;secret&quot; object containing the password for
decryption.</p>

<p style="margin-top: 1em">-object
filter-buffer,id=id,netdev=netdevid,interval=t[,queue=all|rx|tx][,status=on|off]
<br>
Interval t can&rsquo;t be 0, this filter batches the packet
delivery: all packets arriving in a given interval on netdev
netdevid are delayed until the end of the interval. <br>
Interval is in microseconds. status is optional that
indicate whether the netfilter is on (enabled) or off
(disabled), the default status for netfilter will be
&rsquo;on&rsquo;.</p>

<p style="margin-top: 1em">queue all|rx|tx is an option
that can be applied to any netfilter.</p>

<p style="margin-top: 1em">all: the filter is attached both
to the receive and the transmit queue of the netdev
(default).</p>

<p style="margin-top: 1em">rx: the filter is attached to
the receive queue of the netdev, where it will receive
packets sent to the netdev.</p>

<p style="margin-top: 1em">tx: the filter is attached to
the transmit queue of the netdev, where it will receive
packets sent by the netdev.</p>

<p style="margin-top: 1em">-object
filter-mirror,id=id,netdev=netdevid,outdev=chardevid[,queue=all|rx|tx]
<br>
filter-mirror on netdev netdevid,mirror net packet to
chardev chardevid</p>

<p style="margin-top: 1em">-object
filter-redirector,id=id,netdev=netdevid,indev=chardevid,
<br>
outdev=chardevid[,queue=all|rx|tx]</p>

<p style="margin-top: 1em">filter-redirector on netdev
netdevid,redirect filter&rsquo;s net packet to chardev
chardevid,and redirect indev&rsquo;s packet to filter.
Create a filter-redirector we need to <br>
differ outdev id from indev id, id can not be the same. we
can just use indev or outdev, but at least one of indev or
outdev need to be specified.</p>

<p style="margin-top: 1em">-object
filter-rewriter,id=id,netdev=netdevid,rewriter-mode=mode[,queue=all|rx|tx]
<br>
Filter-rewriter is a part of COLO project.It will rewrite
tcp packet to secondary from primary to keep secondary tcp
connection,and rewrite tcp packet to primary from <br>
secondary make tcp packet can be handled by client.</p>

<p style="margin-top: 1em">usage: colo secondary: -object
filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
-object
filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1
-object <br>
filter-rewriter,id=rew0,netdev=hn0,queue=all</p>

<p style="margin-top: 1em">-object
filter-dump,id=id,netdev=dev[,file=filename][,maxlen=len]
<br>
Dump the network traffic on netdev dev to the file specified
by filename. At most len bytes (64k by default) per packet
are stored. The file format is libpcap, so it can <br>
be analyzed with tools such as tcpdump or Wireshark.</p>

<p style="margin-top: 1em">-object
colo-compare,id=id,primary_in=chardevid,secondary_in=chardevid,
<br>
outdev=chardevid</p>

<p style="margin-top: 1em">Colo-compare gets packet from
primary_inchardevid and secondary_inchardevid, than compare
primary packet with secondary packet. If the packets are
same, we will output <br>
primary packet to outdevchardevid, else we will notify
colo-frame do checkpoint and send primary packet to
outdevchardevid.</p>

<p style="margin-top: 1em">we must use it with the help of
filter-mirror and filter-redirector.</p>

<p style="margin-top: 1em">primary: <br>
-netdev
tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown
<br>
-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66 <br>
-chardev
socket,id=mirror0,host=3.3.3.3,port=9003,server,nowait <br>
-chardev
socket,id=compare1,host=3.3.3.3,port=9004,server,nowait <br>
-chardev
socket,id=compare0,host=3.3.3.3,port=9001,server,nowait <br>
-chardev socket,id=compare0-0,host=3.3.3.3,port=9001 <br>
-chardev
socket,id=compare_out,host=3.3.3.3,port=9005,server,nowait
<br>
-chardev socket,id=compare_out0,host=3.3.3.3,port=9005 <br>
-object
filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0 <br>
-object
filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
<br>
-object
filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
<br>
-object
colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0</p>

<p style="margin-top: 1em">secondary: <br>
-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down
script=/etc/qemu-ifdown <br>
-device e1000,netdev=hn0,mac=52:a4:00:12:78:66 <br>
-chardev socket,id=red0,host=3.3.3.3,port=9003 <br>
-chardev socket,id=red1,host=3.3.3.3,port=9004 <br>
-object
filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0 <br>
-object
filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1</p>

<p style="margin-top: 1em">If you want to know the detail
of above command line, you can read the colo-compare git
log.</p>

<p style="margin-top: 1em">-object
cryptodev-backend-builtin,id=id[,queues=queues] <br>
Creates a cryptodev backend which executes crypto opreation
from the QEMU cipher APIS. The id parameter is a unique ID
that will be used to reference this cryptodev <br>
backend from the virtio-crypto device. The queues parameter
is optional, which specify the queue number of cryptodev
backend, the default of queues is 1.</p>

<p style="margin-top: 1em"># qemu-system-x86_64 [...]
-object cryptodev-backend-builtin,id=cryptodev0 -device
virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 [...]</p>

<p style="margin-top: 1em">-object
secret,id=id,data=string,format=raw|base64[,keyid=secretid,iv=string]
<br>
-object
secret,id=id,file=filename,format=raw|base64[,keyid=secretid,iv=string]
<br>
Defines a secret to store a password, encryption key, or
some other sensitive data. The sensitive data can either be
passed directly via the data parameter, or indirectly <br>
via the file parameter. Using the data parameter is insecure
unless the sensitive data is encrypted.</p>

<p style="margin-top: 1em">The sensitive data can be
provided in raw format (the default), or base64. When
encoded as JSON, the raw format only supports valid UTF-8
characters, so base64 is <br>
recommended for sending binary data. QEMU will convert from
which ever format is provided to the format it needs
internally. eg, an RBD password can be provided in raw <br>
format, even though it will be base64 encoded when passed
onto the RBD sever.</p>

<p style="margin-top: 1em">For added protection, it is
possible to encrypt the data associated with a secret using
the AES-256-CBC cipher. Use of encryption is indicated by
providing the keyid and <br>
iv parameters. The keyid parameter provides the ID of a
previously defined secret that contains the AES-256
decryption key. This key should be 32-bytes long and be
base64 <br>
encoded. The iv parameter provides the random initialization
vector used for encryption of this particular secret and
should be a base64 encrypted string of the 16-byte <br>
IV.</p>

<p style="margin-top: 1em">The simplest (insecure) usage is
to provide the secret inline</p>

<p style="margin-top: 1em"># $QEMU -object
secret,id=sec0,data=letmein,format=raw</p>

<p style="margin-top: 1em">The simplest secure usage is to
provide the secret via a file</p>

<p style="margin-top: 1em"># echo -n &quot;letmein&quot;
&gt; mypasswd.txt # $QEMU -object
secret,id=sec0,file=mypasswd.txt,format=raw</p>

<p style="margin-top: 1em">For greater security,
AES-256-CBC should be used. To illustrate usage, consider
the openssl command line tool which can encrypt the data.
Note that when encrypting, the <br>
plaintext must be padded to the cipher block size (32 bytes)
using the standard PKCS#5/6 compatible padding
algorithm.</p>

<p style="margin-top: 1em">First a master key needs to be
created in base64 encoding:</p>

<p style="margin-top: 1em"># openssl rand -base64 32 &gt;
key.b64 <br>
# KEY=$(base64 -d key.b64 | hexdump -v -e &rsquo;/1
&quot;%02X&quot;&rsquo;)</p>

<p style="margin-top: 1em">Each secret to be encrypted
needs to have a random initialization vector generated.
These do not need to be kept secret</p>

<p style="margin-top: 1em"># openssl rand -base64 16 &gt;
iv.b64 <br>
# IV=$(base64 -d iv.b64 | hexdump -v -e &rsquo;/1
&quot;%02X&quot;&rsquo;)</p>

<p style="margin-top: 1em">The secret to be defined can now
be encrypted, in this case we&rsquo;re telling openssl to
base64 encode the result, but it could be left as raw bytes
if desired.</p>

<p style="margin-top: 1em"># SECRET=$(echo -n
&quot;letmein&quot; | <br>
openssl enc -aes-256-cbc -a -K $KEY -iv $IV)</p>

<p style="margin-top: 1em">When launching QEMU, create a
master secret pointing to &quot;key.b64&quot; and specify
that to be used to decrypt the user password. Pass the
contents of &quot;iv.b64&quot; to the second <br>
secret</p>

<p style="margin-top: 1em"># $QEMU -object
secret,id=secmaster0,format=base64,file=key.b64 -object
secret,id=sec0,keyid=secmaster0,format=base64,
data=$SECRET,iv=$(&lt;iv.b64)</p>

<p style="margin-top: 1em">During the graphical emulation,
you can use special key combinations to change modes. The
default key mappings are shown below, but if you use
&quot;-alt-grab&quot; then the modifier is <br>
Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you use
&quot;-ctrl-grab&quot; then the modifier is the right Ctrl
key (instead of Ctrl-Alt):</p>

<p style="margin-top: 1em">Ctrl-Alt-f <br>
Toggle full screen</p>

<p style="margin-top: 1em">Ctrl-Alt-+ <br>
Enlarge the screen</p>

<p style="margin-top: 1em">Ctrl-Alt-- <br>
Shrink the screen</p>

<p style="margin-top: 1em">Ctrl-Alt-u <br>
Restore the screen&rsquo;s un-scaled dimensions</p>

<p style="margin-top: 1em">Ctrl-Alt-n <br>
Switch to virtual console &rsquo;n&rsquo;. Standard console
mappings are:</p>

<p style="margin-top: 1em">1 Target system display</p>

<p style="margin-top: 1em">2 Monitor</p>

<p style="margin-top: 1em">3 Serial port</p>

<p style="margin-top: 1em">Ctrl-Alt <br>
Toggle mouse and keyboard grab.</p>

<p style="margin-top: 1em">In the virtual consoles, you can
use Ctrl-Up, Ctrl-Down, Ctrl-PageUp and Ctrl-PageDown to
move in the back log.</p>

<p style="margin-top: 1em">During emulation, if you are
using a character backend multiplexer (which is the default
if you are using -nographic) then several commands are
available via an escape sequence. <br>
These key sequences all start with an escape character,
which is Ctrl-a by default, but can be changed with -echr.
The list below assumes you&rsquo;re using the default.</p>

<p style="margin-top: 1em">Ctrl-a h <br>
Print this help</p>

<p style="margin-top: 1em">Ctrl-a x <br>
Exit emulator</p>

<p style="margin-top: 1em">Ctrl-a s <br>
Save disk data back to file (if -snapshot)</p>

<p style="margin-top: 1em">Ctrl-a t <br>
Toggle console timestamps</p>

<p style="margin-top: 1em">Ctrl-a b <br>
Send break (magic sysrq in Linux)</p>

<p style="margin-top: 1em">Ctrl-a c <br>
Rotate between the frontends connected to the multiplexer
(usually this switches between the monitor and the
console)</p>

<p style="margin-top: 1em">Ctrl-a Ctrl-a <br>
Send the escape character to the frontend</p>

<p style="margin-top: 1em">The following options are
specific to the PowerPC emulation:</p>

<p style="margin-top: 1em">-g WxH[xDEPTH] <br>
Set the initial VGA graphic mode. The default is
800x600x32.</p>

<p style="margin-top: 1em">-prom-env string <br>
Set OpenBIOS variables in NVRAM, for example:</p>

<p style="margin-top: 1em">qemu-system-ppc -prom-env
&rsquo;auto-boot?=false&rsquo; -prom-env
&rsquo;boot-device=hd:2,yaboot&rsquo; -prom-env
&rsquo;boot-args=conf=hd:2,yaboot.conf&rsquo;</p>

<p style="margin-top: 1em">These variables are not used by
Open Hack&rsquo;Ware.</p>

<p style="margin-top: 1em">The following options are
specific to the Sparc32 emulation:</p>

<p style="margin-top: 1em">-g WxHx[xDEPTH] <br>
Set the initial graphics mode. For TCX, the default is
1024x768x8 with the option of 1024x768x24. For cgthree, the
default is 1024x768x8 with the option of 1152x900x8 for <br>
people who wish to use OBP.</p>

<p style="margin-top: 1em">-prom-env string <br>
Set OpenBIOS variables in NVRAM, for example:</p>

<p style="margin-top: 1em">qemu-system-sparc -prom-env
&rsquo;auto-boot?=false&rsquo; -prom-env
&rsquo;boot-device=sd(0,2,0):d&rsquo; -prom-env
&rsquo;boot-args=linux single&rsquo;</p>

<p style="margin-top: 1em">-M
[SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic]
[|SPARCbook] <br>
Set the emulated machine type. Default is SS-5.</p>

<p style="margin-top: 1em">The following options are
specific to the Sparc64 emulation:</p>

<p style="margin-top: 1em">-prom-env string <br>
Set OpenBIOS variables in NVRAM, for example:</p>

<p style="margin-top: 1em">qemu-system-sparc64 -prom-env
&rsquo;auto-boot?=false&rsquo;</p>

<p style="margin-top: 1em">-M [sun4u|sun4v|niagara] <br>
Set the emulated machine type. The default is sun4u.</p>

<p style="margin-top: 1em">SEE ALSO <br>
The HTML documentation of QEMU for more precise information
and Linux user mode emulator invocation.</p>

<p style="margin-top: 1em">AUTHOR <br>
Fabrice Bellard</p>

<p style="margin-top: 1em">2017-08-16 QEMU.1(1)</p>
<hr>
</body>
</html>
