<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>GMTMATH(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GMTMATH(1)</td>
    <td class="head-vol">GMT</td>
    <td class="head-rtitle">GMTMATH(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
gmtmath - Reverse Polish Notation (RPN) calculator for data tables
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>gmtmath</b> [ <b>-A</b><i>t_f(t).d</i>[<b>+e</b>][<b>+s</b>|<b>w</b>] ] [
  <b>-C</b> <i>cols</i> ] [ <b>-E</b><i>eigen</i> ] [ <b>-I</b> ] [
  <b>-N</b><i>n_col</i>[/ <i>t_col</i>] ] [ <b>-Q</b> ] [
  <b>-S</b>[<b>f</b>|<b>l</b>] ] [
  <b>-T</b><i>t_min</i>/<i>t_max</i>/<i>t_inc</i>[ <b>+n</b>]|<i>tfile</i> ] [
  <b>-V</b>[<i>level</i>] ] [ <b>-b</b>binary ] [ <b>-d</b>nodata ] [
  <b>-e</b>regexp ] [ <b>-f</b>flags ] [ <b>-g</b>gaps ] [ <b>-h</b>headers ] [
  <b>-i</b>flags ] [ <b>-o</b>flags ] [ <b>-s</b>flags ] <i>operand</i> [
  <i>operand</i> ] <b>OPERATOR</b> [ <i>operand</i> ] <b>OPERATOR</b> &#x2026;
  <b>=</b> [ <i>outfile</i> ]
<div style="height: 1.00em;">&#x00A0;</div>
<b>Note:</b> No space is allowed between the option flag and the associated
  arguments.
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>gmtmath</b> will perform operations like add, subtract, multiply, and divide
  on one or more table data files or constants using Reverse Polish Notation
  (RPN) syntax (e.g., Hewlett-Packard calculator-style). Arbitrarily complicated
  expressions may therefore be evaluated; the final result is written to an
  output file [or standard output]. Data operations are element-by-element, not
  matrix manipulations (except where noted). Some operators only require one
  operand (see below). If no data tables are used in the expression then options
  <b>-T</b>, <b>-N</b> can be set (and optionally <b>-bo</b> to indicate the
  data type for binary tables). If STDIN is given, the standard input will be
  read and placed on the stack as if a file with that content had been given on
  the command line. By default, all columns except the &#x201C;time&#x201D;
  column are operated on, but this can be changed (see <b>-C</b>). Complicated
  or frequently occurring expressions may be coded as a macro for future use or
  stored and recalled via named memory locations.
<h1 class="Sh" title="Sh" id="REQUIRED_ARGUMENTS"><a class="selflink" href="#REQUIRED_ARGUMENTS">REQUIRED
  ARGUMENTS</a></h1>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b><i>operand</i></b></dt>
  <dd class="It-tag">If <i>operand</i> can be opened as a file it will be read
      as an ASCII (or binary, see <b>-bi</b>) table data file. If not a file, it
      is interpreted as a numerical constant or a special symbol (see below).
      The special argument STDIN means that <i>stdin</i> will be read and placed
      on the stack; STDIN can appear more than once if necessary.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b><i>outfile</i></b></dt>
  <dd class="It-tag">The name of a table data file that will hold the final
      result. If not given then the output is sent to stdout.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="OPTIONAL_ARGUMENTS"><a class="selflink" href="#OPTIONAL_ARGUMENTS">OPTIONAL
  ARGUMENTS</a></h1>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-A</b><i>t_f(t).d</i>[<b>+e</b>][<b>+r</b>][<b>+s</b>|<b>w</b>]</dt>
  <dd class="It-tag">Requires <b>-N</b> and will partially initialize a table
      with values from the given file containing <i>t</i> and <i>f(t)</i> only.
      The <i>t</i> is placed in column <i>t_col</i> while <i>f(t)</i> goes into
      column <i>n_col</i> - 1 (see <b>-N</b>). Append <b>+r</b> to only place
      <i>f(t)</i> and leave the left hand side of the matrix equation alone. If
      used with operators LSQFIT and SVDFIT you can optionally append the
      modifier <b>+e</b> which will instead evaluate the solution and write a
      data set with four columns: t, f(t), the model solution at t, and the the
      residuals at t, respectively [Default writes one column with model
      coefficients]. Append <b>+w</b> if <i>t_f(t).d</i> has a third column with
      weights, or append <b>+s</b> if <i>t_f(t).d</i> has a third column with
      1-sigma. In those two cases we find the weighted solution. The weights (or
      sigmas) will be output as the last column when <b>+e</b> is in
    effect.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-C</b><i>cols</i></dt>
  <dd class="It-tag">Select the columns that will be operated on until next
      occurrence of <b>-C</b>. List columns separated by commas; ranges like
      1,3-5,7 are allowed. <b>-C</b> (no arguments) resets the default action of
      using all columns except time column (see <b>-N</b>). <b>-Ca</b> selects
      all columns, including time column, while <b>-Cr</b> reverses (toggles)
      the current choices. When <b>-C</b> is in effect it also controls which
      columns from a file will be placed on the stack.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-E</b><i>eigen</i></dt>
  <dd class="It-tag">Sets the minimum eigenvalue used by operators LSQFIT and
      SVDFIT [1e-7]. Smaller eigenvalues are set to zero and will not be
      considered in the solution.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-I</b></dt>
  <dd class="It-tag">Reverses the output row sequence from ascending time to
      descending [ascending].</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-N</b><i>n_col</i>[/<i>t_col</i>]</dt>
  <dd class="It-tag">Select the number of columns and optionally the column
      number that contains the &#x201C;time&#x201D; variable [0]. Columns are
      numbered starting at 0 [2/0]. If input files are specified then <b>-N</b>
      will add any missing columns.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-Q</b></dt>
  <dd class="It-tag">Quick mode for scalar calculation. Shorthand for <b>-Ca</b>
      <b>-N</b>1/0 <b>-T</b>0/0/1. In this mode, constants may have plot units
      (i.e., c, i, p) and if so the final answer will be reported in the unit
      set by PROJ_LENGTH_UNIT.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-S</b>[<b>f</b>|<b>l</b>]</dt>
  <dd class="It-tag">Only report the first or last row of the results [Default
      is all rows]. This is useful if you have computed a statistic (say the
      <b>MODE</b>) and only want to report a single number instead of numerous
      records with identical values. Append <b>l</b> to get the last row and
      <b>f</b> to get the first row only [Default].</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-T</b><i>t_min</i>/<i>t_max</i>/<i>t_inc</i>[<b>+n</b>]|<i>tfile</i></dt>
  <dd class="It-tag">Required when no input files are given. Sets the
      t-coordinates of the first and last point and the equidistant sampling
      interval for the &#x201C;time&#x201D; column (see <b>-N</b>). Append
      <b>+n</b> if you are specifying the number of equidistant points instead.
      If there is no time column (only data columns), give <b>-T</b> with no
      arguments; this also implies <b>-Ca</b>. Alternatively, give the name of a
      file whose first column contains the desired t-coordinates which may be
      irregular.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-V</b>[<i>level</i>] (more &#x2026;)</dt>
  <dd class="It-tag">Select verbosity level [c].</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bi</b>[<i>ncols</i>][<b>t</b>] (more &#x2026;)</dt>
  <dd class="It-tag">Select native binary input.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-bo</b>[<i>ncols</i>][<i>type</i>] (more &#x2026;)</dt>
  <dd class="It-tag">Select native binary output. [Default is same as input, but
      see <b>-o</b>]</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-d</b>[<b>i</b>|<b>o</b>]<i>nodata</i> (more
    &#x2026;)</dt>
  <dd class="It-tag">Replace input columns that equal <i>nodata</i> with NaN and
      do the reverse on output.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-e</b>[<b>~</b>]<i>&#x201D;pattern&#x201D;</i> <b>|</b>
    <b>-e</b>[<b>~</b>]/<i>regexp</i>/[<b>i</b>] (more &#x2026;)</dt>
  <dd class="It-tag">Only accept data records that match the given pattern.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-f</b>[<b>i</b>|<b>o</b>]<i>colinfo</i> (more
    &#x2026;)</dt>
  <dd class="It-tag">Specify data types of input and/or output columns.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-g</b>[<b>a</b>]<b>x</b>|<b>y</b>|<b>d</b>|<b>X</b>|<b>Y</b>|<b>D</b>|[<i>col</i>]<b>z</b>[+|-]<i>gap</i>[<b>u</b>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Determine data gaps and line breaks.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-h</b>[<b>i</b>|<b>o</b>][<i>n</i>][<b>+c</b>][<b>+d</b>][<b>+r</b><i>remark</i>][<b>+r</b><i>title</i>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Skip or produce header record(s).</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-i</b><i>cols</i>[<b>+l</b>][<b>+s</b><i>scale</i>][<b>+o</b><i>offset</i>][,<i>&#x2026;</i>]
    (more &#x2026;)</dt>
  <dd class="It-tag">Select input columns and transformations (0 is first
      column).</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-o</b><i>cols</i>[,&#x2026;] (more &#x2026;)</dt>
  <dd class="It-tag">Select output columns (0 is first column).</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-s</b>[<i>cols</i>][<b>a</b>|<b>r</b>] (more
    &#x2026;)</dt>
  <dd class="It-tag">Set handling of NaN records.</dd>
</dl>
</div>
<br/>
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag"><b>-^</b> or just <b>-</b></dt>
  <dd class="It-tag">Print a short message about the syntax of the command, then
      exits (NOTE: on Windows just use <b>-</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-+</b> or just <b>+</b></dt>
  <dd class="It-tag">Print an extensive usage (help) message, including the
      explanation of any module-specific option (but not the GMT common
      options), then exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag"><b>-?</b> or no arguments</dt>
  <dd class="It-tag">Print a complete usage (help) message, including the
      explanation of all options, then exits.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="OPERATORS"><a class="selflink" href="#OPERATORS">OPERATORS</a></h1>
Choose among the following 185 operators. &#x201C;args&#x201D; are the number of
  input and output arguments.
<table class="tbl">
  <colgroup>
    <col style="width: 15.00ex;"/>
    <col style="width: 4.00ex;"/>
    <col style="width: 89.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>Operator</td>
    <td>args</td>
    <td>Returns</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ABS</b></td>
    <td>1 1</td>
    <td>abs (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACOS</b></td>
    <td>1 1</td>
    <td>acos (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACOSH</b></td>
    <td>1 1</td>
    <td>acosh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACSC</b></td>
    <td>1 1</td>
    <td>acsc (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ACOT</b></td>
    <td>1 1</td>
    <td>acot (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ADD</b></td>
    <td>2 1</td>
    <td>A + B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>AND</b></td>
    <td>2 1</td>
    <td>B if A == NaN, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ASEC</b></td>
    <td>1 1</td>
    <td>asec (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ASIN</b></td>
    <td>1 1</td>
    <td>asin (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ASINH</b></td>
    <td>1 1</td>
    <td>asinh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ATAN</b></td>
    <td>1 1</td>
    <td>atan (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ATAN2</b></td>
    <td>2 1</td>
    <td>atan2 (A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ATANH</b></td>
    <td>1 1</td>
    <td>atanh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BCDF</b></td>
    <td>3 1</td>
    <td>Binomial cumulative distribution function for p = A, n = B, and x =
      C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BPDF</b></td>
    <td>3 1</td>
    <td>Binomial probability density function for p = A, n = B, and x = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BEI</b></td>
    <td>1 1</td>
    <td>bei (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BER</b></td>
    <td>1 1</td>
    <td>ber (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITAND</b></td>
    <td>2 1</td>
    <td>A &amp; B (bitwise AND operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITLEFT</b></td>
    <td>2 1</td>
    <td>A &lt;&lt; B (bitwise left-shift operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITNOT</b></td>
    <td>1 1</td>
    <td>~A (bitwise NOT operator, i.e., return two&#x2019;s complement)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITOR</b></td>
    <td>2 1</td>
    <td>A | B (bitwise OR operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITRIGHT</b></td>
    <td>2 1</td>
    <td>A &gt;&gt; B (bitwise right-shift operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITTEST</b></td>
    <td>2 1</td>
    <td>1 if bit B of A is set, else 0 (bitwise TEST operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>BITXOR</b></td>
    <td>2 1</td>
    <td>A ^ B (bitwise XOR operator)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CEIL</b></td>
    <td>1 1</td>
    <td>ceil (A) (smallest integer &gt;= A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CHICRIT</b></td>
    <td>2 1</td>
    <td>Chi-squared distribution critical value for alpha = A and nu = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CHICDF</b></td>
    <td>2 1</td>
    <td>Chi-squared cumulative distribution function for chi2 = A and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CHIPDF</b></td>
    <td>2 1</td>
    <td>Chi-squared probability density function for chi2 = A and nu = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COL</b></td>
    <td>1 1</td>
    <td>Places column A on the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COMB</b></td>
    <td>2 1</td>
    <td>Combinations n_C_r, with n = A and r = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CORRCOEFF</b></td>
    <td>2 1</td>
    <td>Correlation coefficient r(A, B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COS</b></td>
    <td>1 1</td>
    <td>cos (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COSD</b></td>
    <td>1 1</td>
    <td>cos (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COSH</b></td>
    <td>1 1</td>
    <td>cosh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COT</b></td>
    <td>1 1</td>
    <td>cot (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>COTD</b></td>
    <td>1 1</td>
    <td>cot (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CSC</b></td>
    <td>1 1</td>
    <td>csc (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>CSCD</b></td>
    <td>1 1</td>
    <td>csc (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DDT</b></td>
    <td>1 1</td>
    <td>d(A)/dt Central 1st derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>D2DT2</b></td>
    <td>1 1</td>
    <td>d^2(A)/dt^2 2nd derivative</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>D2R</b></td>
    <td>1 1</td>
    <td>Converts Degrees to Radians</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DENAN</b></td>
    <td>2 1</td>
    <td>Replace NaNs in A with values from B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DILOG</b></td>
    <td>1 1</td>
    <td>dilog (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DIFF</b></td>
    <td>1 1</td>
    <td>Forward difference between adjacent elements of A (A[1]-A[0], A[2]-A[1],
      &#x2026;, NaN)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DIV</b></td>
    <td>2 1</td>
    <td>A / B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>DUP</b></td>
    <td>1 2</td>
    <td>Places duplicate of A on the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ECDF</b></td>
    <td>2 1</td>
    <td>Exponential cumulative distribution function for x = A and lambda =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ECRIT</b></td>
    <td>2 1</td>
    <td>Exponential distribution critical value for alpha = A and lambda =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EPDF</b></td>
    <td>2 1</td>
    <td>Exponential probability density function for x = A and lambda = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ERF</b></td>
    <td>1 1</td>
    <td>Error function erf (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ERFC</b></td>
    <td>1 1</td>
    <td>Complementary Error function erfc (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ERFINV</b></td>
    <td>1 1</td>
    <td>Inverse error function of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EQ</b></td>
    <td>2 1</td>
    <td>1 if A == B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EXCH</b></td>
    <td>2 2</td>
    <td>Exchanges A and B on the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EXP</b></td>
    <td>1 1</td>
    <td>exp (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FACT</b></td>
    <td>1 1</td>
    <td>A! (A factorial)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FCDF</b></td>
    <td>3 1</td>
    <td>F cumulative distribution function for F = A, nu1 = B, and nu2 = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FCRIT</b></td>
    <td>3 1</td>
    <td>F distribution critical value for alpha = A, nu1 = B, and nu2 = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FLIPUD</b></td>
    <td>1 1</td>
    <td>Reverse order of each column</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FLOOR</b></td>
    <td>1 1</td>
    <td>floor (A) (greatest integer &lt;= A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FMOD</b></td>
    <td>2 1</td>
    <td>A % B (remainder after truncated division)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>FPDF</b></td>
    <td>3 1</td>
    <td>F probability density function for F = A, nu1 = B, and nu2 = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>GE</b></td>
    <td>2 1</td>
    <td>1 if A &gt;= B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>GT</b></td>
    <td>2 1</td>
    <td>1 if A &gt; B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>HYPOT</b></td>
    <td>2 1</td>
    <td>hypot (A, B) = sqrt (A*A + B*B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>I0</b></td>
    <td>1 1</td>
    <td>Modified Bessel function of A (1st kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>I1</b></td>
    <td>1 1</td>
    <td>Modified Bessel function of A (1st kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>IFELSE</b></td>
    <td>3 1</td>
    <td>B if A != 0, else C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>IN</b></td>
    <td>2 1</td>
    <td>Modified Bessel function of A (1st kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>INRANGE</b></td>
    <td>3 1</td>
    <td>1 if B &lt;= A &lt;= C, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>INT</b></td>
    <td>1 1</td>
    <td>Numerically integrate A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>INV</b></td>
    <td>1 1</td>
    <td>1 / A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ISFINITE</b></td>
    <td>1 1</td>
    <td>1 if A is finite, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ISNAN</b></td>
    <td>1 1</td>
    <td>1 if A == NaN, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>J0</b></td>
    <td>1 1</td>
    <td>Bessel function of A (1st kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>J1</b></td>
    <td>1 1</td>
    <td>Bessel function of A (1st kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>JN</b></td>
    <td>2 1</td>
    <td>Bessel function of A (1st kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>K0</b></td>
    <td>1 1</td>
    <td>Modified Kelvin function of A (2nd kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>K1</b></td>
    <td>1 1</td>
    <td>Modified Bessel function of A (2nd kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KN</b></td>
    <td>2 1</td>
    <td>Modified Bessel function of A (2nd kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KEI</b></td>
    <td>1 1</td>
    <td>kei (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KER</b></td>
    <td>1 1</td>
    <td>ker (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>KURT</b></td>
    <td>1 1</td>
    <td>Kurtosis of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LCDF</b></td>
    <td>1 1</td>
    <td>Laplace cumulative distribution function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LCRIT</b></td>
    <td>1 1</td>
    <td>Laplace distribution critical value for alpha = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LE</b></td>
    <td>2 1</td>
    <td>1 if A &lt;= B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LMSSCL</b></td>
    <td>1 1</td>
    <td>LMS scale estimate (LMS STD) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LMSSCLW</b></td>
    <td>2 1</td>
    <td>Weighted LMS scale estimate (LMS STD) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG</b></td>
    <td>1 1</td>
    <td>log (A) (natural log)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG10</b></td>
    <td>1 1</td>
    <td>log10 (A) (base 10)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG1P</b></td>
    <td>1 1</td>
    <td>log (1+A) (accurate for small A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOG2</b></td>
    <td>1 1</td>
    <td>log2 (A) (base 2)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LOWER</b></td>
    <td>1 1</td>
    <td>The lowest (minimum) value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LPDF</b></td>
    <td>1 1</td>
    <td>Laplace probability density function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LRAND</b></td>
    <td>2 1</td>
    <td>Laplace random noise with mean A and std. deviation B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LSQFIT</b></td>
    <td>1 0</td>
    <td>Let current table be [A | b] return least squares solution x = A \
      b</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>LT</b></td>
    <td>2 1</td>
    <td>1 if A &lt; B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MAD</b></td>
    <td>1 1</td>
    <td>Median Absolute Deviation (L1 STD) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MADW</b></td>
    <td>2 1</td>
    <td>Weighted Median Absolute Deviation (L1 STD) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MAX</b></td>
    <td>2 1</td>
    <td>Maximum of A and B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEAN</b></td>
    <td>1 1</td>
    <td>Mean value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEANW</b></td>
    <td>2 1</td>
    <td>Weighted mean value of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEDIAN</b></td>
    <td>1 1</td>
    <td>Median value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MEDIANW</b></td>
    <td>2 1</td>
    <td>Weighted median value of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MIN</b></td>
    <td>2 1</td>
    <td>Minimum of A and B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MOD</b></td>
    <td>2 1</td>
    <td>A mod B (remainder after floored division)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MODE</b></td>
    <td>1 1</td>
    <td>Mode value (Least Median of Squares) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MODEW</b></td>
    <td>2 1</td>
    <td>Weighted mode value (Least Median of Squares) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>MUL</b></td>
    <td>2 1</td>
    <td>A * B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NAN</b></td>
    <td>2 1</td>
    <td>NaN if A == B, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NEG</b></td>
    <td>1 1</td>
    <td>-A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NEQ</b></td>
    <td>2 1</td>
    <td>1 if A != B, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NORM</b></td>
    <td>1 1</td>
    <td>Normalize (A) so max(A)-min(A) = 1</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NOT</b></td>
    <td>1 1</td>
    <td>NaN if A == NaN, 1 if A == 0, else 0</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>NRAND</b></td>
    <td>2 1</td>
    <td>Normal, random values with mean A and std. deviation B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>OR</b></td>
    <td>2 1</td>
    <td>NaN if B == NaN, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PCDF</b></td>
    <td>2 1</td>
    <td>Poisson cumulative distribution function for x = A and lambda = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PERM</b></td>
    <td>2 1</td>
    <td>Permutations n_P_r, with n = A and r = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PPDF</b></td>
    <td>2 1</td>
    <td>Poisson distribution P(x,lambda), with x = A and lambda = B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PLM</b></td>
    <td>3 1</td>
    <td>Associated Legendre polynomial P(A) degree B order C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PLMg</b></td>
    <td>3 1</td>
    <td>Normalized associated Legendre polynomial P(A) degree B order C
      (geophysical convention)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>POP</b></td>
    <td>1 0</td>
    <td>Delete top element from the stack</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>POW</b></td>
    <td>2 1</td>
    <td>A ^ B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PQUANT</b></td>
    <td>2 1</td>
    <td>The B&#x2019;th quantile (0-100%) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PQUANTW</b></td>
    <td>3 1</td>
    <td>The C&#x2019;th weighted quantile (0-100%) of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PSI</b></td>
    <td>1 1</td>
    <td>Psi (or Digamma) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PV</b></td>
    <td>3 1</td>
    <td>Legendre function Pv(A) of degree v = real(B) + imag(C)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>QV</b></td>
    <td>3 1</td>
    <td>Legendre function Qv(A) of degree v = real(B) + imag(C)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>R2</b></td>
    <td>2 1</td>
    <td>R2 = A^2 + B^2</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>R2D</b></td>
    <td>1 1</td>
    <td>Convert radians to degrees</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RAND</b></td>
    <td>2 1</td>
    <td>Uniform random values between A and B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RCDF</b></td>
    <td>1 1</td>
    <td>Rayleigh cumulative distribution function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RCRIT</b></td>
    <td>1 1</td>
    <td>Rayleigh distribution critical value for alpha = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RINT</b></td>
    <td>1 1</td>
    <td>rint (A) (round to integral value nearest to A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RMS</b></td>
    <td>1 1</td>
    <td>Root-mean-square of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RMSW</b></td>
    <td>1 1</td>
    <td>Weighted root-mean-square of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>RPDF</b></td>
    <td>1 1</td>
    <td>Rayleigh probability density function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ROLL</b></td>
    <td>2 0</td>
    <td>Cyclicly shifts the top A stack items by an amount B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ROTT</b></td>
    <td>2 1</td>
    <td>Rotate A by the (constant) shift B in the t-direction</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SEC</b></td>
    <td>1 1</td>
    <td>sec (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SECD</b></td>
    <td>1 1</td>
    <td>sec (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SIGN</b></td>
    <td>1 1</td>
    <td>sign (+1 or -1) of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SIN</b></td>
    <td>1 1</td>
    <td>sin (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SINC</b></td>
    <td>1 1</td>
    <td>sinc (A) (sin (pi*A)/(pi*A))</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SIND</b></td>
    <td>1 1</td>
    <td>sin (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SINH</b></td>
    <td>1 1</td>
    <td>sinh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SKEW</b></td>
    <td>1 1</td>
    <td>Skewness of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SQR</b></td>
    <td>1 1</td>
    <td>A^2</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SQRT</b></td>
    <td>1 1</td>
    <td>sqrt (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STD</b></td>
    <td>1 1</td>
    <td>Standard deviation of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STDW</b></td>
    <td>2 1</td>
    <td>Weighted standard deviation of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STEP</b></td>
    <td>1 1</td>
    <td>Heaviside step function H(A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>STEPT</b></td>
    <td>1 1</td>
    <td>Heaviside step function H(t-A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SUB</b></td>
    <td>2 1</td>
    <td>A - B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>SUM</b></td>
    <td>1 1</td>
    <td>Cumulative sum of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TAN</b></td>
    <td>1 1</td>
    <td>tan (A) (A in radians)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TAND</b></td>
    <td>1 1</td>
    <td>tan (A) (A in degrees)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TANH</b></td>
    <td>1 1</td>
    <td>tanh (A)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TAPER</b></td>
    <td>1 1</td>
    <td>Unit weights cosine-tapered to zero within A of end margins</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TN</b></td>
    <td>2 1</td>
    <td>Chebyshev polynomial Tn(-1&lt;A&lt;+1) of degree B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TCRIT</b></td>
    <td>2 1</td>
    <td>Student&#x2019;s t distribution critical value for alpha = A and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TPDF</b></td>
    <td>2 1</td>
    <td>Student&#x2019;s t probability density function for t = A, and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TCDF</b></td>
    <td>2 1</td>
    <td>Student&#x2019;s t cumulative distribution function for t = A, and nu =
      B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>UPPER</b></td>
    <td>1 1</td>
    <td>The highest (maximum) value of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>VAR</b></td>
    <td>1 1</td>
    <td>Variance of A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>VARW</b></td>
    <td>2 1</td>
    <td>Weighted variance of A for weights in B</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WCDF</b></td>
    <td>3 1</td>
    <td>Weibull cumulative distribution function for x = A, scale = B, and shape
      = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WCRIT</b></td>
    <td>3 1</td>
    <td>Weibull distribution critical value for alpha = A, scale = B, and shape
      = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>WPDF</b></td>
    <td>3 1</td>
    <td>Weibull density distribution P(x,scale,shape), with x = A, scale = B,
      and shape = C</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>XOR</b></td>
    <td>2 1</td>
    <td>B if A == NaN, else A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>Y0</b></td>
    <td>1 1</td>
    <td>Bessel function of A (2nd kind, order 0)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>Y1</b></td>
    <td>1 1</td>
    <td>Bessel function of A (2nd kind, order 1)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>YN</b></td>
    <td>2 1</td>
    <td>Bessel function of A (2nd kind, order B)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ZCDF</b></td>
    <td>1 1</td>
    <td>Normal cumulative distribution function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ZPDF</b></td>
    <td>1 1</td>
    <td>Normal probability density function for z = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ZCRIT</b></td>
    <td>1 1</td>
    <td>Normal distribution critical value for alpha = A</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>ROOTS</b></td>
    <td>2 1</td>
    <td>Treats col A as f(t) = 0 and returns its roots</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<h1 class="Sh" title="Sh" id="SYMBOLS"><a class="selflink" href="#SYMBOLS">SYMBOLS</a></h1>
The following symbols have special meaning:
<table class="tbl">
  <colgroup>
    <col style="width: 12.00ex;"/>
    <col style="width: 43.00ex;"/>
  </colgroup>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>PI</b></td>
    <td>3.1415926&#x2026;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>E</b></td>
    <td>2.7182818&#x2026;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EULER</b></td>
    <td>0.5772156&#x2026;</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EPS_F</b></td>
    <td>1.192092896e-07 (sgl. prec. eps)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>EPS_D</b></td>
    <td>2.2204460492503131e-16 (dbl. prec. eps)</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TMIN</b></td>
    <td>Minimum t value</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TMAX</b></td>
    <td>Maximum t value</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TRANGE</b></td>
    <td>Range of t values</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TINC</b></td>
    <td>t increment</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>N</b></td>
    <td>The number of records</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>T</b></td>
    <td>Table with t-coordinates</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TNORM</b></td>
    <td>Table with normalized t-coordinates</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td><b>TROW</b></td>
    <td>Table with row numbers 1, 2, &#x2026;, N-1</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
</table>
<h1 class="Sh" title="Sh" id="ASCII_FORMAT_PRECISION"><a class="selflink" href="#ASCII_FORMAT_PRECISION">ASCII
  FORMAT PRECISION</a></h1>
The ASCII output formats of numerical data are controlled by parameters in your
  gmt.conf file. Longitude and latitude are formatted according to
  FORMAT_GEO_OUT, absolute time is under the control of FORMAT_DATE_OUT and
  FORMAT_CLOCK_OUT, whereas general floating point values are formatted
  according to FORMAT_FLOAT_OUT. Be aware that the format in effect can lead to
  loss of precision in ASCII output, which can lead to various problems
  downstream. If you find the output is not written with enough precision,
  consider switching to binary output ( <b>-bo</b> if available) or specify more
  decimals using the FORMAT_FLOAT_OUT setting.
<h1 class="Sh" title="Sh" id="NOTES_ON_OPERATORS"><a class="selflink" href="#NOTES_ON_OPERATORS">NOTES
  ON OPERATORS</a></h1>
1. The operators <b>PLM</b> and <b>PLMg</b> calculate the associated Legendre
  polynomial of degree L and order M in x which must satisfy -1 &lt;= x &lt;= +1
  and 0 &lt;= M &lt;= L. x, L, and M are the three arguments preceding the
  operator. <b>PLM</b> is not normalized and includes the Condon-Shortley phase
  (-1)^M. <b>PLMg</b> is normalized in the way that is most commonly used in
  geophysics. The C-S phase can be added by using -M as argument. <b>PLM</b>
  will overflow at higher degrees, whereas <b>PLMg</b> is stable until ultra
  high degrees (at least 3000).
<div style="height: 1.00em;">&#x00A0;</div>
2. Files that have the same names as some operators, e.g., <b>ADD</b>,
  <b>SIGN</b>, <b>=</b>, etc. should be identified by prepending the current
  directory (i.e., ./).
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">3.</dt>
  <dd class="It-tag">The stack depth limit is hard-wired to 100.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
4. All functions expecting a positive radius (e.g., <b>LOG</b>, <b>KEI</b>,
  etc.) are passed the absolute value of their argument.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">5.</dt>
  <dd class="It-tag">The <b>DDT</b> and <b>D2DT2</b> functions only work on
      regularly spaced data.</dd>
</dl>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
6. All derivatives are based on central finite differences, with natural
  boundary conditions.
<div style="margin-left: 0.00ex;">
<dl class="Bl-tag">
  <dt class="It-tag">7.</dt>
  <dd class="It-tag"><b>ROOTS</b> must be the last operator on the stack, only
      followed by <b>=</b>.</dd>
</dl>
</div>
<br/>
<h1 class="Sh" title="Sh" id="STORE,_RECALL_AND_CLEAR"><a class="selflink" href="#STORE,_RECALL_AND_CLEAR">STORE,
  RECALL AND CLEAR</a></h1>
You may store intermediate calculations to a named variable that you may recall
  and place on the stack at a later time. This is useful if you need access to a
  computed quantity many times in your expression as it will shorten the overall
  expression and improve readability. To save a result you use the special
  operator <b>STO</b>@<i>label</i>, where <i>label</i> is the name you choose to
  give the quantity. To recall the stored result to the stack at a later time,
  use [ <b>RCL</b>]@<i>label</i>, i.e., <b>RCL</b> is optional. To clear memory
  you may use <b>CLR</b>@<i>label</i>. Note that <b>STO</b> and <b>CLR</b> leave
  the stack unchanged.
<div style="height: 1.00em;">&#x00A0;</div>
8. The bitwise operators ( <b>BITAND</b>, <b>BITLEFT</b>, <b>BITNOT</b>,
  <b>BITOR</b>, <b>BITRIGHT</b>, <b>BITTEST</b>, and <b>BITXOR</b>) convert a
  tables&#x2019;s double precision values to unsigned 64-bit ints to perform the
  bitwise operations. Consequently, the largest whole integer value that can be
  stored in a double precision value is 2^53 or 9,007,199,254,740,992. Any
  higher result will be masked to fit in the lower 54 bits. Thus, bit operations
  are effectively limited to 54 bits. All bitwise operators return NaN if given
  NaN arguments or bit-settings &lt;= 0.
<div style="height: 1.00em;">&#x00A0;</div>
9. TAPER will interpret its argument to be a width in the same units as the
  time-axis, but if no time is provided (i.e., plain data tables) then the width
  is taken to be given in number of rows.
<h1 class="Sh" title="Sh" id="MACROS"><a class="selflink" href="#MACROS">MACROS</a></h1>
Users may save their favorite operator combinations as macros via the file
  <i>gmtmath.macros</i> in their current or user directory. The file may contain
  any number of macros (one per record); comment lines starting with # are
  skipped. The format for the macros is <b>name</b> = <b>arg1 arg2 &#x2026;
  arg2</b> [ : <i>comment</i>] where <b>name</b> is how the macro will be used.
  When this operator appears on the command line we simply replace it with the
  listed argument list. No macro may call another macro. As an example, the
  following macro expects that the time-column contains seafloor ages in Myr and
  computes the predicted half-space bathymetry:
<div style="height: 1.00em;">&#x00A0;</div>
<b>DEPTH</b> = <b>SQRT 350 MUL 2500 ADD NEG</b> : <i>usage: DEPTH to return</i>
  <i>half-space seafloor depths</i>
<div style="height: 1.00em;">&#x00A0;</div>
Note: Because geographic or time constants may be present in a macro, it is
  required that the optional comment flag (:) must be followed by a space. As
  another example, we show a macro <b>GPSWEEK</b> which determines which GPS
  week a timestamp belongs to:
<div style="height: 1.00em;">&#x00A0;</div>
<b>GPSWEEK</b> = 1980-01-06T00:00:00 SUB 86400 DIV 7 DIV FLOOR : GPS week
  without rollover
<h1 class="Sh" title="Sh" id="ACTIVE_COLUMN_SELECTION"><a class="selflink" href="#ACTIVE_COLUMN_SELECTION">ACTIVE
  COLUMN SELECTION</a></h1>
When <b>-C</b><i>cols</i> is set then any operation, including loading of data
  from files, will restrict which columns are affected. To avoid unexpected
  results, note that if you issue a <b>-C</b><i>cols</i> option before you load
  in the data then only those columns will be updated, hence the unspecified
  columns will be zero. On the other hand, if you load the file first and then
  issue <b>-C</b><i>cols</i> then the unspecified columns will have been loaded
  but are then ignored until you undo the effect of <b>-C</b>.
<h1 class="Sh" title="Sh" id="EXAMPLES"><a class="selflink" href="#EXAMPLES">EXAMPLES</a></h1>
To add two plot dimensions of different units, we can run
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
length=`gmt math -Q 15c 2i SUB =`
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To take the square root of the content of the second data column being piped
  through <b>gmtmath</b> by process1 and pipe it through a 3rd process, use
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
process1 | gmt math STDIN SQRT = | process3
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To take log10 of the average of 2 data files, use
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math file1.d file2.d ADD 0.5 MUL LOG10 = file3.d
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Given the file samples.d, which holds seafloor ages in m.y. and seafloor depth
  in m, use the relation depth(in m) = 2500 + 350 * sqrt (age) to print the
  depth anomalies:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math samples.d T SQRT 350 MUL 2500 ADD SUB = | lpr
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To take the average of columns 1 and 4-6 in the three data sets sizes.1,
  sizes.2, and sizes.3, use
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math -C1,4-6 sizes.1 sizes.2 ADD sizes.3 ADD 3 DIV = ave.d
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To take the 1-column data set ages.d and calculate the modal value and assign it
  to a variable, try
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt set mode_age = `gmt math -S -T ages.d MODE =`
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To evaluate the dilog(x) function for coordinates given in the file t.d:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math -Tt.d T DILOG = dilog.d
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To demonstrate the use of stored variables, consider this sum of the first 3
  cosine harmonics where we store and repeatedly recall the trigonometric
  argument (2*pi*T/360):
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math -T0/360/1 2 PI MUL 360 DIV T MUL STO@kT COS @kT 2 MUL COS ADD \
            @kT 3 MUL COS ADD = harmonics.d
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To use <b>gmtmath</b> as a RPN Hewlett-Packard calculator on scalars (i.e., no
  input files) and calculate arbitrary expressions, use the <b>-Q</b> option. As
  an example, we will calculate the value of Kei (((1 + 1.75)/2.2) + cos (60))
  and store the result in the shell variable z:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
set z = `gmt math -Q 1 1.75 ADD 2.2 DIV 60 COSD ADD KEI =`
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
To use <b>gmtmath</b> as a general least squares equation solver, imagine that
  the current table is the augmented matrix [ A | b ] and you want the least
  squares solution x to the matrix equation A * x = b. The operator
  <b>LSQFIT</b> does this; it is your job to populate the matrix correctly
  first. The <b>-A</b> option will facilitate this. Suppose you have a 2-column
  file ty.d with <i>t</i> and <i>b(t)</i> and you would like to fit a the model
  y(t) = a + b*t + c*H(t-t0), where H is the Heaviside step function for a given
  t0 = 1.55. Then, you need a 4-column augmented table loaded with t in column 1
  and your observed y(t) in column 3. The calculation becomes
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math -N4/1 -Aty.d -C0 1 ADD -C2 1.55 STEPT ADD -Ca LSQFIT = solution.d
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Note we use the <b>-C</b> option to select which columns we are working on, then
  make active all the columns we need (here all of them, with <b>-Ca</b>) before
  calling <b>LSQFIT</b>. The second and fourth columns (col numbers 1 and 3) are
  preloaded with t and y(t), respectively, the other columns are zero. If you
  already have a pre-calculated table with the augmented matrix [ A | b ] in a
  file (say lsqsys.d), the least squares solution is simply
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
gmt math -T lsqsys.d LSQFIT = solution.d
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
Users must be aware that when <b>-C</b> controls which columns are to be active
  the control extends to placing columns from files as well. Contrast the
  different result obtained by these very similar commands:
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
echo 1 2 3 4 | gmt math STDIN -C3 1 ADD =
1    2    3    5
</pre>
</div>
<br/>
</div>
<br/>
<div style="height: 1.00em;">&#x00A0;</div>
versus
<div style="margin-left: 0.00ex;">
<div style="margin-left: 3.50ex;">
<div style="height: 1.00em;">&#x00A0;</div>
<pre>
echo 1 2 3 4 | gmt math -C3 STDIN 1 ADD =
0    0    0    5
</pre>
</div>
<br/>
</div>
<br/>
<h1 class="Sh" title="Sh" id="REFERENCES"><a class="selflink" href="#REFERENCES">REFERENCES</a></h1>
Abramowitz, M., and I. A. Stegun, 1964, <i>Handbook of Mathematical</i>
  <i>Functions</i>, Applied Mathematics Series, vol. 55, Dover, New York.
<div style="height: 1.00em;">&#x00A0;</div>
Holmes, S. A., and W. E. Featherstone, 2002, A unified approach to the Clenshaw
  summation and the recursive computation of very high degree and order
  normalized associated Legendre functions. <i>Journal of Geodesy</i>, 76,
  279-299.
<div style="height: 1.00em;">&#x00A0;</div>
Press, W. H., S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery, 1992,
  <i>Numerical Recipes</i>, 2nd edition, Cambridge Univ., New York.
<div style="height: 1.00em;">&#x00A0;</div>
Spanier, J., and K. B. Oldman, 1987, <i>An Atlas of Functions</i>, Hemisphere
  Publishing Corp.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
gmt, grdmath
<h1 class="Sh" title="Sh" id="COPYRIGHT"><a class="selflink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2017, P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis, and F. Wobbe</div>
<table class="foot">
  <tr>
    <td class="foot-date">June 24, 2017</td>
    <td class="foot-os">5.4.2</td>
  </tr>
</table>
</body>
</html>
