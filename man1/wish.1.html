<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:43:01 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>wish(1) Tk Applications wish(1)</p>


<p style="margin-top: 1em">_________________________________________________________________________________________________________________________________________________________________________________________</p>

<p style="margin-top: 1em">NAME <br>
wish - Simple windowing shell</p>

<p style="margin-top: 1em">SYNOPSIS <br>
wish ?-encoding name? ?fileName arg arg ...?</p>

<p style="margin-top: 1em">OPTIONS <br>
-encoding name Specifies the encoding of the text stored in
fileName. This option is only recognized prior to the
fileName argument. &acirc;</p>

<p style="margin-top: 1em">-colormap new Specifies that the
window should have a new private colormap instead of using
the default colormap for the screen.</p>

<p style="margin-top: 1em">-display display Display (and
screen) on which to display window.</p>

<p style="margin-top: 1em">-geometry geometry Initial
geometry to use for window. If this option is specified, its
value is stored in the geometry global variable of the
application&rsquo;s Tcl interpreter.</p>

<p style="margin-top: 1em">-name name Use name as the title
to be displayed in the window, and as the name of the
interpreter for send commands.</p>

<p style="margin-top: 1em">-sync Execute all X server
commands synchronously, so that errors are reported
immediately. This will result in much slower execution, but
it is useful for debug&acirc; <br>
ging.</p>

<p style="margin-top: 1em">-use id Specifies that the main
window for the application is to be embedded in the window
whose identifier is id, instead of being created as an
independent toplevel <br>
window. Id must be specified in the same way as the value
for the -use option for toplevel widgets (i.e. it has a form
like that returned by the winfo id <br>
command). <br>
Note that on some platforms this will only work correctly if
id refers to a Tk frame or toplevel that has its -container
option enabled.</p>

<p style="margin-top: 1em">-visual visual Specifies the
visual to use for the window. Visual may have any of the
forms supported by the Tk_GetVisual procedure.</p>

<p style="margin-top: 1em">-- Pass all remaining arguments
through to the script&rsquo;s argv variable without
interpreting them. This provides a mechanism for passing
arguments such as -name <br>
to a script instead of having wish interpret them.
_________________________________________________________________</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Wish is a simple program consisting of the Tcl command
language, the Tk toolkit, and a main program that reads
commands from standard input or from a file. It creates a
main <br>
window and then processes Tcl commands. If wish is invoked
with arguments, then the first few arguments, ?-encoding
name? ?fileName? specify the name of a script file, and,
<br>
optionally, the encoding of the text data stored in that
script file. A value for fileName is recognized if the
appropriate argument does not start with
&acirc;-&acirc;.</p>

<p style="margin-top: 1em">If there are no arguments, or
the arguments do not specify a fileName, then wish reads Tcl
commands interactively from standard input. It will continue
processing commands until <br>
all windows have been deleted or until end-of-file is
reached on standard input. If there exists a file
&acirc;.wishrc&acirc; in the home directory of the user,
wish evaluates the file as a <br>
Tcl script just before reading the first command from
standard input.</p>

<p style="margin-top: 1em">If arguments to wish do specify
a fileName, then fileName is treated as the name of a script
file. Wish will evaluate the script in fileName (which
presumably creates a user <br>
interface), then it will respond to events until all windows
have been deleted. Commands will not be read from standard
input. There is no automatic evaluation of
&acirc;.wishrc&acirc; <br>
when the name of a script file is presented on the wish
command line, but the script file can always source it if
desired.</p>

<p style="margin-top: 1em">Note that on Windows, the
wishversion.exe program varies from the tclshversion.exe
program in an additional important way: it does not connect
to a standard Windows console and <br>
is instead a windowed program. Because of this, it
additionally provides access to its own console command.</p>

<p style="margin-top: 1em">OPTION PROCESSING <br>
Wish automatically processes all of the command-line options
described in the OPTIONS summary above. Any other
command-line arguments besides these are passed through to
the <br>
application using the argc and argv variables described
later.</p>

<p style="margin-top: 1em">APPLICATION NAME AND CLASS <br>
The name of the application, which is used for purposes such
as send commands, is taken from the -name option, if it is
specified; otherwise it is taken from fileName, if it is
<br>
specified, or from the command name by which wish was
invoked. In the last two cases, if the name contains a
&acirc;/&acirc; character, then only the characters after
the last slash are <br>
used as the application name.</p>

<p style="margin-top: 1em">The class of the application,
which is used for purposes such as specifying options with a
RESOURCE_MANAGER property or .Xdefaults file, is the same as
its name except that the <br>
first letter is capitalized.</p>

<p style="margin-top: 1em">VARIABLES <br>
Wish sets the following Tcl variables:</p>

<p style="margin-top: 1em">argc Contains a count of the
number of arg arguments (0 if none), not including the
options described above.</p>

<p style="margin-top: 1em">argv Contains a Tcl list whose
elements are the arg arguments that follow a -- option or do
not match any of the options described in OPTIONS above, in
order, or an <br>
empty string if there are no such arguments.</p>

<p style="margin-top: 1em">argv0 Contains fileName if it
was specified. Otherwise, contains the name by which wish
was invoked.</p>

<p style="margin-top: 1em">geometry If the -geometry option
is specified, wish copies its value into this variable. If
the variable still exists after fileName has been evaluated,
wish uses the <br>
value of the variable in a wm geometry command to set the
main window&rsquo;s geometry.</p>

<p style="margin-top: 1em">tcl_interactive <br>
Contains 1 if wish is reading commands interactively
(fileName was not specified and standard input is a
terminal-like device), 0 otherwise.</p>

<p style="margin-top: 1em">SCRIPT FILES <br>
If you create a Tcl script in a file whose first line is
<br>
#!/usr/local/bin/wish <br>
then you can invoke the script file directly from your shell
if you mark it as executable. This assumes that wish has
been installed in the default location in /usr/local/bin;
<br>
if it is installed somewhere else then you will have to
modify the above line to match. Many UNIX systems do not
allow the #! line to exceed about 30 characters in length,
so be <br>
sure that the wish executable can be accessed with a short
file name.</p>

<p style="margin-top: 1em">An even better approach is to
start your script files with the following three lines: <br>
#!/bin/sh <br>
# the next line restarts using wish exec wish &quot;$0&quot;
${1+&quot;$@&quot;} <br>
This approach has three advantages over the approach in the
previous paragraph. First, the location of the wish binary
does not have to be hard-wired into the script: it can be
<br>
anywhere in your shell search path. Second, it gets around
the 30-character file name limit in the previous approach.
Third, this approach will work even if wish is itself a <br>
shell script (this is done on some systems in order to
handle multiple architectures or operating systems: the wish
script selects one of several binaries to run). The three
<br>
lines cause both sh and wish to process the script, but the
exec is only executed by sh. sh processes the script first;
it treats the second line as a comment and executes the <br>
third line. The exec statement cause the shell to stop
processing and instead to start up wish to reprocess the
entire script. When wish starts up, it treats all three
lines as <br>
comments, since the backslash at the end of the second line
causes the third line to be treated as part of the comment
on the second line.</p>

<p style="margin-top: 1em">The end of a script file may be
marked either by the physical end of the medium, or by the
character, &acirc; 32&acirc; (&acirc;001a&acirc;,
control-Z). If this character is present in the file, the
<br>
wish application will read text up to but not including the
character. An application that requires this character in
the file may encode it as &acirc; 32&acirc;,
&acirc;a&acirc;, or &acirc;001a&acirc;; or <br>
may generate it by use of commands such as format or
binary.</p>

<p style="margin-top: 1em">PROMPTS <br>
When wish is invoked interactively it normally prompts for
each command with &acirc;% &acirc;. You can change the
prompt by setting the variables tcl_prompt1 and tcl_prompt2.
If variable <br>
tcl_prompt1 exists then it must consist of a Tcl script to
output a prompt; instead of outputting a prompt wish will
evaluate the script in tcl_prompt1. The variable <br>
tcl_prompt2 is used in a similar way when a newline is typed
but the current command is not yet complete; if tcl_prompt2
is not set then no prompt is output for incomplete
com&acirc; <br>
mands.</p>

<p style="margin-top: 1em">KEYWORDS <br>
shell, toolkit</p>

<p style="margin-top: 1em">Tk 8.0 wish(1)</p>
<hr>
</body>
</html>
