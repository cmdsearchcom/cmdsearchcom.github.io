<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:02:14 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DASH(1) BSD General Commands Manual DASH(1)</p>

<p style="margin-top: 1em">NAME <br>
dash &acirc; command interpreter (shell)</p>

<p style="margin-top: 1em">SYNOPSIS <br>
dash [-aCefnuvxIimqVEbp] [+aCefnuvxIimqVEbp] [-o
option_name] [+o option_name] [command_file [argument ...]]
<br>
dash -c [-aCefnuvxIimqVEbp] [+aCefnuvxIimqVEbp] [-o
option_name] [+o option_name] command_string [command_name
[argument ...]] <br>
dash -s [-aCefnuvxIimqVEbp] [+aCefnuvxIimqVEbp] [-o
option_name] [+o option_name] [argument ...]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
dash is the standard command interpreter for the system. The
current version of dash is in the process of being changed
to conform with the POSIX 1003.2 and 1003.2a specifications
<br>
for the shell. This version has many features which make it
appear similar in some respects to the Korn shell, but it is
not a Korn shell clone (see ksh(1)). Only features
desig&acirc; <br>
nated by POSIX, plus a few Berkeley extensions, are being
incorporated into this shell. This man page is not intended
to be a tutorial or a complete specification of the
shell.</p>

<p style="margin-top: 1em">Overview <br>
The shell is a command that reads lines from either a file
or the terminal, interprets them, and generally executes
other commands. It is the program that is running when a
user <br>
logs into the system (although a user can select a different
shell with the chsh(1) command). The shell implements a
language that has flow control constructs, a macro facility
<br>
that provides a variety of features in addition to data
storage, along with built in history and line editing
capabilities. It incorporates many features to aid
interactive use <br>
and has the advantage that the interpretative language is
common to both interactive and non-interactive use (shell
scripts). That is, commands can be typed directly to the
run&acirc; <br>
ning shell or can be put into a file and the file can be
executed directly by the shell.</p>

<p style="margin-top: 1em">Invocation <br>
If no args are present and if the standard input of the
shell is connected to a terminal (or if the -i flag is set),
and the -c option is not present, the shell is considered an
<br>
interactive shell. An interactive shell generally prompts
before each command and handles programming and command
errors differently (as described below). When first
starting, <br>
the shell inspects argument 0, and if it begins with a dash
&acirc;-&acirc;, the shell is also considered a login shell.
This is normally done automatically by the system when the
user first <br>
logs in. A login shell first reads commands from the files
/etc/profile and .profile if they exist. If the environment
variable ENV is set on entry to an interactive shell, or is
<br>
set in the .profile of a login shell, the shell next reads
commands from the file named in ENV. Therefore, a user
should place commands that are to be executed only at login
time <br>
in the .profile file, and commands that are executed for
every interactive shell inside the ENV file. To set the ENV
variable to some file, place the following line in your <br>
.profile of your home directory</p>

<p style="margin-top: 1em">ENV=$HOME/.shinit; export
ENV</p>

<p style="margin-top: 1em">substituting for
&acirc;.shinit&acirc; any filename you wish.</p>

<p style="margin-top: 1em">If command line arguments
besides the options have been specified, then the shell
treats the first argument as the name of a file from which
to read commands (a shell script), and <br>
the remaining arguments are set as the positional parameters
of the shell ($1, $2, etc). Otherwise, the shell reads
commands from its standard input.</p>

<p style="margin-top: 1em">Argument List Processing <br>
All of the single letter options that have a corresponding
name can be used as an argument to the -o option. The set -o
name is provided next to the single letter option in the
<br>
description below. Specifying a dash &acirc;-&acirc; turns
the option on, while using a plus &acirc;+&acirc; disables
the option. The following options can be set from the
command line or with the set <br>
builtin (described later).</p>

<p style="margin-top: 1em">-a allexport Export all
variables assigned to.</p>

<p style="margin-top: 1em">-c Read commands from the
command_string operand instead of from the standard input.
Special parameter 0 will be set from the command_name
operand and the <br>
positional parameters ($1, $2, etc.) set from the remaining
argument operands.</p>

<p style="margin-top: 1em">-C noclobber Don&rsquo;t
overwrite existing files with &acirc;&gt;&acirc;.</p>

<p style="margin-top: 1em">-e errexit If not interactive,
exit immediately if any untested command fails. The exit
status of a command is considered to be explicitly tested if
the command is <br>
used to control an if, elif, while, or until; or if the
command is the left hand operand of an
&acirc;&amp;&amp;&acirc; or &acirc;||&acirc; operator.</p>

<p style="margin-top: 1em">-f noglob Disable pathname
expansion.</p>

<p style="margin-top: 1em">-n noexec If not interactive,
read commands but do not execute them. This is useful for
checking the syntax of shell scripts.</p>

<p style="margin-top: 1em">-u nounset Write a message to
standard error when attempting to expand a variable that is
not set, and if the shell is not interactive, exit
immediately.</p>

<p style="margin-top: 1em">-v verbose The shell writes its
input to standard error as it is read. Useful for
debugging.</p>

<p style="margin-top: 1em">-x xtrace Write each command to
standard error (preceded by a &acirc;+ &acirc;) before it is
executed. Useful for debugging.</p>

<p style="margin-top: 1em">-I ignoreeof Ignore EOF&rsquo;s
from input when interactive.</p>

<p style="margin-top: 1em">-i interactive Force the shell
to behave interactively.</p>

<p style="margin-top: 1em">-l Make dash act as if it had
been invoked as a login shell.</p>

<p style="margin-top: 1em">-m monitor Turn on job control
(set automatically when interactive).</p>

<p style="margin-top: 1em">-s stdin Read commands from
standard input (set automatically if no file arguments are
present). This option has no effect when set after the shell
has already <br>
started running (i.e. with set).</p>

<p style="margin-top: 1em">-V vi Enable the built-in vi(1)
command line editor (disables -E if it has been set).</p>

<p style="margin-top: 1em">-E emacs Enable the built-in
emacs(1) command line editor (disables -V if it has been
set).</p>

<p style="margin-top: 1em">-b notify Enable asynchronous
notification of background job completion. (UNIMPLEMENTED
for 4.4alpha)</p>

<p style="margin-top: 1em">-p priv Do not attempt to reset
effective uid if it does not match uid. This is not set by
default to help avoid incorrect usage by setuid root
programs via sys&acirc; <br>
tem(3) or popen(3).</p>

<p style="margin-top: 1em">Lexical Structure <br>
The shell reads input in terms of lines from a file and
breaks it up into words at whitespace (blanks and tabs), and
at certain sequences of characters that are special to the
<br>
shell called &acirc;operators&acirc;. There are two types of
operators: control operators and redirection operators
(their meaning is discussed later). Following is a list of
operators:</p>

<p style="margin-top: 1em">Control operators: <br>
&amp; &amp;&amp; ( ) ; ;; | || &lt;newline&gt;</p>

<p style="margin-top: 1em">Redirection operators: <br>
&lt; &gt; &gt;| &lt;&lt; &gt;&gt; &lt;&amp; &gt;&amp;
&lt;&lt;- &lt;&gt;</p>

<p style="margin-top: 1em">Quoting <br>
Quoting is used to remove the special meaning of certain
characters or words to the shell, such as operators,
whitespace, or keywords. There are three types of quoting:
matched <br>
single quotes, matched double quotes, and backslash.</p>

<p style="margin-top: 1em">Backslash <br>
A backslash preserves the literal meaning of the following
character, with the exception of
&acirc;&uml;newline&acirc;&copy;. A backslash preceding a
&acirc;&uml;newline&acirc;&copy; is treated as a line
continuation.</p>

<p style="margin-top: 1em">Single Quotes <br>
Enclosing characters in single quotes preserves the literal
meaning of all the characters (except single quotes, making
it impossible to put single-quotes in a single-quoted <br>
string).</p>

<p style="margin-top: 1em">Double Quotes <br>
Enclosing characters within double quotes preserves the
literal meaning of all characters except dollarsign ($),
backquote (&lsquo;), and backslash (. The backslash inside
double <br>
quotes is historically weird, and serves to quote only the
following characters: <br>
$ &lsquo; &quot; &nbsp;&lt;newline&gt;. <br>
Otherwise it remains literal.</p>

<p style="margin-top: 1em">Reserved Words <br>
Reserved words are words that have special meaning to the
shell and are recognized at the beginning of a line and
after a control operator. The following are reserved
words:</p>

<p style="margin-top: 1em">! elif fi while case <br>
else for then { } <br>
do done until if esac</p>

<p style="margin-top: 1em">Their meaning is discussed
later.</p>

<p style="margin-top: 1em">Aliases <br>
An alias is a name and corresponding value set using the
alias(1) builtin command. Whenever a reserved word may occur
(see above), and after checking for reserved words, the
shell <br>
checks the word to see if it matches an alias. If it does,
it replaces it in the input stream with its value. For
example, if there is an alias called &acirc;lf&acirc; with
the value &acirc;ls <br>
-F&acirc;, then the input:</p>

<p style="margin-top: 1em">lf foobar
&acirc;&uml;return&acirc;&copy;</p>

<p style="margin-top: 1em">would become</p>

<p style="margin-top: 1em">ls -F foobar
&acirc;&uml;return&acirc;&copy;</p>

<p style="margin-top: 1em">Aliases provide a convenient way
for naive users to create shorthands for commands without
having to learn how to create functions with arguments. They
can also be used to create <br>
lexically obscure code. This use is discouraged.</p>

<p style="margin-top: 1em">Commands <br>
The shell interprets the words it reads according to a
language, the specification of which is outside the scope of
this man page (refer to the BNF in the POSIX 1003.2
document). <br>
Essentially though, a line is read and if the first word of
the line (or after a control operator) is not a reserved
word, then the shell has recognized a simple command.
Other&acirc; <br>
wise, a complex command or some other special construct may
have been recognized.</p>

<p style="margin-top: 1em">Simple Commands <br>
If a simple command has been recognized, the shell performs
the following actions:</p>

<p style="margin-top: 1em">1. Leading words of the form
&acirc;name=value&acirc; are stripped off and assigned to
the environment of the simple command. Redirection operators
and their arguments (as described <br>
below) are stripped off and saved for processing.</p>

<p style="margin-top: 1em">2. The remaining words are
expanded as described in the section called
&acirc;Expansions&acirc;, and the first remaining word is
considered the command name and the command is located. <br>
The remaining words are considered the arguments of the
command. If no command name resulted, then the
&acirc;name=value&acirc; variable assignments recognized in
item 1 affect the <br>
current shell.</p>

<p style="margin-top: 1em">3. Redirections are performed as
described in the next section.</p>

<p style="margin-top: 1em">Redirections <br>
Redirections are used to change where a command reads its
input or sends its output. In general, redirections open,
close, or duplicate an existing reference to a file. The
over&acirc; <br>
all format used for redirection is:</p>

<p style="margin-top: 1em">[n] redir-op file</p>

<p style="margin-top: 1em">where redir-op is one of the
redirection operators mentioned previously. Following is a
list of the possible redirections. The [n] is an optional
number, as in &acirc;3&acirc; (not &acirc;[3]&acirc;), <br>
that refers to a file descriptor.</p>

<p style="margin-top: 1em">[n]&gt; file Redirect standard
output (or n) to file.</p>

<p style="margin-top: 1em">[n]&gt;| file Same, but override
the -C option.</p>

<p style="margin-top: 1em">[n]&gt;&gt; file Append standard
output (or n) to file.</p>

<p style="margin-top: 1em">[n]&lt; file Redirect standard
input (or n) from file.</p>

<p style="margin-top: 1em">[n1]&lt;&amp;n2 Duplicate
standard input (or n1) from file descriptor n2.</p>

<p style="margin-top: 1em">[n]&lt;&amp;- Close standard
input (or n).</p>

<p style="margin-top: 1em">[n1]&gt;&amp;n2 Duplicate
standard output (or n1) to n2.</p>

<p style="margin-top: 1em">[n]&gt;&amp;- Close standard
output (or n).</p>

<p style="margin-top: 1em">[n]&lt;&gt; file Open file for
reading and writing on standard input (or n).</p>

<p style="margin-top: 1em">The following redirection is
often called a &acirc;here-document&acirc;.</p>

<p style="margin-top: 1em">[n]&lt;&lt; delimiter <br>
here-doc-text ... <br>
delimiter</p>

<p style="margin-top: 1em">All the text on successive lines
up to the delimiter is saved away and made available to the
command on standard input, or file descriptor n if it is
specified. If the delimiter <br>
as specified on the initial line is quoted, then the
here-doc-text is treated literally, otherwise the text is
subjected to parameter expansion, command substitution, and
arith&acirc; <br>
metic expansion (as described in the section on
&acirc;Expansions&acirc;). If the operator is
&acirc;&lt;&lt;-&acirc; instead of &acirc;&lt;&lt;&acirc;,
then leading tabs in the here-doc-text are stripped.</p>

<p style="margin-top: 1em">Search and Execution <br>
There are three types of commands: shell functions, builtin
commands, and normal programs -- and the command is searched
for (by name) in that order. They each are executed in a
<br>
different way.</p>

<p style="margin-top: 1em">When a shell function is
executed, all of the shell positional parameters (except $0,
which remains unchanged) are set to the arguments of the
shell function. The variables which <br>
are explicitly placed in the environment of the command (by
placing assignments to them before the function name) are
made local to the function and are set to the values given.
<br>
Then the command given in the function definition is
executed. The positional parameters are restored to their
original values when the command completes. This all occurs
within <br>
the current shell.</p>

<p style="margin-top: 1em">Shell builtins are executed
internally to the shell, without spawning a new process.</p>

<p style="margin-top: 1em">Otherwise, if the command name
doesn&rsquo;t match a function or builtin, the command is
searched for as a normal program in the file system (as
described in the next section). When a <br>
normal program is executed, the shell runs the program,
passing the arguments and the environment to the program. If
the program is not a normal executable file (i.e., if it
does <br>
not begin with the &quot;magic number&quot; whose ASCII
representation is &quot;#!&quot;, so execve(2) returns
ENOEXEC then) the shell will interpret the program in a
subshell. The child shell will <br>
reinitialize itself in this case, so that the effect will be
as if a new shell had been invoked to handle the ad-hoc
shell script, except that the location of hashed commands
<br>
located in the parent shell will be remembered by the
child.</p>

<p style="margin-top: 1em">Note that previous versions of
this document and the source code itself misleadingly and
sporadically refer to a shell script without a magic number
as a &quot;shell procedure&quot;.</p>

<p style="margin-top: 1em">Path Search <br>
When locating a command, the shell first looks to see if it
has a shell function by that name. Then it looks for a
builtin command by that name. If a builtin command is not
<br>
found, one of two things happen:</p>

<p style="margin-top: 1em">1. Command names containing a
slash are simply executed without performing any
searches.</p>

<p style="margin-top: 1em">2. The shell searches each entry
in PATH in turn for the command. The value of the PATH
variable should be a series of entries separated by colons.
Each entry consists of a <br>
directory name. The current directory may be indicated
implicitly by an empty directory name, or explicitly by a
single period.</p>

<p style="margin-top: 1em">Command Exit Status <br>
Each command has an exit status that can influence the
behaviour of other shell commands. The paradigm is that a
command exits with zero for normal or success, and non-zero
for <br>
failure, error, or a false indication. The man page for each
command should indicate the various exit codes and what they
mean. Additionally, the builtin commands return exit <br>
codes, as does an executed shell function.</p>

<p style="margin-top: 1em">If a command consists entirely
of variable assignments then the exit status of the command
is that of the last command substitution if any, otherwise
0.</p>

<p style="margin-top: 1em">Complex Commands <br>
Complex commands are combinations of simple commands with
control operators or reserved words, together creating a
larger complex command. More generally, a command is one of
the <br>
following:</p>

<p style="margin-top: 1em">&Acirc;&middot; simple
command</p>

<p style="margin-top: 1em">&Acirc;&middot; pipeline</p>

<p style="margin-top: 1em">&Acirc;&middot; list or
compound-list</p>

<p style="margin-top: 1em">&Acirc;&middot; compound
command</p>

<p style="margin-top: 1em">&Acirc;&middot; function
definition</p>

<p style="margin-top: 1em">Unless otherwise stated, the
exit status of a command is that of the last simple command
executed by the command.</p>

<p style="margin-top: 1em">Pipelines <br>
A pipeline is a sequence of one or more commands separated
by the control operator |. The standard output of all but
the last command is connected to the standard input of the
<br>
next command. The standard output of the last command is
inherited from the shell, as usual.</p>

<p style="margin-top: 1em">The format for a pipeline
is:</p>

<p style="margin-top: 1em">[!] command1 [| command2
...]</p>

<p style="margin-top: 1em">The standard output of command1
is connected to the standard input of command2. The standard
input, standard output, or both of a command is considered
to be assigned by the pipe&acirc; <br>
line before any redirection specified by redirection
operators that are part of the command.</p>

<p style="margin-top: 1em">If the pipeline is not in the
background (discussed later), the shell waits for all
commands to complete.</p>

<p style="margin-top: 1em">If the reserved word ! does not
precede the pipeline, the exit status is the exit status of
the last command specified in the pipeline. Otherwise, the
exit status is the logical <br>
NOT of the exit status of the last command. That is, if the
last command returns zero, the exit status is 1; if the last
command returns greater than zero, the exit status is <br>
zero.</p>

<p style="margin-top: 1em">Because pipeline assignment of
standard input or standard output or both takes place before
redirection, it can be modified by redirection. For
example:</p>

<p style="margin-top: 1em">$ command1 2&gt;&amp;1 |
command2</p>

<p style="margin-top: 1em">sends both the standard output
and standard error of command1 to the standard input of
command2.</p>

<p style="margin-top: 1em">A ; or
&acirc;&uml;newline&acirc;&copy; terminator causes the
preceding AND-OR-list (described next) to be executed
sequentially; a &amp; causes asynchronous execution of the
preceding AND-OR-list.</p>

<p style="margin-top: 1em">Note that unlike some other
shells, each process in the pipeline is a child of the
invoking shell (unless it is a shell builtin, in which case
it executes in the current shell -- <br>
but any effect it has on the environment is wiped).</p>

<p style="margin-top: 1em">Background Commands -- &amp;
<br>
If a command is terminated by the control operator ampersand
(&amp;), the shell executes the command asynchronously --
that is, the shell does not wait for the command to finish
before <br>
executing the next command.</p>

<p style="margin-top: 1em">The format for running a command
in background is:</p>

<p style="margin-top: 1em">command1 &amp; [command2 &amp;
...]</p>

<p style="margin-top: 1em">If the shell is not interactive,
the standard input of an asynchronous command is set to
/dev/null.</p>

<p style="margin-top: 1em">Lists -- Generally Speaking <br>
A list is a sequence of zero or more commands separated by
newlines, semicolons, or ampersands, and optionally
terminated by one of these three characters. The commands in
a list <br>
are executed in the order they are written. If command is
followed by an ampersand, the shell starts the command and
immediately proceed onto the next command; otherwise it
waits <br>
for the command to terminate before proceeding to the next
one.</p>

<p style="margin-top: 1em">Short-Circuit List Operators
<br>
&acirc;&amp;&amp;&acirc; and &acirc;||&acirc; are AND-OR
list operators. &acirc;&amp;&amp;&acirc; executes the first
command, and then executes the second command iff the exit
status of the first command is zero. &acirc;||&acirc; is
similar, <br>
but executes the second command iff the exit status of the
first command is nonzero. &acirc;&amp;&amp;&acirc; and
&acirc;||&acirc; both have the same priority.</p>

<p style="margin-top: 1em">Flow-Control Constructs -- if,
while, for, case <br>
The syntax of the if command is</p>

<p style="margin-top: 1em">if list <br>
then list <br>
[ elif list <br>
then list ] ... <br>
[ else list ] <br>
fi</p>

<p style="margin-top: 1em">The syntax of the while command
is</p>

<p style="margin-top: 1em">while list <br>
do list <br>
done</p>

<p style="margin-top: 1em">The two lists are executed
repeatedly while the exit status of the first list is zero.
The until command is similar, but has the word until in
place of while, which causes it to <br>
repeat until the exit status of the first list is zero.</p>

<p style="margin-top: 1em">The syntax of the for command
is</p>

<p style="margin-top: 1em">for variable [ in [ word ... ] ]
<br>
do list <br>
done</p>

<p style="margin-top: 1em">The words following in are
expanded, and then the list is executed repeatedly with the
variable set to each word in turn. Omitting in word ... is
equivalent to in &quot;$@&quot;.</p>

<p style="margin-top: 1em">The syntax of the break and
continue command is</p>

<p style="margin-top: 1em">break [ num ] <br>
continue [ num ]</p>

<p style="margin-top: 1em">Break terminates the num
innermost for or while loops. Continue continues with the
next iteration of the innermost loop. These are implemented
as builtin commands.</p>

<p style="margin-top: 1em">The syntax of the case command
is</p>

<p style="margin-top: 1em">case word in <br>
[(]pattern) list ;; <br>
... <br>
esac</p>

<p style="margin-top: 1em">The pattern can actually be one
or more patterns (see Shell Patterns described later),
separated by &acirc;|&acirc; characters. The &acirc;(&acirc;
character before the pattern is optional.</p>

<p style="margin-top: 1em">Grouping Commands Together <br>
Commands may be grouped by writing either</p>

<p style="margin-top: 1em">(list)</p>

<p style="margin-top: 1em">or</p>

<p style="margin-top: 1em">{ list; }</p>

<p style="margin-top: 1em">The first of these executes the
commands in a subshell. Builtin commands grouped into a
(list) will not affect the current shell. The second form
does not fork another shell so <br>
is slightly more efficient. Grouping commands together this
way allows you to redirect their output as though they were
one program:</p>

<p style="margin-top: 1em">{ printf &quot; hello &quot; ;
printf &quot; world0 ; } &gt; greeting</p>

<p style="margin-top: 1em">Note that &acirc;}&acirc; must
follow a control operator (here, &acirc;;&acirc;) so that it
is recognized as a reserved word and not as another command
argument.</p>

<p style="margin-top: 1em">Functions <br>
The syntax of a function definition is</p>

<p style="margin-top: 1em">name () command</p>

<p style="margin-top: 1em">A function definition is an
executable statement; when executed it installs a function
named name and returns an exit status of zero. The command
is normally a list enclosed <br>
between &acirc;{&acirc; and &acirc;}&acirc;.</p>

<p style="margin-top: 1em">Variables may be declared to be
local to a function by using a local command. This should
appear as the first statement of a function, and the syntax
is</p>

<p style="margin-top: 1em">local [variable | -] ...</p>

<p style="margin-top: 1em">Local is implemented as a
builtin command.</p>

<p style="margin-top: 1em">When a variable is made local,
it inherits the initial value and exported and readonly
flags from the variable with the same name in the
surrounding scope, if there is one. Other&acirc; <br>
wise, the variable is initially unset. The shell uses
dynamic scoping, so that if you make the variable x local to
function f, which then calls function g, references to the
vari&acirc; <br>
able x made inside g will refer to the variable x declared
inside f, not to the global variable named x.</p>

<p style="margin-top: 1em">The only special parameter that
can be made local is &acirc;-&acirc;. Making &acirc;-&acirc;
local any shell options that are changed via the set command
inside the function to be restored to their orig&acirc; <br>
inal values when the function returns.</p>

<p style="margin-top: 1em">The syntax of the return command
is</p>

<p style="margin-top: 1em">return [exitstatus]</p>

<p style="margin-top: 1em">It terminates the currently
executing function. Return is implemented as a builtin
command.</p>

<p style="margin-top: 1em">Variables and Parameters <br>
The shell maintains a set of parameters. A parameter denoted
by a name is called a variable. When starting up, the shell
turns all the environment variables into shell variables.
<br>
New variables can be set using the form</p>

<p style="margin-top: 1em">name=value</p>

<p style="margin-top: 1em">Variables set by the user must
have a name consisting solely of alphabetics, numerics, and
underscores - the first of which must not be numeric. A
parameter can also be denoted by <br>
a number or a special character as explained below.</p>

<p style="margin-top: 1em">Positional Parameters <br>
A positional parameter is a parameter denoted by a number (n
&gt; 0). The shell sets these initially to the values of its
command line arguments that follow the name of the shell
<br>
script. The set builtin can also be used to set or reset
them.</p>

<p style="margin-top: 1em">Special Parameters <br>
A special parameter is a parameter denoted by one of the
following special characters. The value of the parameter is
listed next to its character.</p>

<p style="margin-top: 1em">* Expands to the positional
parameters, starting from one. When the expansion occurs
within a double-quoted string it expands to a single field
with the value of each <br>
parameter separated by the first character of the IFS
variable, or by a &acirc;&uml;space&acirc;&copy; if IFS is
unset.</p>

<p style="margin-top: 1em">@ Expands to the positional
parameters, starting from one. When the expansion occurs
within double-quotes, each positional parameter expands as a
separate argument. If <br>
there are no positional parameters, the expansion of @
generates zero arguments, even when @ is double-quoted. What
this basically means, for example, is if $1 is <br>
&acirc;abc&acirc; and $2 is &acirc;def ghi&acirc;, then
&quot;$@&quot; expands to the two arguments:</p>

<p style="margin-top: 1em">&quot;abc&quot; &quot;def
ghi&quot;</p>

<p style="margin-top: 1em"># Expands to the number of
positional parameters.</p>

<p style="margin-top: 1em">? Expands to the exit status of
the most recent pipeline.</p>

<p style="margin-top: 1em">- (Hyphen.) Expands to the
current option flags (the single-letter option names
concatenated into a string) as specified on invocation, by
the set builtin command, or implicitly <br>
by the shell.</p>

<p style="margin-top: 1em">$ Expands to the process ID of
the invoked shell. A subshell retains the same value of $ as
its parent.</p>

<p style="margin-top: 1em">! Expands to the process ID of
the most recent background command executed from the current
shell. For a pipeline, the process ID is that of the last
command in the <br>
pipeline.</p>

<p style="margin-top: 1em">0 (Zero.) Expands to the name of
the shell or shell script.</p>

<p style="margin-top: 1em">Word Expansions <br>
This clause describes the various expansions that are
performed on words. Not all expansions are performed on
every word, as explained later.</p>

<p style="margin-top: 1em">Tilde expansions, parameter
expansions, command substitutions, arithmetic expansions,
and quote removals that occur within a single word expand to
a single field. It is only field <br>
splitting or pathname expansion that can create multiple
fields from a single word. The single exception to this rule
is the expansion of the special parameter @ within double-
<br>
quotes, as was described above.</p>

<p style="margin-top: 1em">The order of word expansion
is:</p>

<p style="margin-top: 1em">1. Tilde Expansion, Parameter
Expansion, Command Substitution, Arithmetic Expansion (these
all occur at the same time).</p>

<p style="margin-top: 1em">2. Field Splitting is performed
on fields generated by step (1) unless the IFS variable is
null.</p>

<p style="margin-top: 1em">3. Pathname Expansion (unless
set -f is in effect).</p>

<p style="margin-top: 1em">4. Quote Removal.</p>

<p style="margin-top: 1em">The $ character is used to
introduce parameter expansion, command substitution, or
arithmetic evaluation.</p>

<p style="margin-top: 1em">Tilde Expansion (substituting a
user&rsquo;s home directory) <br>
A word beginning with an unquoted tilde character (~) is
subjected to tilde expansion. All the characters up to a
slash (/) or the end of the word are treated as a username
and <br>
are replaced with the user&rsquo;s home directory. If the
username is missing (as in ~/foobar), the tilde is replaced
with the value of the HOME variable (the current
user&rsquo;s home direc&acirc; <br>
tory).</p>

<p style="margin-top: 1em">Parameter Expansion <br>
The format for parameter expansion is as follows:</p>

<p style="margin-top: 1em">${expression}</p>

<p style="margin-top: 1em">where expression consists of all
characters until the matching &acirc;}&acirc;. Any
&acirc;}&acirc; escaped by a backslash or within a quoted
string, and characters in embedded arithmetic expansions,
<br>
command substitutions, and variable expansions, are not
examined in determining the matching &acirc;}&acirc;.</p>

<p style="margin-top: 1em">The simplest form for parameter
expansion is:</p>

<p style="margin-top: 1em">${parameter}</p>

<p style="margin-top: 1em">The value, if any, of parameter
is substituted.</p>

<p style="margin-top: 1em">The parameter name or symbol can
be enclosed in braces, which are optional except for
positional parameters with more than one digit or when
parameter is followed by a character <br>
that could be interpreted as part of the name. If a
parameter expansion occurs inside double-quotes:</p>

<p style="margin-top: 1em">1. Pathname expansion is not
performed on the results of the expansion.</p>

<p style="margin-top: 1em">2. Field splitting is not
performed on the results of the expansion, with the
exception of @.</p>

<p style="margin-top: 1em">In addition, a parameter
expansion can be modified by using one of the following
formats.</p>

<p style="margin-top: 1em">${parameter:-word} Use Default
Values. If parameter is unset or null, the expansion of word
is substituted; otherwise, the value of parameter is
substituted.</p>

<p style="margin-top: 1em">${parameter:=word} Assign
Default Values. If parameter is unset or null, the expansion
of word is assigned to parameter. In all cases, the final
value of parameter is substi&acirc; <br>
tuted. Only variables, not positional parameters or special
parameters, can be assigned in this way.</p>

<p style="margin-top: 1em">${parameter:?[word]} Indicate
Error if Null or Unset. If parameter is unset or null, the
expansion of word (or a message indicating it is unset if
word is omitted) is written to <br>
standard error and the shell exits with a nonzero exit
status. Otherwise, the value of parameter is substituted. An
interactive shell need not exit.</p>

<p style="margin-top: 1em">${parameter:+word} Use
Alternative Value. If parameter is unset or null, null is
substituted; otherwise, the expansion of word is
substituted.</p>

<p style="margin-top: 1em">In the parameter expansions
shown previously, use of the colon in the format results in
a test for a parameter that is unset or null; omission of
the colon results in a test for a <br>
parameter that is only unset.</p>

<p style="margin-top: 1em">${#parameter} String Length. The
length in characters of the value of parameter.</p>

<p style="margin-top: 1em">The following four varieties of
parameter expansion provide for substring processing. In
each case, pattern matching notation (see Shell Patterns),
rather than regular expression <br>
notation, is used to evaluate the patterns. If parameter is
* or @, the result of the expansion is unspecified.
Enclosing the full parameter expansion string in
double-quotes <br>
does not cause the following four varieties of pattern
characters to be quoted, whereas quoting characters within
the braces has this effect.</p>

<p style="margin-top: 1em">${parameter%word} Remove
Smallest Suffix Pattern. The word is expanded to produce a
pattern. The parameter expansion then results in parameter,
with the smallest portion of <br>
the suffix matched by the pattern deleted.</p>

<p style="margin-top: 1em">${parameter%%word} Remove
Largest Suffix Pattern. The word is expanded to produce a
pattern. The parameter expansion then results in parameter,
with the largest portion of the <br>
suffix matched by the pattern deleted.</p>

<p style="margin-top: 1em">${parameter#word} Remove
Smallest Prefix Pattern. The word is expanded to produce a
pattern. The parameter expansion then results in parameter,
with the smallest portion of <br>
the prefix matched by the pattern deleted.</p>

<p style="margin-top: 1em">${parameter##word} Remove
Largest Prefix Pattern. The word is expanded to produce a
pattern. The parameter expansion then results in parameter,
with the largest portion of the <br>
prefix matched by the pattern deleted.</p>

<p style="margin-top: 1em">Command Substitution <br>
Command substitution allows the output of a command to be
substituted in place of the command name itself. Command
substitution occurs when the command is enclosed as
follows:</p>

<p style="margin-top: 1em">$(command)</p>

<p style="margin-top: 1em">or (&acirc;backquoted&acirc;
version):</p>

<p style="margin-top: 1em">&lsquo;command&lsquo;</p>

<p style="margin-top: 1em">The shell expands the command
substitution by executing command in a subshell environment
and replacing the command substitution with the standard
output of the command, removing <br>
sequences of one or more &acirc;&uml;newline&acirc;&copy;s
at the end of the substitution. (Embedded
&acirc;&uml;newline&acirc;&copy;s before the end of the
output are not removed; however, during field splitting,
they may be <br>
translated into &acirc;&uml;space&acirc;&copy;s, depending
on the value of IFS and quoting that is in effect.)</p>

<p style="margin-top: 1em">Arithmetic Expansion <br>
Arithmetic expansion provides a mechanism for evaluating an
arithmetic expression and substituting its value. The format
for arithmetic expansion is as follows:</p>

<p style="margin-top: 1em">$((expression))</p>

<p style="margin-top: 1em">The expression is treated as if
it were in double-quotes, except that a double-quote inside
the expression is not treated specially. The shell expands
all tokens in the expression <br>
for parameter expansion, command substitution, and quote
removal.</p>

<p style="margin-top: 1em">Next, the shell treats this as
an arithmetic expression and substitutes the value of the
expression.</p>

<p style="margin-top: 1em">White Space Splitting (Field
Splitting) <br>
After parameter expansion, command substitution, and
arithmetic expansion the shell scans the results of
expansions and substitutions that did not occur in
double-quotes for field <br>
splitting and multiple fields can result.</p>

<p style="margin-top: 1em">The shell treats each character
of the IFS as a delimiter and uses the delimiters to split
the results of parameter expansion and command substitution
into fields.</p>

<p style="margin-top: 1em">Pathname Expansion (File Name
Generation) <br>
Unless the -f flag is set, file name generation is performed
after word splitting is complete. Each word is viewed as a
series of patterns, separated by slashes. The process of
<br>
expansion replaces the word with the names of all existing
files whose names can be formed by replacing each pattern
with a string that matches the specified pattern. There are
<br>
two restrictions on this: first, a pattern cannot match a
string containing a slash, and second, a pattern cannot
match a string starting with a period unless the first
character <br>
of the pattern is a period. The next section describes the
patterns used for both Pathname Expansion and the case
command.</p>

<p style="margin-top: 1em">Shell Patterns <br>
A pattern consists of normal characters, which match
themselves, and meta-characters. The meta-characters are
&acirc;!&acirc;, &acirc;*&acirc;, &acirc;?&acirc;, and
&acirc;[&acirc;. These characters lose their special
meanings <br>
if they are quoted. When command or variable substitution is
performed and the dollar sign or back quotes are not double
quoted, the value of the variable or the output of the <br>
command is scanned for these characters and they are turned
into meta-characters.</p>

<p style="margin-top: 1em">An asterisk (&acirc;*&acirc;)
matches any string of characters. A question mark matches
any single character. A left bracket (&acirc;[&acirc;)
introduces a character class. The end of the character <br>
class is indicated by a (&acirc;]&acirc;); if the
&acirc;]&acirc; is missing then the &acirc;[&acirc; matches
a &acirc;[&acirc; rather than introducing a character class.
A character class matches any of the characters between <br>
the square brackets. A range of characters may be specified
using a minus sign. The character class may be complemented
by making an exclamation point the first character of the
<br>
character class.</p>

<p style="margin-top: 1em">To include a &acirc;]&acirc; in
a character class, make it the first character listed (after
the &acirc;!&acirc;, if any). To include a minus sign, make
it the first or last character listed.</p>

<p style="margin-top: 1em">Builtins <br>
This section lists the builtin commands which are builtin
because they need to perform some operation that can&rsquo;t
be performed by a separate process. In addition to these,
there <br>
are several other commands that may be builtin for
efficiency (e.g. printf(1), echo(1), test(1), etc).</p>

<p style="margin-top: 1em">:</p>

<p style="margin-top: 1em">true A null command that returns
a 0 (true) exit value.</p>

<p style="margin-top: 1em">. file <br>
The commands in the specified file are read and executed by
the shell.</p>

<p style="margin-top: 1em">alias [name[=string ...]] <br>
If name=string is specified, the shell defines the alias
name with value string. If just name is specified, the value
of the alias name is printed. With no arguments, the <br>
alias builtin prints the names and values of all defined
aliases (see unalias).</p>

<p style="margin-top: 1em">bg [job] ... <br>
Continue the specified jobs (or the current job if no jobs
are given) in the background.</p>

<p style="margin-top: 1em">command [-p] [-v] [-V] command
[arg ...] <br>
Execute the specified command but ignore shell functions
when searching for it. (This is useful when you have a shell
function with the same name as a builtin command.)</p>

<p style="margin-top: 1em">-p search for command using a
PATH that guarantees to find all the standard utilities.</p>

<p style="margin-top: 1em">-V Do not execute the command
but search for the command and print the resolution of the
command search. This is the same as the type builtin.</p>

<p style="margin-top: 1em">-v Do not execute the command
but search for the command and print the absolute pathname
of utilities, the name for builtins or the expansion of
aliases.</p>

<p style="margin-top: 1em">cd -</p>

<p style="margin-top: 1em">cd [-LP] [directory] <br>
Switch to the specified directory (default HOME). If an
entry for CDPATH appears in the environment of the cd
command or the shell variable CDPATH is set and the
directory <br>
name does not begin with a slash, then the directories
listed in CDPATH will be searched for the specified
directory. The format of CDPATH is the same as that of PATH.
If <br>
a single dash is specified as the argument, it will be
replaced by the value of OLDPWD. The cd command will print
out the name of the directory that it actually switched to
<br>
if this is different from the name that the user gave. These
may be different either because the CDPATH mechanism was
used or because the argument is a single dash. The -P <br>
option causes the physical directory structure to be used,
that is, all symbolic links are resolved to their respective
values. The -L option turns off the effect of any <br>
preceding -P options.</p>

<p style="margin-top: 1em">echo [-n] args... <br>
Print the arguments on the standard output, separated by
spaces. Unless the -n option is present, a newline is output
following the arguments.</p>

<p style="margin-top: 1em">If any of the following
sequences of characters is encountered during output, the
sequence is not output. Instead, the specified action is
performed:</p>

<p style="margin-top: 1em">A backspace character is
output.</p>

<p style="margin-top: 1em">Output a form feed.</p>

<p style="margin-top: 1em">Output a newline character.</p>

<p style="margin-top: 1em">Output a carriage return.</p>

<p style="margin-top: 1em">Output a (horizontal) tab
character.</p>

<p style="margin-top: 1em">Output a vertical tab.</p>

<p style="margin-top: 1em">digits <br>
Output the character whose value is given by zero to three
octal digits. If there are zero digits, a nul character is
output.</p>

<p style="margin-top: 1em">\ Output a backslash.</p>

<p style="margin-top: 1em">All other backslash sequences
elicit undefined behaviour.</p>

<p style="margin-top: 1em">eval string ... <br>
Concatenate all the arguments with spaces. Then re-parse and
execute the command.</p>

<p style="margin-top: 1em">exec [command arg ...] <br>
Unless command is omitted, the shell process is replaced
with the specified program (which must be a real program,
not a shell builtin or function). Any redirections on the
<br>
exec command are marked as permanent, so that they are not
undone when the exec command finishes.</p>

<p style="margin-top: 1em">exit [exitstatus] <br>
Terminate the shell process. If exitstatus is given it is
used as the exit status of the shell; otherwise the exit
status of the preceding command is used.</p>

<p style="margin-top: 1em">export name ...</p>

<p style="margin-top: 1em">export -p <br>
The specified names are exported so that they will appear in
the environment of subsequent commands. The only way to
un-export a variable is to unset it. The shell allows <br>
the value of a variable to be set at the same time it is
exported by writing</p>

<p style="margin-top: 1em">export name=value</p>

<p style="margin-top: 1em">With no arguments the export
command lists the names of all exported variables. With the
-p option specified the output will be formatted suitably
for non-interactive use.</p>

<p style="margin-top: 1em">fc [-e editor] [first
[last]]</p>

<p style="margin-top: 1em">fc -l [-nr] [first [last]]</p>

<p style="margin-top: 1em">fc -s [old=new] [first] <br>
The fc builtin lists, or edits and re-executes, commands
previously entered to an interactive shell.</p>

<p style="margin-top: 1em">-e editor <br>
Use the editor named by editor to edit the commands. The
editor string is a command name, subject to search via the
PATH variable. The value in the FCEDIT variable <br>
is used as a default when -e is not specified. If FCEDIT is
null or unset, the value of the EDITOR variable is used. If
EDITOR is null or unset, ed(1) is used as <br>
the editor.</p>

<p style="margin-top: 1em">-l (ell) <br>
List the commands rather than invoking an editor on them.
The commands are written in the sequence indicated by the
first and last operands, as affected by -r, with <br>
each command preceded by the command number.</p>

<p style="margin-top: 1em">-n Suppress command numbers when
listing with -l.</p>

<p style="margin-top: 1em">-r Reverse the order of the
commands listed (with -l) or edited (with neither -l nor
-s).</p>

<p style="margin-top: 1em">-s Re-execute the command
without invoking an editor.</p>

<p style="margin-top: 1em">first</p>

<p style="margin-top: 1em">last Select the commands to list
or edit. The number of previous commands that can be
accessed are determined by the value of the HISTSIZE
variable. The value of first <br>
or last or both are one of the following:</p>

<p style="margin-top: 1em">[+]number <br>
A positive number representing a command number; command
numbers can be displayed with the -l option.</p>

<p style="margin-top: 1em">-number <br>
A negative decimal number representing the command that was
executed number of commands previously. For example, -1 is
the immediately previous command.</p>

<p style="margin-top: 1em">string <br>
A string indicating the most recently entered command that
begins with that string. If the old=new operand is not also
specified with -s, the string form of the <br>
first operand cannot contain an embedded equal sign.</p>

<p style="margin-top: 1em">The following environment
variables affect the execution of fc:</p>

<p style="margin-top: 1em">FCEDIT Name of the editor to
use.</p>

<p style="margin-top: 1em">HISTSIZE The number of previous
commands that are accessible.</p>

<p style="margin-top: 1em">fg [job] <br>
Move the specified job or the current job to the
foreground.</p>

<p style="margin-top: 1em">getopts optstring var <br>
The POSIX getopts command, not to be confused with the Bell
Labs -derived getopt(1).</p>

<p style="margin-top: 1em">The first argument should be a
series of letters, each of which may be optionally followed
by a colon to indicate that the option requires an argument.
The variable speci&acirc; <br>
fied is set to the parsed option.</p>

<p style="margin-top: 1em">The getopts command deprecates
the older getopt(1) utility due to its handling of arguments
containing whitespace.</p>

<p style="margin-top: 1em">The getopts builtin may be used
to obtain options and their arguments from a list of
parameters. When invoked, getopts places the value of the
next option from the option <br>
string in the list in the shell variable specified by var
and its index in the shell variable OPTIND. When the shell
is invoked, OPTIND is initialized to 1. For each <br>
option that requires an argument, the getopts builtin will
place it in the shell variable OPTARG. If an option is not
allowed for in the optstring, then OPTARG will be <br>
unset.</p>

<p style="margin-top: 1em">optstring is a string of
recognized option letters (see getopt(3)). If a letter is
followed by a colon, the option is expected to have an
argument which may or may not be <br>
separated from it by white space. If an option character is
not found where expected, getopts will set the variable var
to a &acirc;?&acirc;; getopts will then unset OPTARG and
write <br>
output to standard error. By specifying a colon as the first
character of optstring all errors will be ignored.</p>

<p style="margin-top: 1em">A nonzero value is returned when
the last option is reached. If there are no remaining
arguments, getopts will set var to the special option,
&acirc;--&acirc;, otherwise, it will set <br>
var to &acirc;?&acirc;.</p>

<p style="margin-top: 1em">The following code fragment
shows how one might process the arguments for a command that
can take the options [a] and [b], and the option [c], which
requires an argument.</p>

<p style="margin-top: 1em">while getopts abc: f <br>
do <br>
case $f in <br>
a | b) flag=$f;; <br>
c) carg=$OPTARG;; <br>
esac <br>
done <br>
shift &lsquo;expr $OPTIND - 1&lsquo;</p>

<p style="margin-top: 1em">This code will accept any of the
following as equivalent:</p>

<p style="margin-top: 1em">cmd -acarg file file <br>
cmd -a -c arg file file <br>
cmd -carg -a file file <br>
cmd -a -carg -- file file</p>

<p style="margin-top: 1em">hash -rv command ... <br>
The shell maintains a hash table which remembers the
locations of commands. With no arguments whatsoever, the
hash command prints out the contents of this table. Entries
<br>
which have not been looked at since the last cd command are
marked with an asterisk; it is possible for these entries to
be invalid.</p>

<p style="margin-top: 1em">With arguments, the hash command
removes the specified commands from the hash table (unless
they are functions) and then locates them. With the -v
option, hash prints the <br>
locations of the commands as it finds them. The -r option
causes the hash command to delete all the entries in the
hash table except for functions.</p>

<p style="margin-top: 1em">pwd [-LP] <br>
builtin command remembers what the current directory is
rather than recomputing it each time. This makes it faster.
However, if the current directory is renamed, the <br>
builtin version of pwd will continue to print the old name
for the directory. The -P option causes the physical value
of the current working directory to be shown, that is, <br>
all symbolic links are resolved to their respective values.
The -L option turns off the effect of any preceding -P
options.</p>

<p style="margin-top: 1em">read [-p prompt] [-r] variable
[...] <br>
The prompt is printed if the -p option is specified and the
standard input is a terminal. Then a line is read from the
standard input. The trailing newline is deleted from <br>
the line and the line is split as described in the section
on word splitting above, and the pieces are assigned to the
variables in order. At least one variable must be <br>
specified. If there are more pieces than variables, the
remaining pieces (along with the characters in IFS that
separated them) are assigned to the last variable. If there
<br>
are more variables than pieces, the remaining variables are
assigned the null string. The read builtin will indicate
success unless EOF is encountered on input, in which <br>
case failure is returned.</p>

<p style="margin-top: 1em">By default, unless the -r option
is specified, the backslash &acirc;&acirc; acts as an escape
character, causing the following character to be treated
literally. If a backslash is <br>
followed by a newline, the backslash and the newline will be
deleted.</p>

<p style="margin-top: 1em">readonly name ...</p>

<p style="margin-top: 1em">readonly -p <br>
The specified names are marked as read only, so that they
cannot be subsequently modified or unset. The shell allows
the value of a variable to be set at the same time it <br>
is marked read only by writing</p>

<p style="margin-top: 1em">readonly name=value</p>

<p style="margin-top: 1em">With no arguments the readonly
command lists the names of all read only variables. With the
-p option specified the output will be formatted suitably
for non-interactive <br>
use.</p>

<p style="margin-top: 1em">printf format [arguments ...]
<br>
printf formats and prints its arguments, after the first,
under control of the format. The format is a character
string which contains three types of objects: plain
charac&acirc; <br>
ters, which are simply copied to standard output, character
escape sequences which are converted and copied to the
standard output, and format specifications, each of which
<br>
causes printing of the next successive argument.</p>

<p style="margin-top: 1em">The arguments after the first
are treated as strings if the corresponding format is either
b, c or s; otherwise it is evaluated as a C constant, with
the following exten&acirc; <br>
sions:</p>

<p style="margin-top: 1em">&Acirc;&middot; A leading plus
or minus sign is allowed. <br>
&Acirc;&middot; If the leading character is a single or
double quote, the value is the ASCII code of the next
character.</p>

<p style="margin-top: 1em">The format string is reused as
often as necessary to satisfy the arguments. Any extra
format specifications are evaluated with zero or the null
string.</p>

<p style="margin-top: 1em">Character escape sequences are
in backslash notation as defined in ANSI X3.159-1989
(&acirc;ANSI C89&acirc;). The characters and their meanings
are as follows:</p>

<p style="margin-top: 1em">Write a &lt;bell&gt;
character.</p>

<p style="margin-top: 1em">Write a &lt;backspace&gt;
character.</p>

<p style="margin-top: 1em">Write a &lt;form-feed&gt;
character.</p>

<p style="margin-top: 1em">Write a &lt;new-line&gt;
character.</p>

<p style="margin-top: 1em">Write a &lt;carriage return&gt;
character.</p>

<p style="margin-top: 1em">Write a &lt;tab&gt;
character.</p>

<p style="margin-top: 1em">Write a &lt;vertical tab&gt;
character.</p>

<p style="margin-top: 1em">\ Write a backslash
character.</p>

<p style="margin-top: 1em">0m Write an 8-bit character
whose ASCII value is the 1-, 2-, or 3-digit octal number
num.</p>

<p style="margin-top: 1em">Each format specification is
introduced by the percent character
(&lsquo;&lsquo;%&rsquo;&rsquo;). The remainder of the format
specification includes, in the following order:</p>

<p style="margin-top: 1em">Zero or more of the following
flags:</p>

<p style="margin-top: 1em"># A &lsquo;#&rsquo; character
specifying that the value should be printed in an
&lsquo;&lsquo;alternative form&rsquo;&rsquo;. For b, c, d,
and s formats, this option has no effect. For the o <br>
format the precision of the number is increased to force the
first character of the output string to a zero. For the x
(X) format, a non-zero result has the <br>
string 0x (0X) prepended to it. For e, E, f, g, and G
formats, the result will always contain a decimal point,
even if no digits follow the point (normally, <br>
a decimal point only appears in the results of those formats
if a digit follows the decimal point). For g and G formats,
trailing zeros are not removed from <br>
the result as they would otherwise be.</p>

<p style="margin-top: 1em">- A minus sign &lsquo;-&rsquo;
which specifies left adjustment of the output in the
indicated field;</p>

<p style="margin-top: 1em">+ A &lsquo;+&rsquo; character
specifying that there should always be a sign placed before
the number when using signed formats.</p>

<p style="margin-top: 1em">&acirc; &acirc; A space
specifying that a blank should be left before a positive
number for a signed format. A &lsquo;+&rsquo; overrides a
space if both are used;</p>

<p style="margin-top: 1em">0 A zero &lsquo;0&rsquo;
character indicating that zero-padding should be used rather
than blank-padding. A &lsquo;-&rsquo; overrides a
&lsquo;0&rsquo; if both are used;</p>

<p style="margin-top: 1em">Field Width: <br>
An optional digit string specifying a field width; if the
output string has fewer characters than the field width it
will be blank-padded on the left (or right, if <br>
the left-adjustment indicator has been given) to make up the
field width (note that a leading zero is a flag, but an
embedded zero is part of a field width);</p>

<p style="margin-top: 1em">Precision: <br>
An optional period, &acirc;.&acirc;, followed by an optional
digit string giving a precision which specifies the number
of digits to appear after the decimal point, for e and f
<br>
formats, or the maximum number of bytes to be printed from a
string (b and s formats); if the digit string is missing,
the precision is treated as zero;</p>

<p style="margin-top: 1em">Format: <br>
A character which indicates the type of format to use (one
of diouxXfwEgGbcs).</p>

<p style="margin-top: 1em">A field width or precision may
be &acirc;*&acirc; instead of a digit string. In this case
an argument supplies the field width or precision.</p>

<p style="margin-top: 1em">The format characters and their
meanings are:</p>

<p style="margin-top: 1em">diouXx The argument is printed
as a signed decimal (d or i), unsigned octal, unsigned
decimal, or unsigned hexadecimal (X or x), respectively.</p>

<p style="margin-top: 1em">f The argument is printed in the
style [-]ddd.ddd where the number of d&rsquo;s after the
decimal point is equal to the precision specification for
the argument. If the <br>
precision is missing, 6 digits are given; if the precision
is explicitly 0, no digits and no decimal point are
printed.</p>

<p style="margin-top: 1em">eE The argument is printed in
the style [-]d.ddde&Acirc;&plusmn;dd where there is one
digit before the decimal point and the number after is equal
to the precision specification <br>
for the argument; when the precision is missing, 6 digits
are produced. An upper-case E is used for an &lsquo;E&rsquo;
format.</p>

<p style="margin-top: 1em">gG The argument is printed in
style f or in style e (E) whichever gives full precision in
minimum space.</p>

<p style="margin-top: 1em">b Characters from the string
argument are printed with backslash-escape sequences
expanded. <br>
The following additional backslash-escape sequences are
supported:</p>

<p style="margin-top: 1em">format operand.</p>

<p style="margin-top: 1em">num Write an 8-bit character
whose ASCII value is the 1-, 2-, or 3-digit octal number
num.</p>

<p style="margin-top: 1em">c The first character of
argument is printed.</p>

<p style="margin-top: 1em">s Characters from the string
argument are printed until the end is reached or until the
number of bytes indicated by the precision specification is
reached; if the <br>
precision is omitted, all characters in the string are
printed.</p>

<p style="margin-top: 1em">% Print a &lsquo;%&rsquo;; no
argument is used.</p>

<p style="margin-top: 1em">In no case does a non-existent
or small field width cause truncation of a field; padding
takes place only if the specified field width exceeds the
actual width.</p>

<p style="margin-top: 1em">set [{ -options | +options | --
}] arg ... <br>
The set command performs three different functions.</p>

<p style="margin-top: 1em">With no arguments, it lists the
values of all shell variables.</p>

<p style="margin-top: 1em">If options are given, it sets
the specified option flags, or clears them as described in
the section called Argument List Processing. As a special
case, if the option is -o <br>
or +o and no argument is supplied, the shell prints the
settings of all its options. If the option is -o, the
settings are printed in a human-readable format; if the
option <br>
is +o, the settings are printed in a format suitable for
reinput to the shell to affect the same option settings.</p>

<p style="margin-top: 1em">The third use of the set command
is to set the values of the shell&rsquo;s positional
parameters to the specified args. To change the positional
parameters without changing any <br>
options, use &acirc;--&acirc; as the first argument to set.
If no args are present, the set command will clear all the
positional parameters (equivalent to executing &acirc;shift
$#&acirc;.)</p>

<p style="margin-top: 1em">shift [n] <br>
Shift the positional parameters n times. A shift sets the
value of $1 to the value of $2, the value of $2 to the value
of $3, and so on, decreasing the value of $# by one. <br>
If n is greater than the number of positional parameters,
shift will issue an error message, and exit with return
status 2.</p>

<p style="margin-top: 1em">test expression</p>

<p style="margin-top: 1em">[ expression ] <br>
The test utility evaluates the expression and, if it
evaluates to true, returns a zero (true) exit status;
otherwise it returns 1 (false). If there is no expression,
test <br>
also returns 1 (false).</p>

<p style="margin-top: 1em">All operators and flags are
separate arguments to the test utility.</p>

<p style="margin-top: 1em">The following primaries are used
to construct expression:</p>

<p style="margin-top: 1em">-b file True if file exists and
is a block special file.</p>

<p style="margin-top: 1em">-c file True if file exists and
is a character special file.</p>

<p style="margin-top: 1em">-d file True if file exists and
is a directory.</p>

<p style="margin-top: 1em">-e file True if file exists
(regardless of type).</p>

<p style="margin-top: 1em">-f file True if file exists and
is a regular file.</p>

<p style="margin-top: 1em">-g file True if file exists and
its set group ID flag is set.</p>

<p style="margin-top: 1em">-h file True if file exists and
is a symbolic link.</p>

<p style="margin-top: 1em">-k file True if file exists and
its sticky bit is set.</p>

<p style="margin-top: 1em">-n string True if the length of
string is nonzero.</p>

<p style="margin-top: 1em">-p file True if file is a named
pipe (FIFO).</p>

<p style="margin-top: 1em">-r file True if file exists and
is readable.</p>

<p style="margin-top: 1em">-s file True if file exists and
has a size greater than zero.</p>

<p style="margin-top: 1em">-t file_descriptor <br>
True if the file whose file descriptor number is
file_descriptor is open and is associated with a
terminal.</p>

<p style="margin-top: 1em">-u file True if file exists and
its set user ID flag is set.</p>

<p style="margin-top: 1em">-w file True if file exists and
is writable. True indicates only that the write flag is on.
The file is not writable on a read-only file system even if
this test <br>
indicates true.</p>

<p style="margin-top: 1em">-x file True if file exists and
is executable. True indicates only that the execute flag is
on. If file is a directory, true indicates that file can be
searched.</p>

<p style="margin-top: 1em">-z string True if the length of
string is zero.</p>

<p style="margin-top: 1em">-L file True if file exists and
is a symbolic link. This operator is retained for
compatibility with previous versions of this program. Do not
rely on its existence; <br>
use -h instead.</p>

<p style="margin-top: 1em">-O file True if file exists and
its owner matches the effective user id of this process.</p>

<p style="margin-top: 1em">-G file True if file exists and
its group matches the effective group id of this
process.</p>

<p style="margin-top: 1em">-S file True if file exists and
is a socket.</p>

<p style="margin-top: 1em">file1 -nt file2 <br>
True if file1 and file2 exist and file1 is newer than
file2.</p>

<p style="margin-top: 1em">file1 -ot file2 <br>
True if file1 and file2 exist and file1 is older than
file2.</p>

<p style="margin-top: 1em">file1 -ef file2 <br>
True if file1 and file2 exist and refer to the same
file.</p>

<p style="margin-top: 1em">string True if string is not the
null string.</p>

<p style="margin-top: 1em">s1 = s2 True if the strings s1
and s2 are identical.</p>

<p style="margin-top: 1em">s1 != s2 True if the strings s1
and s2 are not identical.</p>

<p style="margin-top: 1em">s1 &lt; s2 True if string s1
comes before s2 based on the ASCII value of their
characters.</p>

<p style="margin-top: 1em">s1 &gt; s2 True if string s1
comes after s2 based on the ASCII value of their
characters.</p>

<p style="margin-top: 1em">n1 -eq n2 True if the integers
n1 and n2 are algebraically equal.</p>

<p style="margin-top: 1em">n1 -ne n2 True if the integers
n1 and n2 are not algebraically equal.</p>

<p style="margin-top: 1em">n1 -gt n2 True if the integer n1
is algebraically greater than the integer n2.</p>

<p style="margin-top: 1em">n1 -ge n2 True if the integer n1
is algebraically greater than or equal to the integer
n2.</p>

<p style="margin-top: 1em">n1 -lt n2 True if the integer n1
is algebraically less than the integer n2.</p>

<p style="margin-top: 1em">n1 -le n2 True if the integer n1
is algebraically less than or equal to the integer n2.</p>

<p style="margin-top: 1em">These primaries can be combined
with the following operators:</p>

<p style="margin-top: 1em">! expression True if expression
is false.</p>

<p style="margin-top: 1em">expression1 -a expression2 <br>
True if both expression1 and expression2 are true.</p>

<p style="margin-top: 1em">expression1 -o expression2 <br>
True if either expression1 or expression2 are true.</p>

<p style="margin-top: 1em">(expression) True if expression
is true.</p>

<p style="margin-top: 1em">The -a operator has higher
precedence than the -o operator.</p>

<p style="margin-top: 1em">times Print the accumulated user
and system times for the shell and for processes run from
the shell. The return status is 0.</p>

<p style="margin-top: 1em">trap [action signal ...] <br>
Cause the shell to parse and execute action when any of the
specified signals are received. The signals are specified by
signal number or as the name of the signal. If <br>
signal is 0 or EXIT, the action is executed when the shell
exits. action may be empty (&rsquo;&rsquo;), which causes
the specified signals to be ignored. With action omitted or
set to <br>
&lsquo;-&rsquo; the specified signals are set to their
default action. When the shell forks off a subshell, it
resets trapped (but not ignored) signals to the default
action. The trap <br>
command has no effect on signals that were ignored on entry
to the shell. trap without any arguments cause it to write a
list of signals and their associated action to the <br>
standard output in a format that is suitable as an input to
the shell that achieves the same trapping results.</p>

<p style="margin-top: 1em">Examples:</p>

<p style="margin-top: 1em">trap</p>

<p style="margin-top: 1em">List trapped signals and their
corresponding action</p>

<p style="margin-top: 1em">trap &rsquo;&rsquo; INT QUIT
tstp 30</p>

<p style="margin-top: 1em">Ignore signals INT QUIT TSTP
USR1</p>

<p style="margin-top: 1em">trap date INT</p>

<p style="margin-top: 1em">Print date upon receiving signal
INT</p>

<p style="margin-top: 1em">type [name ...] <br>
Interpret each name as a command and print the resolution of
the command search. Possible resolutions are: shell keyword,
alias, shell builtin, command, tracked alias and <br>
not found. For aliases the alias expansion is printed; for
commands and tracked aliases the complete pathname of the
command is printed.</p>

<p style="margin-top: 1em">ulimit [-H | -S] [-a |
-tfdscmlpn [value]] <br>
Inquire about or set the hard or soft limits on processes or
set new limits. The choice between hard limit (which no
process is allowed to violate, and which may not be <br>
raised once it has been lowered) and soft limit (which
causes processes to be signaled but not necessarily killed,
and which may be raised) is made with these flags:</p>

<p style="margin-top: 1em">-H set or inquire about hard
limits</p>

<p style="margin-top: 1em">-S set or inquire about soft
limits. If neither -H nor -S is specified, the soft limit is
displayed or both limits are set. If both are specified, the
last one <br>
wins.</p>

<p style="margin-top: 1em">The limit to be interrogated or
set, then, is chosen by specifying any one of these
flags:</p>

<p style="margin-top: 1em">-a show all the current
limits</p>

<p style="margin-top: 1em">-t show or set the limit on CPU
time (in seconds)</p>

<p style="margin-top: 1em">-f show or set the limit on the
largest file that can be created (in 512-byte blocks)</p>

<p style="margin-top: 1em">-d show or set the limit on the
data segment size of a process (in kilobytes)</p>

<p style="margin-top: 1em">-s show or set the limit on the
stack size of a process (in kilobytes)</p>

<p style="margin-top: 1em">-c show or set the limit on the
largest core dump size that can be produced (in 512-byte
blocks)</p>

<p style="margin-top: 1em">-m show or set the limit on the
total physical memory that can be in use by a process (in
kilobytes)</p>

<p style="margin-top: 1em">-l show or set the limit on how
much memory a process can lock with mlock(2) (in
kilobytes)</p>

<p style="margin-top: 1em">-p show or set the limit on the
number of processes this user can have at one time</p>

<p style="margin-top: 1em">-n show or set the limit on the
number files a process can have open at once</p>

<p style="margin-top: 1em">-r show or set the limit on the
real-time scheduling priority of a process</p>

<p style="margin-top: 1em">If none of these is specified,
it is the limit on file size that is shown or set. If value
is specified, the limit is set to that number; otherwise the
current limit is <br>
displayed.</p>

<p style="margin-top: 1em">Limits of an arbitrary process
can be displayed or set using the sysctl(8) utility.</p>

<p style="margin-top: 1em">umask [mask] <br>
Set the value of umask (see umask(2)) to the specified octal
value. If the argument is omitted, the umask value is
printed.</p>

<p style="margin-top: 1em">unalias [-a] [name] <br>
If name is specified, the shell removes that alias. If -a is
specified, all aliases are removed.</p>

<p style="margin-top: 1em">unset [-fv] name ... <br>
The specified variables and functions are unset and
unexported. If -f or -v is specified, the corresponding
function or variable is unset, respectively. If a given name
<br>
corresponds to both a variable and a function, and no
options are given, only the variable is unset.</p>

<p style="margin-top: 1em">wait [job] <br>
Wait for the specified job to complete and return the exit
status of the last process in the job. If the argument is
omitted, wait for all jobs to complete and return an <br>
exit status of zero.</p>

<p style="margin-top: 1em">Command Line Editing <br>
When dash is being used interactively from a terminal, the
current command and the command history (see fc in Builtins)
can be edited using vi-mode command-line editing. This mode
<br>
uses commands, described below, similar to a subset of those
described in the vi man page. The command &acirc;set -o
vi&acirc; enables vi-mode editing and place sh into vi
insert mode. With <br>
vi-mode enabled, sh can be switched between insert mode and
command mode. The editor is not described in full here, but
will be in a later document. It&rsquo;s similar to vi:
typing <br>
&acirc;&uml;ESC&acirc;&copy; will throw you into command VI
command mode. Hitting &acirc;&uml;return&acirc;&copy; while
in command mode will pass the line to the shell.</p>

<p style="margin-top: 1em">EXIT STATUS <br>
Errors that are detected by the shell, such as a syntax
error, will cause the shell to exit with a non-zero exit
status. If the shell is not an interactive shell, the
execution of <br>
the shell file will be aborted. Otherwise the shell will
return the exit status of the last command executed, or if
the exit builtin is used with a numeric argument, it will
<br>
return the argument.</p>

<p style="margin-top: 1em">ENVIRONMENT <br>
HOME Set automatically by login(1) from the user&rsquo;s
login directory in the password file (passwd(4)). This
environment variable also functions as the default argument
for the <br>
cd builtin.</p>

<p style="margin-top: 1em">PATH The default search path for
executables. See the above section Path Search.</p>

<p style="margin-top: 1em">CDPATH The search path used with
the cd builtin.</p>

<p style="margin-top: 1em">MAIL The name of a mail file,
that will be checked for the arrival of new mail. Overridden
by MAILPATH.</p>

<p style="margin-top: 1em">MAILCHECK The frequency in
seconds that the shell checks for the arrival of mail in the
files specified by the MAILPATH or the MAIL file. If set to
0, the check will occur at <br>
each prompt.</p>

<p style="margin-top: 1em">MAILPATH A colon &acirc;:&acirc;
separated list of file names, for the shell to check for
incoming mail. This environment setting overrides the MAIL
setting. There is a maximum of 10 mail&acirc; <br>
boxes that can be monitored at once.</p>

<p style="margin-top: 1em">PS1 The primary prompt string,
which defaults to &acirc;$ &acirc;, unless you are the
superuser, in which case it defaults to &acirc;#
&acirc;.</p>

<p style="margin-top: 1em">PS2 The secondary prompt string,
which defaults to &acirc;&gt; &acirc;.</p>

<p style="margin-top: 1em">PS4 Output before each line when
execution trace (set -x) is enabled, defaults to &acirc;+
&acirc;.</p>

<p style="margin-top: 1em">IFS Input Field Separators. This
is normally set to &acirc;&uml;space&acirc;&copy;,
&acirc;&uml;tab&acirc;&copy;, and
&acirc;&uml;newline&acirc;&copy;. See the White Space
Splitting section for more details.</p>

<p style="margin-top: 1em">TERM The default terminal
setting for the shell. This is inherited by children of the
shell, and is used in the history editing modes.</p>

<p style="margin-top: 1em">HISTSIZE The number of lines in
the history buffer for the shell.</p>

<p style="margin-top: 1em">PWD The logical value of the
current working directory. This is set by the cd
command.</p>

<p style="margin-top: 1em">OLDPWD The previous logical
value of the current working directory. This is set by the
cd command.</p>

<p style="margin-top: 1em">PPID The process ID of the
parent process of the shell.</p>

<p style="margin-top: 1em">FILES <br>
$HOME/.profile</p>

<p style="margin-top: 1em">/etc/profile</p>

<p style="margin-top: 1em">SEE ALSO <br>
csh(1), echo(1), getopt(1), ksh(1), login(1), printf(1),
test(1), getopt(3), passwd(5), environ(7), sysctl(8)</p>

<p style="margin-top: 1em">HISTORY <br>
dash is a POSIX-compliant implementation of /bin/sh that
aims to be as small as possible. dash is a direct descendant
of the NetBSD version of ash (the Almquist SHell), ported to
<br>
Linux in early 1997. It was renamed to dash in 2002.</p>

<p style="margin-top: 1em">BUGS <br>
Setuid shell scripts should be avoided at all costs, as they
are a significant security risk.</p>

<p style="margin-top: 1em">PS1, PS2, and PS4 should be
subject to parameter expansion before being displayed.</p>

<p style="margin-top: 1em">BSD January 19, 2003 BSD</p>
<hr>
</body>
</html>
