<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:28:12 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>OCI(1) APRIL 2016 OCI(1)</p>

<p style="margin-top: 1em">NAME <br>
ocitools-generate - Generate a config.json for an OCI
container</p>

<p style="margin-top: 1em">SYNOPSIS <br>
ocitools generate [--arch[=[]] [--apparmor[=[]]]
[--args[=[]]] [--bind[=[]]] [--cap-add[=[]]]
[--cap-drop[=[]]] [--cwd[=[]]] [--env[=[]]] [--gid[=GID]]
[--gidmappings[=[]]]] <br>
[--groups[=[]]] [--hostname[=[]]] [--help] [--ipc]
[--network] [--no-new-privileges] [--mount]
[--mount-cgroups] [--os[=[]]] [--pid] [--poststart[=[]]]
[--poststop[=[]]] <br>
[--prestart[=[]]] [--privileged] [--read-only]
[--root-propagation[=[]]] [--rootfs[=[]]]
[--seccomp-default[=[]]] [--seccomp-arch[=[]]]
[--seccomp-syscalls[=[]]] <br>
[--selinux-label[=[]]] [--sysctl[=[]]] [--tmpfs[=[]]]
[--uid[=[]]] [--uidmappings[=[]]] [--uts]</p>

<p style="margin-top: 1em">DESCRIPTION <br>
ocitools generate is used to generate a config.json (OCI
spec file) to be used to instantiate an OCI container. This
config.json file can be placed into a directory and used by
<br>
an OCI compatable runtime like runc to run a container.</p>

<p style="margin-top: 1em">OPTIONS <br>
--apparmor=&quot;PROFILE&quot; <br>
Specifies the the apparmor profile for the container</p>

<p style="margin-top: 1em">--arch=&quot;ARCH&quot; <br>
Architecture used within the container. <br>
&quot;amd64&quot;</p>

<p style="margin-top: 1em">--args=OPTION <br>
Arguments to run within the container. Can be specified
multiple times. <br>
If you were going to run a command with multiple options,
you would need to specify the command and each argument in
order.</p>

<p style="margin-top: 1em">--args
&quot;/usr/bin/httpd&quot; --args &quot;-D&quot; --args
&quot;FOREGROUND&quot;</p>


<p style="margin-top: 1em">--bind=[=[[HOST-DIR:CONTAINER-DIR][:OPTIONS]]]
Bind mount <br>
directories src:dest:(rw,ro) If you specify, --bind <br>
/HOST-DIR:/CONTAINER-DIR, runc bind mounts /HOST-DIR in the
host <br>
to /CONTAINER-DIR in the OCI container. The OPTIONS are a
comma <br>
delimited list and can be: [rw|ro] The HOST_DIR and <br>
CONTAINER-DIR must be absolute paths such as /src/docs. You
<br>
can add :ro or :rw suffix to a volume to mount it read-only
or <br>
read-write mode, respectively. By default, the volumes are
mounted <br>
read-write.</p>

<p style="margin-top: 1em">--cap-add=[] <br>
Add Linux capabilities</p>

<p style="margin-top: 1em">--cap-drop=[] <br>
Drop Linux capabilities</p>

<p style="margin-top: 1em">--cwd=PATH <br>
Current working directory for the process</p>

<p style="margin-top: 1em">--env=[] <br>
Set environment variables</p>

<p style="margin-top: 1em">This option allows you to
specify arbitrary environment variables that are available
for the process that will be launched inside of the
container.</p>

<p style="margin-top: 1em">--hostname=&quot;&quot; <br>
Container host name</p>

<p style="margin-top: 1em">Sets the container host name
that is available inside the container.</p>

<p style="margin-top: 1em">--help <br>
Print usage statement</p>

<p style="margin-top: 1em">--gid=GID <br>
Gid for the process inside of container</p>

<p style="margin-top: 1em">--groups=GROUP <br>
Supplementary groups for the processes inside of
container</p>

<p style="margin-top: 1em">--gidmappings=GIDMAPPINGS <br>
Add GIDMappings e.g HostID:ContainerID:Size for use with
User Namespace</p>

<p style="margin-top: 1em">--ipc <br>
Use ipc namespace</p>

<p style="margin-top: 1em">--network <br>
Use network namespace</p>

<p style="margin-top: 1em">--no-new-privileges <br>
Set no new privileges bit for the container process. Setting
this flag <br>
will block the container processes from gaining any
additional privileges <br>
using tools like setuid apps. It is a good idea to run
unprivileged <br>
containers with this flag.</p>

<p style="margin-top: 1em">--mount <br>
Use a mount namespace</p>

<p style="margin-top: 1em">--mount-cgroups <br>
Mount cgroups (rw,ro,no)</p>

<p style="margin-top: 1em">--os=OS <br>
Operating system used within the container</p>

<p style="margin-top: 1em">--pid <br>
Use a pid namespace</p>

<p style="margin-top: 1em">--poststart=CMD <br>
Path to command to run in poststart hooks. This command will
be run before <br>
the container process gets launched but after the container
environment and <br>
main process has been created.</p>

<p style="margin-top: 1em">--poststop=CMD <br>
Path to command to run in poststop hooks. This command will
be run after the <br>
container completes but before the container process is
destroyed</p>

<p style="margin-top: 1em">--prestart=CMD <br>
Path to command to run in prestart hooks. This command will
be run before <br>
the container process gets launched but after the container
environment.</p>

<p style="margin-top: 1em">--privileged=true|false <br>
Give extended privileges to this container. The default is
false.</p>

<p style="margin-top: 1em">By default, OCI containers are
&acirc;unprivileged&acirc; (=false) and cannot do some of
the things a normal root process can do.</p>

<p style="margin-top: 1em">When the operator executes
ocitools generate --privileged, OCI will enable access to
all devices on the host as well as disable some of the
confinement mechanisms like AppArmor, <br>
SELinux, and seccomp from blocking access to privileged
processes. This gives the container processes nearly all the
same access to the host as processes generating outside of a
<br>
container on the host.</p>

<p style="margin-top: 1em">--read-only=true|false <br>
Mount the container&rsquo;s root filesystem as read
only.</p>

<p style="margin-top: 1em">By default a container will have
its root filesystem writable allowing processes to write
files anywhere. By specifying the --read-only flag the
container will have its root <br>
filesystem mounted as read only prohibiting any writes.</p>


<p style="margin-top: 1em">--root-propagation=PROPOGATIONMODE
<br>
Mount propagation for root filesystem. <br>
Values are &quot;SHARED, RSHARED, PRIVATE, RPRIVATE, SLAVE,
RSLAVE&quot;</p>

<p style="margin-top: 1em">--rootfs=&quot;ROOTFSPATH&quot;
<br>
Path to the rootfs</p>

<p style="margin-top: 1em">--sysctl=SYSCTLSETTING <br>
Add sysctl settings e.g net.ipv4.forward=1, only allowed if
the syctl is <br>
namespaced.</p>

<p style="margin-top: 1em">--seccomp-default=ACTION <br>
Specifies the the defaultaction of Seccomp syscall
restrictions <br>
Values: KILL,ERRNO,TRACE,ALLOW</p>

<p style="margin-top: 1em">--seccomp-arch=ARCH <br>
Specifies Additional architectures permitted to be used for
system calls. <br>
By default if you turn on seccomp, only the host
architecture will be allowed.</p>

<p style="margin-top: 1em">--seccomp-syscalls=SYSCALLS <br>
Specifies Additional syscalls permitted to be used for
system calls, <br>
e.g Name:Action:Arg1_index/Arg1_value/Arg1_valuetwo/Arg1_op,
Arg2_index/Arg2_value/Arg2_valuetwo/Arg2_op</p>


<p style="margin-top: 1em">--selinux-label=[=SELINUXLABEL]]
<br>
SELinux Label <br>
Depending on your SELinux policy, you would specify a label
that looks like <br>
this: <br>
&quot;system_u:system_r:svirt_lxc_net_t:s0:c1,c2&quot;</p>

<p style="margin-top: 1em">Note you would want your ROOTFS
directory to be labeled with a context that <br>
this process type can use.</p>


<p style="margin-top: 1em">&quot;system_u:object_r:usr_t:s0&quot;
might be a good label for a readonly container, <br>
&quot;system_u:system_r:svirt_sandbox_file_t:s0:c1,c2&quot;
for a read/write container.</p>

<p style="margin-top: 1em">--tmpfs=[] Create a tmpfs mount
<br>
Mount a temporary filesystem (tmpfs) mount into a container,
for example:</p>

<p style="margin-top: 1em">$ ocitools generate -d --tmpfs
/tmp:rw,size=787448k,mode=1777 my_image</p>

<p style="margin-top: 1em">This command mounts a
&lsquo;tmpfs&lsquo; at &lsquo;/tmp&lsquo; within the
container. The supported mount options are the same as the
Linux default &lsquo;mount&lsquo; flags. If you do not
specify any options, the systems uses the following options:
<br>
&lsquo;rw,noexec,nosuid,nodev,size=65536k&lsquo;.</p>

<p style="margin-top: 1em">--uid=UID <br>
Sets the UID used within the container.</p>

<p style="margin-top: 1em">--uidmappings <br>
Add UIDMappings e.g HostUID:ContainerID:Size for use with
User Namespace</p>

<p style="margin-top: 1em">--uts <br>
Use the uts namespace</p>

<p style="margin-top: 1em">EXAMPLES Generating container in
read-only mode <br>
During container image development, containers often need to
write to the image content. Installing packages into /usr,
for example. In production, applications seldom need to <br>
write to the image. Container applications write to volumes
if they need to write to file systems at all. Applications
can be made more secure by generating them in read-only <br>
mode using the --read-only switch. This protects the
containers image from modification. Read only containers may
still need to write temporary data. The best way to handle
<br>
this is to mount tmpfs directories on /generate and
/tmp.</p>

<p style="margin-top: 1em"># ocitools generate --read-only
--tmpfs /generate --tmpfs /tmp --tmpfs /run --rootfs
/var/lib/containers/fedora /bin/bash</p>

<p style="margin-top: 1em">Exposing log messages from the
container to the host&rsquo;s log <br>
If you want messages that are logged in your container to
show up in the host&rsquo;s syslog/journal then you should
bind mount the /dev/log directory as follows.</p>

<p style="margin-top: 1em"># ocitools generate --bind
/dev/log:/dev/log --rootfs /var/lib/containers/fedora
/bin/bash</p>

<p style="margin-top: 1em">From inside the container you
can test this by sending a message to the log.</p>

<p style="margin-top: 1em">(bash)# logger &quot;Hello from
my container&quot;</p>

<p style="margin-top: 1em">Then exit and check the
journal.</p>

<p style="margin-top: 1em"># exit</p>

<p style="margin-top: 1em"># journalctl -b | grep Hello</p>

<p style="margin-top: 1em">This should list the message
sent to logger.</p>

<p style="margin-top: 1em">Bind Mounting External Volumes
<br>
To mount a host directory as a container volume, specify the
absolute path to the directory and the absolute path for the
container directory separated by a colon:</p>

<p style="margin-top: 1em"># ocitools generate --bind
/var/db:/data1 --rootfs /var/lib/containers/fedora --args
bash</p>

<p style="margin-top: 1em">Using SELinux <br>
You can use SELinux to add security to the container. You
must specify the process label to run the init process
inside of the container using the --selinux-label.</p>

<p style="margin-top: 1em"># ocitools generate --bind
/var/db:/data1 --selinux-label
system_u:system_r:svirt_lxc_net_t:s0:c1,c2 --rootfs
/var/lib/containers/fedora --args bash</p>

<p style="margin-top: 1em">Not in the above example we used
a type of svirt_lxc_net_t and an MCS Label of s0:c1,c2. If
you want to guarantee separation between containers, you
need to make sure that each <br>
container gets launched with a different MCS Label pair.</p>

<p style="margin-top: 1em">Also the underlying rootfs must
be labeled with a matching label. For the example above, you
would execute a command like:</p>

<p style="margin-top: 1em"># chcon -R
system_u:object_r:svirt_sandbox_file_t:s0:c1,c2
/var/lib/containers/fedora</p>

<p style="margin-top: 1em">This will set up the labeling of
the rootfs so that the process launched would be able to
write to the container. If you wanted to only allow it to
read/execute the content in <br>
rootfs, you could execute:</p>

<p style="margin-top: 1em"># chcon -R
system_u:object_r:usr_t:s0 /var/lib/containers/fedora</p>

<p style="margin-top: 1em">When using SELinux, be aware
that the host has no knowledge of container SELinux policy.
Therefore, in the above example, if SELinux policy is
enforced, the /var/db directory is <br>
not writable to the container. A &quot;Permission
Denied&quot; message will occur and an avc: message in the
host&rsquo;s syslog.</p>

<p style="margin-top: 1em">To work around this, the
following command needs to be generate in order for the
proper SELinux policy type label to be attached to the host
directory:</p>

<p style="margin-top: 1em"># chcon -Rt svirt_sandbox_file_t
-l s0:c1,c2 /var/db</p>

<p style="margin-top: 1em">Now, writing to the /data1
volume in the container will be allowed and the changes will
also be reflected on the host in /var/db.</p>

<p style="margin-top: 1em">SEE ALSO <br>
runc(1), ocitools(1)</p>

<p style="margin-top: 1em">HISTORY <br>
April 2016, Originally compiled by Dan Walsh (dwalsh at
redhat dot com)</p>

<p style="margin-top: 1em">OCI Community OCI User Manuals
OCI(1)</p>
<hr>
</body>
</html>
