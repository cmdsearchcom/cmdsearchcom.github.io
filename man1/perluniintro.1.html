<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>PERLUNIINTRO(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNIINTRO(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNIINTRO(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
perluniintro - Perl Unicode introduction
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document gives a general idea of Unicode and how to use Unicode in Perl.
  See &quot;Further Resources&quot; for references to more in-depth treatments
  of Unicode.
<h2 class="Ss" title="Ss" id="Unicode"><a class="selflink" href="#Unicode">Unicode</a></h2>
Unicode is a character set standard which plans to codify all of the writing
  systems of the world, plus many other symbols.
<div class="Pp"></div>
Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other
  modern character set standards, covering more than 80 writing systems and
  hundreds of languages, including all commercially-important modern languages.
  All characters in the largest Chinese, Japanese, and Korean dictionaries are
  also encoded. The standards will eventually cover almost all characters in
  more than 250 writing systems and thousands of languages. Unicode 1.0 was
  released in October 1991, and 6.0 in October 2010.
<div class="Pp"></div>
A Unicode <i>character</i> is an abstract entity. It is not bound to any
  particular integer width, especially not to the C language &quot;char&quot;.
  Unicode is language-neutral and display-neutral: it does not encode the
  language of the text, and it does not generally define fonts or other
  graphical layout details. Unicode operates on characters and on text built
  from those characters.
<div class="Pp"></div>
Unicode defines characters like &quot;LATIN CAPITAL LETTER A&quot; or
  &quot;GREEK SMALL LETTER ALPHA&quot; and unique numbers for the characters, in
  this case 0x0041 and 0x03B1, respectively. These unique numbers are called
  <i>code points</i>. A code point is essentially the position of the character
  within the set of all possible Unicode characters, and thus in Perl, the term
  <i>ordinal</i> is often used interchangeably with it.
<div class="Pp"></div>
The Unicode standard prefers using hexadecimal notation for the code points. If
  numbers like 0x0041 are unfamiliar to you, take a peek at a later section,
  &quot;Hexadecimal Notation&quot;. The Unicode standard uses the notation
  &quot;U+0041 LATIN CAPITAL LETTER A&quot;, to give the hexadecimal code point
  and the normative name of the character.
<div class="Pp"></div>
Unicode also defines various <i>properties</i> for the characters, like
  &quot;uppercase&quot; or &quot;lowercase&quot;, &quot;decimal digit&quot;, or
  &quot;punctuation&quot;; these properties are independent of the names of the
  characters. Furthermore, various operations on the characters like
  uppercasing, lowercasing, and collating (sorting) are defined.
<div class="Pp"></div>
A Unicode <i>logical</i> &quot;character&quot; can actually consist of more than
  one internal <i>actual</i> &quot;character&quot; or code point. For Western
  languages, this is adequately modelled by a <i>base character</i> (like
  &quot;LATIN CAPITAL LETTER A&quot;) followed by one or more <i>modifiers</i>
  (like &quot;COMBINING ACUTE ACCENT&quot;). This sequence of base character and
  modifiers is called a <i>combining character</i> <i>sequence</i>. Some
  non-western languages require more complicated models, so Unicode created the
  <i>grapheme cluster</i> concept, which was later further refined into the
  <i>extended grapheme cluster</i>. For example, a Korean Hangul syllable is
  considered a single logical character, but most often consists of three actual
  Unicode characters: a leading consonant followed by an interior vowel followed
  by a trailing consonant.
<div class="Pp"></div>
Whether to call these extended grapheme clusters &quot;characters&quot; depends
  on your point of view. If you are a programmer, you probably would tend
  towards seeing each element in the sequences as one unit, or
  &quot;character&quot;. However from the user's point of view, the whole
  sequence could be seen as one &quot;character&quot; since that's probably what
  it looks like in the context of the user's language. In this document, we take
  the programmer's point of view: one &quot;character&quot; is one Unicode code
  point.
<div class="Pp"></div>
For some combinations of base character and modifiers, there are
  <i>precomposed</i> characters. There is a single character equivalent, for
  example, to the sequence &quot;LATIN CAPITAL LETTER A&quot; followed by
  &quot;COMBINING ACUTE ACCENT&quot;. It is called &quot;LATIN CAPITAL LETTER A
  WITH ACUTE&quot;. These precomposed characters are, however, only available
  for some combinations, and are mainly meant to support round-trip conversions
  between Unicode and legacy standards (like ISO 8859). Using sequences, as
  Unicode does, allows for needing fewer basic building blocks (code points) to
  express many more potential grapheme clusters. To support conversion between
  equivalent forms, various <i>normalization</i> <i>forms</i> are also defined.
  Thus, &quot;LATIN CAPITAL LETTER A WITH ACUTE&quot; is in <i>Normalization
  Form Composed</i>, (abbreviated NFC), and the sequence &quot;LATIN CAPITAL
  LETTER A&quot; followed by &quot;COMBINING ACUTE ACCENT&quot; represents the
  same character in <i>Normalization Form Decomposed</i> (NFD).
<div class="Pp"></div>
Because of backward compatibility with legacy encodings, the &quot;a unique
  number for every character&quot; idea breaks down a bit: instead, there is
  &quot;at least one number for every character&quot;. The same character could
  be represented differently in several legacy encodings. The converse is not
  also true: some code points do not have an assigned character. Firstly, there
  are unallocated code points within otherwise used blocks. Secondly, there are
  special Unicode control characters that do not represent true characters.
<div class="Pp"></div>
When Unicode was first conceived, it was thought that all the world's characters
  could be represented using a 16-bit word; that is a maximum of 0x10000 (or
  65536) characters from 0x0000 to 0xFFFF would be needed. This soon proved to
  be false, and since Unicode 2.0 (July 1996), Unicode has been defined all the
  way up to 21 bits (0x10FFFF), and Unicode 3.1 (March 2001) defined the first
  characters above 0xFFFF. The first 0x10000 characters are called the <i>Plane
  0</i>, or the <i>Basic Multilingual Plane</i> (BMP). With Unicode 3.1, 17
  (yes, seventeen) planes in all were defined--but they are nowhere near full of
  defined characters, yet.
<div class="Pp"></div>
When a new language is being encoded, Unicode generally will choose a
  &quot;block&quot; of consecutive unallocated code points for its characters.
  So far, the number of code points in these blocks has always been evenly
  divisible by 16. Extras in a block, not currently needed, are left
  unallocated, for future growth. But there have been occasions when a later
  relase needed more code points than the available extras, and a new block had
  to allocated somewhere else, not contiguous to the initial one, to handle the
  overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an
  adequate organizing principal, and so the &quot;Script&quot; property was
  created. (Later an improved script property was added as well, the
  &quot;Script_Extensions&quot; property.) Those code points that are in
  overflow blocks can still have the same script as the original ones. The
  script concept fits more closely with natural language: there is
  &quot;Latin&quot; script, &quot;Greek&quot; script, and so on; and there are
  several artificial scripts, like &quot;Common&quot; for characters that are
  used in multiple scripts, such as mathematical symbols. Scripts usually span
  varied parts of several blocks. For more information about scripts, see
  &quot;Scripts&quot; in perlunicode. The division into blocks exists, but it is
  almost completely accidental--an artifact of how the characters have been and
  still are allocated. (Note that this paragraph has oversimplified things for
  the sake of this being an introduction. Unicode doesn't really encode
  languages, but the writing systems for them--their scripts; and one script can
  be used by many languages. Unicode also encodes things that aren't really
  about languages, such as symbols like &quot;BAGGAGE CLAIM&quot;.)
<div class="Pp"></div>
The Unicode code points are just abstract numbers. To input and output these
  abstract numbers, the numbers must be <i>encoded</i> or <i>serialised</i>
  somehow. Unicode defines several <i>character encoding</i> <i>forms</i>, of
  which <i>UTF-8</i> is perhaps the most popular. UTF-8 is a variable length
  encoding that encodes Unicode characters as 1 to 6 bytes. Other encodings
  include UTF-16 and UTF-32 and their big- and little-endian variants (UTF-8 is
  byte-order independent) The ISO/IEC 10646 defines the UCS-2 and UCS-4 encoding
  forms.
<div class="Pp"></div>
For more information about encodings--for instance, to learn what
  <i>surrogates</i> and <i>byte order marks</i> (BOMs) are--see perlunicode.
<h2 class="Ss" title="Ss" id="Perl's_Unicode_Support"><a class="selflink" href="#Perl's_Unicode_Support">Perl's
  Unicode Support</a></h2>
Starting from Perl 5.6.0, Perl has had the capacity to handle Unicode natively.
  Perl 5.8.0, however, is the first recommended release for serious Unicode
  work. The maintenance release 5.6.1 fixed many of the problems of the initial
  Unicode implementation, but for example regular expressions still do not work
  with Unicode in 5.6.1. Perl 5.14.0 is the first release where Unicode support
  is (almost) seamlessly integrable without some gotchas (the exception being
  some differences in quotemeta, which is fixed starting in Perl 5.16.0). To
  enable this seamless support, you should &quot;use feature
  'unicode_strings'&quot; (which is automatically selected if you &quot;use
  5.012&quot; or higher). See feature. (5.14 also fixes a number of bugs and
  departures from the Unicode standard.)
<div class="Pp"></div>
Before Perl 5.8.0, the use of &quot;use utf8&quot; was used to declare that
  operations in the current block or file would be Unicode-aware. This model was
  found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now
  carried with the data, instead of being attached to the operations. Starting
  with Perl 5.8.0, only one case remains where an explicit &quot;use utf8&quot;
  is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8
  in your identifier names, and in string and regular expression literals, by
  saying &quot;use utf8&quot;. This is not the default because scripts with
  legacy 8-bit data in them would break. See utf8.
<h2 class="Ss" title="Ss" id="Perl's_Unicode_Model"><a class="selflink" href="#Perl's_Unicode_Model">Perl's
  Unicode Model</a></h2>
Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of
  Unicode characters. The general principle is that Perl tries to keep its data
  as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot
  be avoided, the data is transparently upgraded to Unicode. Prior to Perl 5.14,
  the upgrade was not completely transparent (see &quot;The &quot;Unicode
  Bug&quot;&quot; in perlunicode), and for backwards compatibility, full
  transparency is not gained unless &quot;use feature 'unicode_strings'&quot;
  (see feature) or &quot;use 5.012&quot; (or higher) is selected.
<div class="Pp"></div>
Internally, Perl currently uses either whatever the native eight-bit character
  set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode
  Unicode strings. Specifically, if all code points in the string are 0xFF or
  less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.
<div class="Pp"></div>
A user of Perl does not normally need to know nor care how Perl happens to
  encode its internal strings, but it becomes relevant when outputting Unicode
  strings to a stream without a PerlIO layer (one with the &quot;default&quot;
  encoding). In such a case, the raw bytes used internally (the native character
  set or UTF-8, as appropriate for each string) will be used, and a &quot;Wide
  character&quot; warning will be issued if those strings contain a character
  beyond 0x00FF.
<div class="Pp"></div>
For example,
<div class="Pp"></div>
<pre>
      perl -e 'print &quot;\x{DF}\n&quot;, &quot;\x{0100}\x{DF}\n&quot;'
</pre>
<div class="Pp"></div>
produces a fairly useless mixture of native bytes and UTF-8, as well as a
  warning:
<div class="Pp"></div>
<pre>
     Wide character in print at ...
</pre>
<div class="Pp"></div>
To output UTF-8, use the &quot;:encoding&quot; or &quot;:utf8&quot; output
  layer. Prepending
<div class="Pp"></div>
<pre>
      binmode(STDOUT, &quot;:utf8&quot;);
</pre>
<div class="Pp"></div>
to this sample program ensures that the output is completely UTF-8, and removes
  the program's warning.
<div class="Pp"></div>
You can enable automatic UTF-8-ification of your standard file handles, default
  &quot;open()&quot; layer, and @ARGV by using either the &quot;-C&quot; command
  line switch or the &quot;PERL_UNICODE&quot; environment variable, see perlrun
  for the documentation of the &quot;-C&quot; switch.
<div class="Pp"></div>
Note that this means that Perl expects other software to work the same way: if
  Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming
  in from another command is not UTF-8, Perl will likely complain about the
  malformed UTF-8.
<div class="Pp"></div>
All features that combine Unicode and I/O also require using the new PerlIO
  feature. Almost all Perl 5.8 platforms do use PerlIO, though: you can see
  whether yours is by running &quot;perl -V&quot; and looking for
  &quot;useperlio=define&quot;.
<h2 class="Ss" title="Ss" id="Unicode_and_EBCDIC"><a class="selflink" href="#Unicode_and_EBCDIC">Unicode
  and EBCDIC</a></h2>
Perl 5.8.0 also supports Unicode on EBCDIC platforms. There, Unicode support is
  somewhat more complex to implement since additional conversions are needed at
  every step.
<div class="Pp"></div>
Later Perl releases have added code that will not work on EBCDIC platforms, and
  no one has complained, so the divergence has continued. If you want to run
  Perl on an EBCDIC platform, send email to perlbug@perl.org
<div class="Pp"></div>
On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of
  UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII
  characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;.
<h2 class="Ss" title="Ss" id="Creating_Unicode"><a class="selflink" href="#Creating_Unicode">Creating
  Unicode</a></h2>
To create Unicode characters in literals for code points above 0xFF, use the
  &quot;\x{...}&quot; notation in double-quoted strings:
<div class="Pp"></div>
<pre>
    my $smiley = &quot;\x{263a}&quot;;
</pre>
<div class="Pp"></div>
Similarly, it can be used in regular expression literals
<div class="Pp"></div>
<pre>
    $smiley =~ /\x{263a}/;
</pre>
<div class="Pp"></div>
At run-time you can use &quot;chr()&quot;:
<div class="Pp"></div>
<pre>
    my $hebrew_alef = chr(0x05d0);
</pre>
<div class="Pp"></div>
See &quot;Further Resources&quot; for how to find all these numeric codes.
<div class="Pp"></div>
Naturally, &quot;ord()&quot; will do the reverse: it turns a character into a
  code point.
<div class="Pp"></div>
Note that &quot;\x..&quot; (no &quot;{}&quot; and only two hexadecimal digits),
  &quot;\x{...}&quot;, and &quot;chr(...)&quot; for arguments less than 0x100
  (decimal 256) generate an eight-bit character for backward compatibility with
  older Perls. For arguments of 0x100 or more, Unicode characters are always
  produced. If you want to force the production of Unicode characters regardless
  of the numeric value, use &quot;pack(&quot;U&quot;, ...)&quot; instead of
  &quot;\x..&quot;, &quot;\x{...}&quot;, or &quot;chr()&quot;.
<div class="Pp"></div>
You can invoke characters by name in double-quoted strings:
<div class="Pp"></div>
<pre>
    my $arabic_alef = &quot;\N{ARABIC LETTER ALEF}&quot;;
</pre>
<div class="Pp"></div>
And, as mentioned above, you can also &quot;pack()&quot; numbers into Unicode
  characters:
<div class="Pp"></div>
<pre>
   my $georgian_an  = pack(&quot;U&quot;, 0x10a0);
</pre>
<div class="Pp"></div>
Note that both &quot;\x{...}&quot; and &quot;\N{...}&quot; are compile-time
  string constants: you cannot use variables in them. if you want similar
  run-time functionality, use &quot;chr()&quot; and
  &quot;charnames::string_vianame()&quot;.
<div class="Pp"></div>
If you want to force the result to Unicode characters, use the special
  &quot;U0&quot; prefix. It consumes no arguments but causes the following bytes
  to be interpreted as the UTF-8 encoding of Unicode characters:
<div class="Pp"></div>
<pre>
   my $chars = pack(&quot;U0W*&quot;, 0x80, 0x42);
</pre>
<div class="Pp"></div>
Likewise, you can stop such UTF-8 interpretation by using the special
  &quot;C0&quot; prefix.
<h2 class="Ss" title="Ss" id="Handling_Unicode"><a class="selflink" href="#Handling_Unicode">Handling
  Unicode</a></h2>
Handling Unicode is for the most part transparent: just use the strings as
  usual. Functions like &quot;index()&quot;, &quot;length()&quot;, and
  &quot;substr()&quot; will work on the Unicode characters; regular expressions
  will work on the Unicode characters (see perlunicode and perlretut).
<div class="Pp"></div>
Note that Perl considers grapheme clusters to be separate characters, so for
  example
<div class="Pp"></div>
<pre>
 print length(&quot;\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}&quot;),
       &quot;\n&quot;;
</pre>
<div class="Pp"></div>
will print 2, not 1. The only exception is that regular expressions have
  &quot;\X&quot; for matching an extended grapheme cluster. (Thus &quot;\X&quot;
  in a regular expression would match the entire sequence of both the example
  characters.)
<div class="Pp"></div>
Life is not quite so transparent, however, when working with legacy encodings,
  I/O, and certain special cases:
<h2 class="Ss" title="Ss" id="Legacy_Encodings"><a class="selflink" href="#Legacy_Encodings">Legacy
  Encodings</a></h2>
When you combine legacy data and Unicode, the legacy data needs to be upgraded
  to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC,
  if applicable).
<div class="Pp"></div>
The &quot;Encode&quot; module knows about many encodings and has interfaces for
  doing conversions between those encodings:
<div class="Pp"></div>
<pre>
    use Encode 'decode';
    $data = decode(&quot;iso-8859-3&quot;, $data); # convert from legacy to utf-8
</pre>
<h2 class="Ss" title="Ss" id="Unicode_I/O"><a class="selflink" href="#Unicode_I/O">Unicode
  I/O</a></h2>
Normally, writing out Unicode data
<div class="Pp"></div>
<pre>
    print FH $some_string_with_unicode, &quot;\n&quot;;
</pre>
<div class="Pp"></div>
produces raw bytes that Perl happens to use to internally encode the Unicode
  string. Perl's internal encoding depends on the system as well as what
  characters happen to be in the string at the time. If any of the characters
  are at code points 0x100 or above, you will get a warning. To ensure that the
  output is explicitly rendered in the encoding you desire--and to avoid the
  warning--open the stream with the desired encoding. Some examples:
<div class="Pp"></div>
<pre>
    open FH, &quot;&gt;:utf8&quot;, &quot;file&quot;;
    open FH, &quot;&gt;:encoding(ucs2)&quot;,      &quot;file&quot;;
    open FH, &quot;&gt;:encoding(UTF-8)&quot;,     &quot;file&quot;;
    open FH, &quot;&gt;:encoding(shift_jis)&quot;, &quot;file&quot;;
</pre>
<div class="Pp"></div>
and on already open streams, use &quot;binmode()&quot;:
<div class="Pp"></div>
<pre>
    binmode(STDOUT, &quot;:utf8&quot;);
    binmode(STDOUT, &quot;:encoding(ucs2)&quot;);
    binmode(STDOUT, &quot;:encoding(UTF-8)&quot;);
    binmode(STDOUT, &quot;:encoding(shift_jis)&quot;);
</pre>
<div class="Pp"></div>
The matching of encoding names is loose: case does not matter, and many
  encodings have several aliases. Note that the &quot;:utf8&quot; layer must
  always be specified exactly like that; it is <i>not</i> subject to the loose
  matching of encoding names. Also note that currently &quot;:utf8&quot; is
  unsafe for input, because it accepts the data without validating that it is
  indeed valid UTF-8; you should instead use &quot;:encoding(utf-8)&quot; (with
  or without a hyphen).
<div class="Pp"></div>
See PerlIO for the &quot;:utf8&quot; layer, PerlIO::encoding and Encode::PerlIO
  for the &quot;:encoding()&quot; layer, and Encode::Supported for many
  encodings supported by the &quot;Encode&quot; module.
<div class="Pp"></div>
Reading in a file that you know happens to be encoded in one of the Unicode or
  legacy encodings does not magically turn the data into Unicode in Perl's eyes.
  To do that, specify the appropriate layer when opening files
<div class="Pp"></div>
<pre>
    open(my $fh,'&lt;:encoding(utf8)', 'anything');
    my $line_of_unicode = &lt;$fh&gt;;
    open(my $fh,'&lt;:encoding(Big5)', 'anything');
    my $line_of_unicode = &lt;$fh&gt;;
</pre>
<div class="Pp"></div>
The I/O layers can also be specified more flexibly with the &quot;open&quot;
  pragma. See open, or look at the following example.
<div class="Pp"></div>
<pre>
    use open ':encoding(utf8)'; # input/output default encoding will be
                                # UTF-8
    open X, &quot;&gt;file&quot;;
    print X chr(0x100), &quot;\n&quot;;
    close X;
    open Y, &quot;&lt;file&quot;;
    printf &quot;%#x\n&quot;, ord(&lt;Y&gt;); # this should print 0x100
    close Y;
</pre>
<div class="Pp"></div>
With the &quot;open&quot; pragma you can use the &quot;:locale&quot; layer
<div class="Pp"></div>
<pre>
    BEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }
    # the :locale will probe the locale environment variables like
    # LC_ALL
    use open OUT =&gt; ':locale'; # russki parusski
    open(O, &quot;&gt;koi8&quot;);
    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
    close O;
    open(I, &quot;&lt;koi8&quot;);
    printf &quot;%#x\n&quot;, ord(&lt;I&gt;), &quot;\n&quot;; # this should print 0xc1
    close I;
</pre>
<div class="Pp"></div>
These methods install a transparent filter on the I/O stream that converts data
  from the specified encoding when it is read in from the stream. The result is
  always Unicode.
<div class="Pp"></div>
The open pragma affects all the &quot;open()&quot; calls after the pragma by
  setting default layers. If you want to affect only certain streams, use
  explicit layers directly in the &quot;open()&quot; call.
<div class="Pp"></div>
You can switch encodings on an already opened stream by using
  &quot;binmode()&quot;; see &quot;binmode&quot; in perlfunc.
<div class="Pp"></div>
The &quot;:locale&quot; does not currently (as of Perl 5.8.0) work with
  &quot;open()&quot; and &quot;binmode()&quot;, only with the &quot;open&quot;
  pragma. The &quot;:utf8&quot; and &quot;:encoding(...)&quot; methods do work
  with all of &quot;open()&quot;, &quot;binmode()&quot;, and the
  &quot;open&quot; pragma.
<div class="Pp"></div>
Similarly, you may use these I/O layers on output streams to automatically
  convert Unicode to the specified encoding when it is written to the stream.
  For example, the following snippet copies the contents of the file
  &quot;text.jis&quot; (encoded as ISO-2022-JP, aka JIS) to the file
  &quot;text.utf8&quot;, encoded as UTF-8:
<div class="Pp"></div>
<pre>
    open(my $nihongo, '&lt;:encoding(iso-2022-jp)', 'text.jis');
    open(my $unicode, '&gt;:utf8',                  'text.utf8');
    while (&lt;$nihongo&gt;) { print $unicode $_ }
</pre>
<div class="Pp"></div>
The naming of encodings, both by the &quot;open()&quot; and by the
  &quot;open&quot; pragma allows for flexible names: &quot;koi8-r&quot; and
  &quot;KOI8R&quot; will both be understood.
<div class="Pp"></div>
Common encodings recognized by ISO, MIME, IANA, and various other
  standardisation organisations are recognised; for a more detailed list see
  Encode::Supported.
<div class="Pp"></div>
&quot;read()&quot; reads characters and returns the number of characters.
  &quot;seek()&quot; and &quot;tell()&quot; operate on byte counts, as do
  &quot;sysread()&quot; and &quot;sysseek()&quot;.
<div class="Pp"></div>
Notice that because of the default behaviour of not doing any conversion upon
  input if there is no default layer, it is easy to mistakenly write code that
  keeps on expanding a file by repeatedly encoding the data:
<div class="Pp"></div>
<pre>
    # BAD CODE WARNING
    open F, &quot;file&quot;;
    local $/; ## read in the whole file of 8-bit characters
    $t = &lt;F&gt;;
    close F;
    open F, &quot;&gt;:encoding(utf8)&quot;, &quot;file&quot;;
    print F $t; ## convert to UTF-8 on output
    close F;
</pre>
<div class="Pp"></div>
If you run this code twice, the contents of the <i>file</i> will be twice UTF-8
  encoded. A &quot;use open ':encoding(utf8)'&quot; would have avoided the bug,
  or explicitly opening also the <i>file</i> for input as UTF-8.
<div class="Pp"></div>
<b>NOTE</b>: the &quot;:utf8&quot; and &quot;:encoding&quot; features work only
  if your Perl has been built with the new PerlIO feature (which is the default
  on most systems).
<h2 class="Ss" title="Ss" id="Displaying_Unicode_As_Text"><a class="selflink" href="#Displaying_Unicode_As_Text">Displaying
  Unicode As Text</a></h2>
Sometimes you might want to display Perl scalars containing Unicode as simple
  ASCII (or EBCDIC) text. The following subroutine converts its argument so that
  Unicode characters with code points greater than 255 are displayed as
  &quot;\x{...}&quot;, control characters (like &quot;\n&quot;) are displayed as
  &quot;\x..&quot;, and the rest of the characters as themselves:
<div class="Pp"></div>
<pre>
 sub nice_string {
     join(&quot;&quot;,
       map { $_ &gt; 255 ?                  # if wide character...
              sprintf(&quot;\\x{%04X}&quot;, $_) :  # \x{...}
              chr($_) =~ /[[:cntrl:]]/ ?  # else if control character...
              sprintf(&quot;\\x%02X&quot;, $_) :    # \x..
              quotemeta(chr($_))          # else quoted or as themselves
         } unpack(&quot;W*&quot;, $_[0]));           # unpack Unicode characters
   }
</pre>
<div class="Pp"></div>
For example,
<div class="Pp"></div>
<pre>
   nice_string(&quot;foo\x{100}bar\n&quot;)
</pre>
<div class="Pp"></div>
returns the string
<div class="Pp"></div>
<pre>
   'foo\x{0100}bar\x0A'
</pre>
<div class="Pp"></div>
which is ready to be printed.
<h2 class="Ss" title="Ss" id="Special_Cases"><a class="selflink" href="#Special_Cases">Special
  Cases</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Bit Complement Operator ~ And <i>vec()</i>
    <div style="height: 1.00em;">&#x00A0;</div>
    The bit complement operator &quot;~&quot; may produce surprising results if
      used on strings containing characters with ordinal values above 255. In
      such a case, the results are consistent with the internal encoding of the
      characters, but not with much else. So don't do that. Similarly for
      &quot;vec()&quot;: you will be operating on the internally-encoded bit
      patterns of the Unicode characters, not on the code point values, which is
      very probably not what you want.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Peeking At Perl's Internal Encoding
    <div style="height: 1.00em;">&#x00A0;</div>
    Normal users of Perl should never care how Perl encodes any particular
      Unicode string (because the normal ways to get at the contents of a string
      with Unicode--via input and output--should always be via
      explicitly-defined I/O layers). But if you must, there are two ways of
      looking behind the scenes.
    <div style="height: 1.00em;">&#x00A0;</div>
    One way of peeking inside the internal encoding of Unicode characters is to
      use &quot;unpack(&quot;C*&quot;, ...&quot; to get the bytes of whatever
      the string encoding happens to be, or &quot;unpack(&quot;U0..&quot;,
      ...)&quot; to get the bytes of the UTF-8 encoding:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    # this prints  c4 80  for the UTF-8 bytes 0xc4 0x80
    print join(&quot; &quot;, unpack(&quot;U0(H2)*&quot;, pack(&quot;U&quot;, 0x100))), &quot;\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Yet another way would be to use the Devel::Peek module:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    perl -MDevel::Peek -e 'Dump(chr(0x100))'
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    That shows the &quot;UTF8&quot; flag in FLAGS and both the UTF-8 bytes and
      Unicode characters in &quot;PV&quot;. See also later in this document the
      discussion about the &quot;utf8::is_utf8()&quot; function.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Advanced_Topics"><a class="selflink" href="#Advanced_Topics">Advanced
  Topics</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">String Equivalence
    <div style="height: 1.00em;">&#x00A0;</div>
    The question of string equivalence turns somewhat complicated in Unicode:
      what do you mean by &quot;equal&quot;?
    <div style="height: 1.00em;">&#x00A0;</div>
    (Is &quot;LATIN CAPITAL LETTER A WITH ACUTE&quot; equal to &quot;LATIN
      CAPITAL LETTER A&quot;?)
    <div style="height: 1.00em;">&#x00A0;</div>
    The short answer is that by default Perl compares equivalence
      (&quot;eq&quot;, &quot;ne&quot;) based only on code points of the
      characters. In the above case, the answer is no (because 0x00C1 !=
      0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal,
      or even A's of any case.
    <div style="height: 1.00em;">&#x00A0;</div>
    The long answer is that you need to consider character normalization and
      casing issues: see Unicode::Normalize, Unicode Technical Report #15,
      Unicode Normalization Forms
      &lt;http://www.unicode.org/unicode/reports/tr15&gt; and sections on case
      mapping in the Unicode Standard &lt;http://www.unicode.org&gt;.
    <div style="height: 1.00em;">&#x00A0;</div>
    As of Perl 5.8.0, the &quot;Full&quot; case-folding of <i>Case</i>
      <i>Mappings/SpecialCasing</i> is implemented, but bugs remain in
      &quot;qr//i&quot; with them, mostly fixed by 5.14.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">String Collation
    <div style="height: 1.00em;">&#x00A0;</div>
    People like to see their strings nicely sorted--or as Unicode parlance goes,
      collated. But again, what do you mean by collate?
    <div style="height: 1.00em;">&#x00A0;</div>
    (Does &quot;LATIN CAPITAL LETTER A WITH ACUTE&quot; come before or after
      &quot;LATIN CAPITAL LETTER A WITH GRAVE&quot;?)
    <div style="height: 1.00em;">&#x00A0;</div>
    The short answer is that by default, Perl compares strings (&quot;lt&quot;,
      &quot;le&quot;, &quot;cmp&quot;, &quot;ge&quot;, &quot;gt&quot;) based
      only on the code points of the characters. In the above case, the answer
      is &quot;after&quot;, since 0x00C1 &gt; 0x00C0.
    <div style="height: 1.00em;">&#x00A0;</div>
    The long answer is that &quot;it depends&quot;, and a good answer cannot be
      given without knowing (at the very least) the language context. See
      Unicode::Collate, and <i>Unicode Collation Algorithm</i>
      &lt;http://www.unicode.org/unicode/reports/tr10/&gt;</dd>
</dl>
<h2 class="Ss" title="Ss" id="Miscellaneous"><a class="selflink" href="#Miscellaneous">Miscellaneous</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Character Ranges and Classes
    <div style="height: 1.00em;">&#x00A0;</div>
    Character ranges in regular expression bracketed character classes ( e.g.,
      &quot;/[a-z]/&quot;) and in the &quot;tr///&quot; (also known as
      &quot;y///&quot;) operator are not magically Unicode-aware. What this
      means is that &quot;[A-Za-z]&quot; will not magically start to mean
      &quot;all alphabetic letters&quot; (not that it does mean that even for
      8-bit characters; for those, if you are using locales (perllocale), use
      &quot;/[[:alpha:]]/&quot;; and if not, use the 8-bit-aware property
      &quot;\p{alpha}&quot;).
    <div style="height: 1.00em;">&#x00A0;</div>
    All the properties that begin with &quot;\p&quot; (and its inverse
      &quot;\P&quot;) are actually character classes that are Unicode-aware.
      There are dozens of them, see perluniprops.
    <div style="height: 1.00em;">&#x00A0;</div>
    You can use Unicode code points as the end points of character ranges, and
      the range will include all Unicode code points that lie between those end
      points.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">String-To-Number Conversions
    <div style="height: 1.00em;">&#x00A0;</div>
    Unicode does define several other decimal--and numeric--characters besides
      the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not
      support string-to-number conversion for digits other than ASCII 0 to 9
      (and ASCII a to f for hexadecimal). To get safe conversions from any
      Unicode string, use &quot; <i>num()</i>&quot; in Unicode::UCD.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Questions_With_Answers"><a class="selflink" href="#Questions_With_Answers">Questions
  With Answers</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Will My Old Scripts Break?
    <div style="height: 1.00em;">&#x00A0;</div>
    Very probably not. Unless you are generating Unicode characters somehow, old
      behaviour should be preserved. About the only behaviour that has changed
      and which could start generating Unicode is the old behaviour of
      &quot;chr()&quot; where supplying an argument more than 255 produced a
      character modulo 255. &quot;chr(300)&quot;, for example, was equal to
      &quot;chr(45)&quot; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL
      LETTER I WITH BREVE.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Do I Make My Scripts Work With Unicode?
    <div style="height: 1.00em;">&#x00A0;</div>
    Very little work should be needed since nothing changes until you generate
      Unicode data. The most important thing is getting input as Unicode; for
      that, see the earlier I/O discussion. To get full seamless Unicode
      support, add &quot;use feature 'unicode_strings'&quot; (or &quot;use
      5.012&quot; or higher) to your script.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Do I Know Whether My String Is In Unicode?
    <div style="height: 1.00em;">&#x00A0;</div>
    You shouldn't have to care. But you may if your Perl is before 5.14.0 or you
      haven't specified &quot;use feature 'unicode_strings'&quot; or &quot;use
      5.012&quot; (or higher) because otherwise the semantics of the code points
      in the range 128 to 255 are different depending on whether the string they
      are contained within is in Unicode or not. (See &quot;When Unicode Does
      Not Happen&quot; in perlunicode.)
    <div style="height: 1.00em;">&#x00A0;</div>
    To determine if a string is in Unicode, use:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    print utf8::is_utf8($string) ? 1 : 0, &quot;\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    But note that this doesn't mean that any of the characters in the string are
      necessary UTF-8 encoded, or that any of the characters have code points
      greater than 0xFF (255) or even 0x80 (128), or that the string has any
      characters at all. All the &quot;is_utf8()&quot; does is to return the
      value of the internal &quot;utf8ness&quot; flag attached to the $string.
      If the flag is off, the bytes in the scalar are interpreted as a single
      byte encoding. If the flag is on, the bytes in the scalar are interpreted
      as the (variable-length, potentially multi-byte) UTF-8 encoded code points
      of the characters. Bytes added to a UTF-8 encoded string are automatically
      upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged
      (double-quoted interpolation, explicit concatenation, or printf/sprintf
      parameter substitution), the result will be UTF-8 encoded as if copies of
      the byte strings were upgraded to UTF-8: for example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $a = &quot;ab\x80c&quot;;
    $b = &quot;\x{100}&quot;;
    print &quot;$a = $b\n&quot;;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    the output string will be UTF-8-encoded &quot;ab\x80c = \x{100}\n&quot;, but
      $a will stay byte-encoded.
    <div style="height: 1.00em;">&#x00A0;</div>
    Sometimes you might really need to know the byte length of a string instead
      of the character length. For that use either the
      &quot;Encode::encode_utf8()&quot; function or the &quot;bytes&quot; pragma
      and the &quot;length()&quot; function:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    my $unicode = chr(0x100);
    print length($unicode), &quot;\n&quot;; # will print 1
    require Encode;
    print length(Encode::encode_utf8($unicode)),&quot;\n&quot;; # will print 2
    use bytes;
    print length($unicode), &quot;\n&quot;; # will also print 2
                                  # (the 0xC4 0x80 of the UTF-8)
    no bytes;
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Do I Find Out What Encoding a File Has?
    <div style="height: 1.00em;">&#x00A0;</div>
    You might try Encode::Guess, but it has a number of limitations.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Do I Detect Data That's Not Valid In a Particular
      Encoding?
    <div style="height: 1.00em;">&#x00A0;</div>
    Use the &quot;Encode&quot; package to try converting it. For example,
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use Encode 'decode_utf8';
    if (eval { decode_utf8($string, Encode::FB_CROAK); 1 }) {
        # $string is valid utf8
    } else {
        # $string is not valid utf8
    }
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    Or use &quot;unpack&quot; to try decoding it:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use warnings;
    @chars = unpack(&quot;C0U*&quot;, $string_of_bytes_that_I_think_is_utf8);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If invalid, a &quot;Malformed UTF-8 character&quot; warning is produced. The
      &quot;C0&quot; means &quot;process the string character per
      character&quot;. Without that, the &quot;unpack(&quot;U*&quot;, ...)&quot;
      would work in &quot;U0&quot; mode (the default if the format string starts
      with &quot;U&quot;) and it would return the bytes making up the UTF-8
      encoding of the target string, something that will always work.</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Do I Convert Binary Data Into a Particular Encoding, Or
      Vice Versa?
    <div style="height: 1.00em;">&#x00A0;</div>
    This probably isn't as useful as you might think. Normally, you shouldn't
      need to.
    <div style="height: 1.00em;">&#x00A0;</div>
    In one sense, what you are asking doesn't make much sense: encodings are for
      characters, and binary data are not &quot;characters&quot;, so converting
      &quot;data&quot; into some encoding isn't meaningful unless you know in
      what character set and encoding the binary data is in, in which case it's
      not just binary data, now is it?
    <div style="height: 1.00em;">&#x00A0;</div>
    If you have a raw sequence of bytes that you know should be interpreted via
      a particular encoding, you can use &quot;Encode&quot;:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use Encode 'from_to';
    from_to($data, &quot;iso-8859-1&quot;, &quot;utf-8&quot;); # from latin-1 to utf-8
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The call to &quot;from_to()&quot; changes the bytes in $data, but nothing
      material about the nature of the string has changed as far as Perl is
      concerned. Both before and after the call, the string $data contains just
      a bunch of 8-bit bytes. As far as Perl is concerned, the encoding of the
      string remains as &quot;system-native 8-bit bytes&quot;.
    <div style="height: 1.00em;">&#x00A0;</div>
    You might relate this to a fictional 'Translate' module:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
   use Translate;
   my $phrase = &quot;Yes&quot;;
   Translate::from_to($phrase, 'english', 'deutsch');
   ## phrase now contains &quot;Ja&quot;
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    The contents of the string changes, but not the nature of the string. Perl
      doesn't know any more after the call than before that the contents of the
      string indicates the affirmative.
    <div style="height: 1.00em;">&#x00A0;</div>
    Back to converting data. If you have (or want) data in your system's native
      8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to
      convert to/from Unicode.
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $native_string  = pack(&quot;W*&quot;, unpack(&quot;U*&quot;, $Unicode_string));
    $Unicode_string = pack(&quot;U*&quot;, unpack(&quot;W*&quot;, $native_string));
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    If you have a sequence of bytes you <b>know</b> is valid UTF-8, but Perl
      doesn't know it yet, you can make Perl a believer, too:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use Encode 'decode_utf8';
    $Unicode = decode_utf8($bytes);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    or:
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $Unicode = pack(&quot;U0a*&quot;, $bytes);
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    You can find the bytes that make up a UTF-8 sequence with
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    @bytes = unpack(&quot;C*&quot;, $Unicode_string)
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    and you can create well-formed Unicode with
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    $Unicode_string = pack(&quot;U*&quot;, 0xff, ...)
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Do I Display Unicode? How Do I Input Unicode?
    <div style="height: 1.00em;">&#x00A0;</div>
    See &lt;http://www.alanwood.net/unicode/&gt; and
      &lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">How Does Unicode Work With Traditional Locales?
    <div style="height: 1.00em;">&#x00A0;</div>
    Starting in Perl 5.16, you can specify
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use locale ':not_characters';
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    to get Perl to work well with tradtional locales. The catch is that you have
      to translate from the locale character set to/from Unicode yourself. See
      &quot;Unicode I/O&quot; above for how to
    <div style="height: 1.00em;">&#x00A0;</div>
    <pre>
    use open ':locale';
    </pre>
    <div style="height: 1.00em;">&#x00A0;</div>
    to accomplish this, but full details are in &quot;Unicode and UTF-8&quot; in
      perllocale, including gotchas that happen if you don't specifiy
      &quot;:not_characters&quot;.</dd>
</dl>
<h2 class="Ss" title="Ss" id="Hexadecimal_Notation"><a class="selflink" href="#Hexadecimal_Notation">Hexadecimal
  Notation</a></h2>
The Unicode standard prefers using hexadecimal notation because that more
  clearly shows the division of Unicode into blocks of 256 characters.
  Hexadecimal is also simply shorter than decimal. You can use decimal notation,
  too, but learning to use hexadecimal just makes life easier with the Unicode
  standard. The &quot;U+HHHH&quot; notation uses hexadecimal, for example.
<div class="Pp"></div>
The &quot;0x&quot; prefix means a hexadecimal number, the digits are 0-9
  <i>and</i> a-f (or A-F, case doesn't matter). Each hexadecimal digit
  represents four bits, or half a byte. &quot;print 0x..., &quot;\n&quot;&quot;
  will show a hexadecimal number in decimal, and &quot;printf &quot;%x\n&quot;,
  $decimal&quot; will show a decimal number in hexadecimal. If you have just the
  &quot;hex digits&quot; of a hexadecimal number, you can use the
  &quot;hex()&quot; function.
<div class="Pp"></div>
<pre>
    print 0x0009, &quot;\n&quot;;    # 9
    print 0x000a, &quot;\n&quot;;    # 10
    print 0x000f, &quot;\n&quot;;    # 15
    print 0x0010, &quot;\n&quot;;    # 16
    print 0x0011, &quot;\n&quot;;    # 17
    print 0x0100, &quot;\n&quot;;    # 256
    print 0x0041, &quot;\n&quot;;    # 65
    printf &quot;%x\n&quot;,  65;    # 41
    printf &quot;%#x\n&quot;, 65;    # 0x41
    print hex(&quot;41&quot;), &quot;\n&quot;; # 65
</pre>
<h2 class="Ss" title="Ss" id="Further_Resources"><a class="selflink" href="#Further_Resources">Further
  Resources</a></h2>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unicode Consortium
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.unicode.org/&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unicode FAQ
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.unicode.org/unicode/faq/&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unicode Glossary
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.unicode.org/glossary/&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unicode Recommended Reading List
    <div style="height: 1.00em;">&#x00A0;</div>
    The Unicode Consortium has a list of articles and books, some of which give
      a much more in depth treatment of Unicode:
      &lt;http://unicode.org/resources/readinglist.html&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unicode Useful Resources
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.unicode.org/unicode/onlinedat/resources.html&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Unicode and Multilingual Support in HTML, Fonts, Web
      Browsers and Other Applications
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.alanwood.net/unicode/&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">UTF-8 and Unicode FAQ for Unix/Linux
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">Legacy Character Sets
    <div style="height: 1.00em;">&#x00A0;</div>
    &lt;http://www.czyborra.com/&gt; &lt;http://www.eki.ee/letter/&gt;</dd>
</dl>
<dl class="Bl-tag">
  <dt class="It-tag">&#x2022;</dt>
  <dd class="It-tag">You can explore various information from the Unicode data
      files using the &quot;Unicode::UCD&quot; module.</dd>
</dl>
<h1 class="Sh" title="Sh" id="UNICODE_IN_OLDER_PERLS"><a class="selflink" href="#UNICODE_IN_OLDER_PERLS">UNICODE
  IN OLDER PERLS</a></h1>
If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode
  processing by using the modules &quot;Unicode::String&quot;,
  &quot;Unicode::Map8&quot;, and &quot;Unicode::Map&quot;, available from CPAN.
  If you have the GNU recode installed, you can also use the Perl front-end
  &quot;Convert::Recode&quot; for character conversions.
<div class="Pp"></div>
The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8
  bytes and back, the code works even with older Perl 5 versions.
<div class="Pp"></div>
<pre>
    # ISO 8859-1 to UTF-8
    s/([\x80-\xFF])/chr(0xC0|ord($1)&gt;&gt;6).chr(0x80|ord($1)&amp;0x3F)/eg;
    # UTF-8 to ISO 8859-1
    s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)&lt;&lt;6&amp;0xC0|ord($2)&amp;0x3F)/eg;
</pre>
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunitut, perlunicode, Encode, open, utf8, bytes, perlretut, perlrun,
  Unicode::Collate, Unicode::Normalize, Unicode::UCD
<h1 class="Sh" title="Sh" id="ACKNOWLEDGMENTS"><a class="selflink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org,
  linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their
  valuable feedback.
<h1 class="Sh" title="Sh" id="AUTHOR,_COPYRIGHT,_AND_LICENSE"><a class="selflink" href="#AUTHOR,_COPYRIGHT,_AND_LICENSE">AUTHOR,
  COPYRIGHT, AND LICENSE</a></h1>
Copyright 2001-2011 Jarkko Hietaniemi &lt;jhi@iki.fi&gt;
<div class="Pp"></div>
This document may be distributed under the same terms as Perl itself.</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-04</td>
    <td class="foot-os">perl v5.16.3</td>
  </tr>
</table>
</body>
</html>
