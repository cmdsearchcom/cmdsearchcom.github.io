<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:31:13 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PERLUNIINTRO(1) Perl Programmers Reference Guide
PERLUNIINTRO(1)</p>

<p style="margin-top: 1em">NAME <br>
perluniintro - Perl Unicode introduction</p>

<p style="margin-top: 1em">DESCRIPTION <br>
This document gives a general idea of Unicode and how to use
Unicode in Perl. See &quot;Further Resources&quot; for
references to more in-depth treatments of Unicode.</p>

<p style="margin-top: 1em">Unicode <br>
Unicode is a character set standard which plans to codify
all of the writing systems of the world, plus many other
symbols.</p>

<p style="margin-top: 1em">Unicode and ISO/IEC 10646 are
coordinated standards that unify almost all other modern
character set standards, covering more than 80 writing
systems and hundreds of languages, <br>
including all commercially-important modern languages. All
characters in the largest Chinese, Japanese, and Korean
dictionaries are also encoded. The standards will eventually
<br>
cover almost all characters in more than 250 writing systems
and thousands of languages. Unicode 1.0 was released in
October 1991, and 6.0 in October 2010.</p>

<p style="margin-top: 1em">A Unicode character is an
abstract entity. It is not bound to any particular integer
width, especially not to the C language &quot;char&quot;.
Unicode is language-neutral and display- <br>
neutral: it does not encode the language of the text, and it
does not generally define fonts or other graphical layout
details. Unicode operates on characters and on text built
<br>
from those characters.</p>

<p style="margin-top: 1em">Unicode defines characters like
&quot;LATIN CAPITAL LETTER A&quot; or &quot;GREEK SMALL
LETTER ALPHA&quot; and unique numbers for the characters, in
this case 0x0041 and 0x03B1, respectively. These <br>
unique numbers are called code points. A code point is
essentially the position of the character within the set of
all possible Unicode characters, and thus in Perl, the term
<br>
ordinal is often used interchangeably with it.</p>

<p style="margin-top: 1em">The Unicode standard prefers
using hexadecimal notation for the code points. If numbers
like 0x0041 are unfamiliar to you, take a peek at a later
section, &quot;Hexadecimal <br>
Notation&quot;. The Unicode standard uses the notation
&quot;U+0041 LATIN CAPITAL LETTER A&quot;, to give the
hexadecimal code point and the normative name of the
character.</p>

<p style="margin-top: 1em">Unicode also defines various
properties for the characters, like &quot;uppercase&quot; or
&quot;lowercase&quot;, &quot;decimal digit&quot;, or
&quot;punctuation&quot;; these properties are independent of
the names of <br>
the characters. Furthermore, various operations on the
characters like uppercasing, lowercasing, and collating
(sorting) are defined.</p>

<p style="margin-top: 1em">A Unicode logical
&quot;character&quot; can actually consist of more than one
internal actual &quot;character&quot; or code point. For
Western languages, this is adequately modelled by a base
<br>
character (like &quot;LATIN CAPITAL LETTER A&quot;) followed
by one or more modifiers (like &quot;COMBINING ACUTE
ACCENT&quot;). This sequence of base character and modifiers
is called a combining <br>
character sequence. Some non-western languages require more
complicated models, so Unicode created the grapheme cluster
concept, which was later further refined into the <br>
extended grapheme cluster. For example, a Korean Hangul
syllable is considered a single logical character, but most
often consists of three actual Unicode characters: a leading
<br>
consonant followed by an interior vowel followed by a
trailing consonant.</p>

<p style="margin-top: 1em">Whether to call these extended
grapheme clusters &quot;characters&quot; depends on your
point of view. If you are a programmer, you probably would
tend towards seeing each element in the <br>
sequences as one unit, or &quot;character&quot;. However
from the user&rsquo;s point of view, the whole sequence
could be seen as one &quot;character&quot; since
that&rsquo;s probably what it looks like in the <br>
context of the user&rsquo;s language. In this document, we
take the programmer&rsquo;s point of view: one
&quot;character&quot; is one Unicode code point.</p>

<p style="margin-top: 1em">For some combinations of base
character and modifiers, there are precomposed characters.
There is a single character equivalent, for example, to the
sequence &quot;LATIN CAPITAL <br>
LETTER A&quot; followed by &quot;COMBINING ACUTE
ACCENT&quot;. It is called &quot;LATIN CAPITAL LETTER A WITH
ACUTE&quot;. These precomposed characters are, however, only
available for some <br>
combinations, and are mainly meant to support round-trip
conversions between Unicode and legacy standards (like ISO
8859). Using sequences, as Unicode does, allows for needing
<br>
fewer basic building blocks (code points) to express many
more potential grapheme clusters. To support conversion
between equivalent forms, various normalization forms are
also <br>
defined. Thus, &quot;LATIN CAPITAL LETTER A WITH ACUTE&quot;
is in Normalization Form Composed, (abbreviated NFC), and
the sequence &quot;LATIN CAPITAL LETTER A&quot; followed by
&quot;COMBINING ACUTE <br>
ACCENT&quot; represents the same character in Normalization
Form Decomposed (NFD).</p>

<p style="margin-top: 1em">Because of backward
compatibility with legacy encodings, the &quot;a unique
number for every character&quot; idea breaks down a bit:
instead, there is &quot;at least one number for every <br>
character&quot;. The same character could be represented
differently in several legacy encodings. The converse is not
also true: some code points do not have an assigned
character. <br>
Firstly, there are unallocated code points within otherwise
used blocks. Secondly, there are special Unicode control
characters that do not represent true characters.</p>

<p style="margin-top: 1em">When Unicode was first
conceived, it was thought that all the world&rsquo;s
characters could be represented using a 16-bit word; that is
a maximum of 0x10000 (or 65536) characters from <br>
0x0000 to 0xFFFF would be needed. This soon proved to be
false, and since Unicode 2.0 (July 1996), Unicode has been
defined all the way up to 21 bits (0x10FFFF), and Unicode
3.1 <br>
(March 2001) defined the first characters above 0xFFFF. The
first 0x10000 characters are called the Plane 0, or the
Basic Multilingual Plane (BMP). With Unicode 3.1, 17 (yes,
<br>
seventeen) planes in all were defined--but they are nowhere
near full of defined characters, yet.</p>

<p style="margin-top: 1em">When a new language is being
encoded, Unicode generally will choose a &quot;block&quot;
of consecutive unallocated code points for its characters.
So far, the number of code points in <br>
these blocks has always been evenly divisible by 16. Extras
in a block, not currently needed, are left unallocated, for
future growth. But there have been occasions when a <br>
later relase needed more code points than the available
extras, and a new block had to allocated somewhere else, not
contiguous to the initial one, to handle the overflow. Thus,
<br>
it became apparent early on that &quot;block&quot;
wasn&rsquo;t an adequate organizing principal, and so the
&quot;Script&quot; property was created. (Later an improved
script property was added as well, <br>
the &quot;Script_Extensions&quot; property.) Those code
points that are in overflow blocks can still have the same
script as the original ones. The script concept fits more
closely with <br>
natural language: there is &quot;Latin&quot; script,
&quot;Greek&quot; script, and so on; and there are several
artificial scripts, like &quot;Common&quot; for characters
that are used in multiple scripts, <br>
such as mathematical symbols. Scripts usually span varied
parts of several blocks. For more information about scripts,
see &quot;Scripts&quot; in perlunicode. The division into
blocks <br>
exists, but it is almost completely accidental--an artifact
of how the characters have been and still are allocated.
(Note that this paragraph has oversimplified things for the
<br>
sake of this being an introduction. Unicode doesn&rsquo;t
really encode languages, but the writing systems for
them--their scripts; and one script can be used by many
languages. <br>
Unicode also encodes things that aren&rsquo;t really about
languages, such as symbols like &quot;BAGGAGE
CLAIM&quot;.)</p>

<p style="margin-top: 1em">The Unicode code points are just
abstract numbers. To input and output these abstract
numbers, the numbers must be encoded or serialised somehow.
Unicode defines several <br>
character encoding forms, of which UTF-8 is perhaps the most
popular. UTF-8 is a variable length encoding that encodes
Unicode characters as 1 to 6 bytes. Other encodings <br>
include UTF-16 and UTF-32 and their big- and little-endian
variants (UTF-8 is byte-order independent) The ISO/IEC 10646
defines the UCS-2 and UCS-4 encoding forms.</p>

<p style="margin-top: 1em">For more information about
encodings--for instance, to learn what surrogates and byte
order marks (BOMs) are--see perlunicode.</p>

<p style="margin-top: 1em">Perl&rsquo;s Unicode Support
<br>
Starting from Perl 5.6.0, Perl has had the capacity to
handle Unicode natively. Perl 5.8.0, however, is the first
recommended release for serious Unicode work. The
maintenance <br>
release 5.6.1 fixed many of the problems of the initial
Unicode implementation, but for example regular expressions
still do not work with Unicode in 5.6.1. Perl 5.14.0 is the
<br>
first release where Unicode support is (almost) seamlessly
integrable without some gotchas (the exception being some
differences in quotemeta, which is fixed starting in Perl
<br>
5.16.0). To enable this seamless support, you should
&quot;use feature &rsquo;unicode_strings&rsquo;&quot; (which
is automatically selected if you &quot;use 5.012&quot; or
higher). See feature. (5.14 also <br>
fixes a number of bugs and departures from the Unicode
standard.)</p>

<p style="margin-top: 1em">Before Perl 5.8.0, the use of
&quot;use utf8&quot; was used to declare that operations in
the current block or file would be Unicode-aware. This model
was found to be wrong, or at least <br>
clumsy: the &quot;Unicodeness&quot; is now carried with the
data, instead of being attached to the operations. Starting
with Perl 5.8.0, only one case remains where an explicit
&quot;use utf8&quot; <br>
is needed: if your Perl script itself is encoded in UTF-8,
you can use UTF-8 in your identifier names, and in string
and regular expression literals, by saying &quot;use
utf8&quot;. This <br>
is not the default because scripts with legacy 8-bit data in
them would break. See utf8.</p>

<p style="margin-top: 1em">Perl&rsquo;s Unicode Model <br>
Perl supports both pre-5.6 strings of eight-bit native
bytes, and strings of Unicode characters. The general
principle is that Perl tries to keep its data as eight-bit
bytes for <br>
as long as possible, but as soon as Unicodeness cannot be
avoided, the data is transparently upgraded to Unicode.
Prior to Perl 5.14, the upgrade was not completely
transparent <br>
(see &quot;The &quot;Unicode Bug&quot;&quot; in
perlunicode), and for backwards compatibility, full
transparency is not gained unless &quot;use feature
&rsquo;unicode_strings&rsquo;&quot; (see feature) or
&quot;use 5.012&quot; (or <br>
higher) is selected.</p>

<p style="margin-top: 1em">Internally, Perl currently uses
either whatever the native eight-bit character set of the
platform (for example Latin-1) is, defaulting to UTF-8, to
encode Unicode strings. <br>
Specifically, if all code points in the string are 0xFF or
less, Perl uses the native eight-bit character set.
Otherwise, it uses UTF-8.</p>

<p style="margin-top: 1em">A user of Perl does not normally
need to know nor care how Perl happens to encode its
internal strings, but it becomes relevant when outputting
Unicode strings to a stream <br>
without a PerlIO layer (one with the &quot;default&quot;
encoding). In such a case, the raw bytes used internally
(the native character set or UTF-8, as appropriate for each
string) will <br>
be used, and a &quot;Wide character&quot; warning will be
issued if those strings contain a character beyond
0x00FF.</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">perl -e &rsquo;print &quot;F}0,
&quot;F}0&rsquo;</p>

<p style="margin-top: 1em">produces a fairly useless
mixture of native bytes and UTF-8, as well as a warning:</p>

<p style="margin-top: 1em">Wide character in print at
...</p>

<p style="margin-top: 1em">To output UTF-8, use the
&quot;:encoding&quot; or &quot;:utf8&quot; output layer.
Prepending</p>

<p style="margin-top: 1em">binmode(STDOUT,
&quot;:utf8&quot;);</p>

<p style="margin-top: 1em">to this sample program ensures
that the output is completely UTF-8, and removes the
program&rsquo;s warning.</p>

<p style="margin-top: 1em">You can enable automatic
UTF-8-ification of your standard file handles, default
&quot;open()&quot; layer, and @ARGV by using either the
&quot;-C&quot; command line switch or the
&quot;PERL_UNICODE&quot; <br>
environment variable, see perlrun for the documentation of
the &quot;-C&quot; switch.</p>

<p style="margin-top: 1em">Note that this means that Perl
expects other software to work the same way: if Perl has
been led to believe that STDIN should be UTF-8, but then
STDIN coming in from another <br>
command is not UTF-8, Perl will likely complain about the
malformed UTF-8.</p>

<p style="margin-top: 1em">All features that combine
Unicode and I/O also require using the new PerlIO feature.
Almost all Perl 5.8 platforms do use PerlIO, though: you can
see whether yours is by running <br>
&quot;perl -V&quot; and looking for
&quot;useperlio=define&quot;.</p>

<p style="margin-top: 1em">Unicode and EBCDIC <br>
Perl 5.8.0 also supports Unicode on EBCDIC platforms. There,
Unicode support is somewhat more complex to implement since
additional conversions are needed at every step.</p>

<p style="margin-top: 1em">Later Perl releases have added
code that will not work on EBCDIC platforms, and no one has
complained, so the divergence has continued. If you want to
run Perl on an EBCDIC <br>
platform, send email to perlbug@perl.org</p>

<p style="margin-top: 1em">On EBCDIC platforms, the
internal Unicode encoding form is UTF-EBCDIC instead of
UTF-8. The difference is that as UTF-8 is
&quot;ASCII-safe&quot; in that ASCII characters encode to
UTF-8 <br>
as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;.</p>

<p style="margin-top: 1em">Creating Unicode <br>
To create Unicode characters in literals for code points
above 0xFF, use the &quot;.}&quot; notation in double-quoted
strings:</p>

<p style="margin-top: 1em">my $smiley = &quot;}&quot;;</p>

<p style="margin-top: 1em">Similarly, it can be used in
regular expression literals</p>

<p style="margin-top: 1em">$smiley =~ /}/;</p>

<p style="margin-top: 1em">At run-time you can use
&quot;chr()&quot;:</p>

<p style="margin-top: 1em">my $hebrew_alef =
chr(0x05d0);</p>

<p style="margin-top: 1em">See &quot;Further
Resources&quot; for how to find all these numeric codes.</p>

<p style="margin-top: 1em">Naturally, &quot;ord()&quot;
will do the reverse: it turns a character into a code
point.</p>

<p style="margin-top: 1em">Note that &quot;.&quot; (no
&quot;{}&quot; and only two hexadecimal digits),
&quot;.}&quot;, and &quot;chr(...)&quot; for arguments less
than 0x100 (decimal 256) generate an eight-bit character for
backward <br>
compatibility with older Perls. For arguments of 0x100 or
more, Unicode characters are always produced. If you want to
force the production of Unicode characters regardless of
<br>
the numeric value, use &quot;pack(&quot;U&quot;, ...)&quot;
instead of &quot;.&quot;, &quot;.}&quot;, or
&quot;chr()&quot;.</p>

<p style="margin-top: 1em">You can invoke characters by
name in double-quoted strings:</p>

<p style="margin-top: 1em">my $arabic_alef = &quot;RABIC
LETTER ALEF}&quot;;</p>

<p style="margin-top: 1em">And, as mentioned above, you can
also &quot;pack()&quot; numbers into Unicode characters:</p>

<p style="margin-top: 1em">my $georgian_an =
pack(&quot;U&quot;, 0x10a0);</p>

<p style="margin-top: 1em">Note that both &quot;.}&quot;
and &quot; are compile-time string constants: you
cannot use variables in them. if you want similar run-time
functionality, use &quot;chr()&quot; and <br>
&quot;charnames::string_vianame()&quot;.</p>

<p style="margin-top: 1em">If you want to force the result
to Unicode characters, use the special &quot;U0&quot;
prefix. It consumes no arguments but causes the following
bytes to be interpreted as the UTF-8 <br>
encoding of Unicode characters:</p>

<p style="margin-top: 1em">my $chars =
pack(&quot;U0W*&quot;, 0x80, 0x42);</p>

<p style="margin-top: 1em">Likewise, you can stop such
UTF-8 interpretation by using the special &quot;C0&quot;
prefix.</p>

<p style="margin-top: 1em">Handling Unicode <br>
Handling Unicode is for the most part transparent: just use
the strings as usual. Functions like &quot;index()&quot;,
&quot;length()&quot;, and &quot;substr()&quot; will work on
the Unicode characters; <br>
regular expressions will work on the Unicode characters (see
perlunicode and perlretut).</p>

<p style="margin-top: 1em">Note that Perl considers
grapheme clusters to be separate characters, so for
example</p>

<p style="margin-top: 1em">print length(&quot;ATIN CAPITAL
LETTER A}OMBINING ACUTE ACCENT}&quot;), <br>
&quot;0;</p>

<p style="margin-top: 1em">will print 2, not 1. The only
exception is that regular expressions have &quot; <br>
entire sequence of both the example characters.)</p>

<p style="margin-top: 1em">Life is not quite so
transparent, however, when working with legacy encodings,
I/O, and certain special cases:</p>

<p style="margin-top: 1em">Legacy Encodings <br>
When you combine legacy data and Unicode, the legacy data
needs to be upgraded to Unicode. Normally the legacy data is
assumed to be ISO 8859-1 (or EBCDIC, if applicable).</p>

<p style="margin-top: 1em">The &quot;Encode&quot; module
knows about many encodings and has interfaces for doing
conversions between those encodings:</p>

<p style="margin-top: 1em">use Encode &rsquo;decode&rsquo;;
<br>
$data = decode(&quot;iso-8859-3&quot;, $data); # convert
from legacy to utf-8</p>

<p style="margin-top: 1em">Unicode I/O <br>
Normally, writing out Unicode data</p>

<p style="margin-top: 1em">print FH
$some_string_with_unicode, &quot;0;</p>

<p style="margin-top: 1em">produces raw bytes that Perl
happens to use to internally encode the Unicode string.
Perl&rsquo;s internal encoding depends on the system as well
as what characters happen to be in <br>
the string at the time. If any of the characters are at code
points 0x100 or above, you will get a warning. To ensure
that the output is explicitly rendered in the encoding you
<br>
desire--and to avoid the warning--open the stream with the
desired encoding. Some examples:</p>

<p style="margin-top: 1em">open FH, &quot;&gt;:utf8&quot;,
&quot;file&quot;;</p>

<p style="margin-top: 1em">open FH,
&quot;&gt;:encoding(ucs2)&quot;, &quot;file&quot;; <br>
open FH, &quot;&gt;:encoding(UTF-8)&quot;, &quot;file&quot;;
<br>
open FH, &quot;&gt;:encoding(shift_jis)&quot;,
&quot;file&quot;;</p>

<p style="margin-top: 1em">and on already open streams, use
&quot;binmode()&quot;:</p>

<p style="margin-top: 1em">binmode(STDOUT,
&quot;:utf8&quot;);</p>

<p style="margin-top: 1em">binmode(STDOUT,
&quot;:encoding(ucs2)&quot;); <br>
binmode(STDOUT, &quot;:encoding(UTF-8)&quot;); <br>
binmode(STDOUT, &quot;:encoding(shift_jis)&quot;);</p>

<p style="margin-top: 1em">The matching of encoding names
is loose: case does not matter, and many encodings have
several aliases. Note that the &quot;:utf8&quot; layer must
always be specified exactly like that; <br>
it is not subject to the loose matching of encoding names.
Also note that currently &quot;:utf8&quot; is unsafe for
input, because it accepts the data without validating that
it is indeed <br>
valid UTF-8; you should instead use
&quot;:encoding(utf-8)&quot; (with or without a hyphen).</p>

<p style="margin-top: 1em">See PerlIO for the
&quot;:utf8&quot; layer, PerlIO::encoding and Encode::PerlIO
for the &quot;:encoding()&quot; layer, and Encode::Supported
for many encodings supported by the &quot;Encode&quot;
module.</p>

<p style="margin-top: 1em">Reading in a file that you know
happens to be encoded in one of the Unicode or legacy
encodings does not magically turn the data into Unicode in
Perl&rsquo;s eyes. To do that, specify <br>
the appropriate layer when opening files</p>

<p style="margin-top: 1em">open(my
$fh,&rsquo;&lt;:encoding(utf8)&rsquo;,
&rsquo;anything&rsquo;); <br>
my $line_of_unicode = &lt;$fh&gt;;</p>

<p style="margin-top: 1em">open(my
$fh,&rsquo;&lt;:encoding(Big5)&rsquo;,
&rsquo;anything&rsquo;); <br>
my $line_of_unicode = &lt;$fh&gt;;</p>

<p style="margin-top: 1em">The I/O layers can also be
specified more flexibly with the &quot;open&quot; pragma.
See open, or look at the following example.</p>

<p style="margin-top: 1em">use open
&rsquo;:encoding(utf8)&rsquo;; # input/output default
encoding will be <br>
# UTF-8 <br>
open X, &quot;&gt;file&quot;; <br>
print X chr(0x100), &quot;0; <br>
close X; <br>
open Y, &quot;&lt;file&quot;; <br>
printf &quot;%#x0, ord(&lt;Y&gt;); # this should print 0x100
<br>
close Y;</p>

<p style="margin-top: 1em">With the &quot;open&quot; pragma
you can use the &quot;:locale&quot; layer</p>

<p style="margin-top: 1em">BEGIN { $ENV{LC_ALL} =
$ENV{LANG} = &rsquo;ru_RU.KOI8-R&rsquo; } <br>
# the :locale will probe the locale environment variables
like <br>
# LC_ALL <br>
use open OUT =&gt; &rsquo;:locale&rsquo;; # russki parusski
<br>
open(O, &quot;&gt;koi8&quot;); <br>
print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A =
KOI8-R 0xc1 <br>
close O; <br>
open(I, &quot;&lt;koi8&quot;); <br>
printf &quot;%#x0, ord(&lt;I&gt;), &quot;0; # this should
print 0xc1 <br>
close I;</p>

<p style="margin-top: 1em">These methods install a
transparent filter on the I/O stream that converts data from
the specified encoding when it is read in from the stream.
The result is always Unicode.</p>

<p style="margin-top: 1em">The open pragma affects all the
&quot;open()&quot; calls after the pragma by setting default
layers. If you want to affect only certain streams, use
explicit layers directly in the <br>
&quot;open()&quot; call.</p>

<p style="margin-top: 1em">You can switch encodings on an
already opened stream by using &quot;binmode()&quot;; see
&quot;binmode&quot; in perlfunc.</p>

<p style="margin-top: 1em">The &quot;:locale&quot; does not
currently (as of Perl 5.8.0) work with &quot;open()&quot;
and &quot;binmode()&quot;, only with the &quot;open&quot;
pragma. The &quot;:utf8&quot; and &quot;:encoding(...)&quot;
methods do work with all of <br>
&quot;open()&quot;, &quot;binmode()&quot;, and the
&quot;open&quot; pragma.</p>

<p style="margin-top: 1em">Similarly, you may use these I/O
layers on output streams to automatically convert Unicode to
the specified encoding when it is written to the stream. For
example, the following <br>
snippet copies the contents of the file &quot;text.jis&quot;
(encoded as ISO-2022-JP, aka JIS) to the file
&quot;text.utf8&quot;, encoded as UTF-8:</p>

<p style="margin-top: 1em">open(my $nihongo,
&rsquo;&lt;:encoding(iso-2022-jp)&rsquo;,
&rsquo;text.jis&rsquo;); <br>
open(my $unicode, &rsquo;&gt;:utf8&rsquo;,
&rsquo;text.utf8&rsquo;); <br>
while (&lt;$nihongo&gt;) { print $unicode $_ }</p>

<p style="margin-top: 1em">The naming of encodings, both by
the &quot;open()&quot; and by the &quot;open&quot; pragma
allows for flexible names: &quot;koi8-r&quot; and
&quot;KOI8R&quot; will both be understood.</p>

<p style="margin-top: 1em">Common encodings recognized by
ISO, MIME, IANA, and various other standardisation
organisations are recognised; for a more detailed list see
Encode::Supported.</p>

<p style="margin-top: 1em">&quot;read()&quot; reads
characters and returns the number of characters.
&quot;seek()&quot; and &quot;tell()&quot; operate on byte
counts, as do &quot;sysread()&quot; and
&quot;sysseek()&quot;.</p>

<p style="margin-top: 1em">Notice that because of the
default behaviour of not doing any conversion upon input if
there is no default layer, it is easy to mistakenly write
code that keeps on expanding a <br>
file by repeatedly encoding the data:</p>

<p style="margin-top: 1em"># BAD CODE WARNING <br>
open F, &quot;file&quot;; <br>
local $/; ## read in the whole file of 8-bit characters <br>
$t = &lt;F&gt;; <br>
close F; <br>
open F, &quot;&gt;:encoding(utf8)&quot;, &quot;file&quot;;
<br>
print F $t; ## convert to UTF-8 on output <br>
close F;</p>

<p style="margin-top: 1em">If you run this code twice, the
contents of the file will be twice UTF-8 encoded. A
&quot;use open &rsquo;:encoding(utf8)&rsquo;&quot; would
have avoided the bug, or explicitly opening also the file
<br>
for input as UTF-8.</p>

<p style="margin-top: 1em">NOTE: the &quot;:utf8&quot; and
&quot;:encoding&quot; features work only if your Perl has
been built with the new PerlIO feature (which is the default
on most systems).</p>

<p style="margin-top: 1em">Displaying Unicode As Text <br>
Sometimes you might want to display Perl scalars containing
Unicode as simple ASCII (or EBCDIC) text. The following
subroutine converts its argument so that Unicode characters
<br>
with code points greater than 255 are displayed as
&quot;.}&quot;, control characters (like &quot;0) are
displayed as &quot;.&quot;, and the rest of the characters
as themselves:</p>

<p style="margin-top: 1em">sub nice_string { <br>
join(&quot;&quot;, <br>
map { $_ &gt; 255 ? # if wide character... <br>
sprintf(&quot;\x{%04X}&quot;, $_) : # .} <br>
chr($_) =~ /[[:cntrl:]]/ ? # else if control character...
<br>
sprintf(&quot;\x%02X&quot;, $_) : # . <br>
quotemeta(chr($_)) # else quoted or as themselves <br>
} unpack(&quot;W*&quot;, $_[0])); # unpack Unicode
characters <br>
}</p>

<p style="margin-top: 1em">For example,</p>

<p style="margin-top: 1em">nice_string(&quot;foobar0)</p>

<p style="margin-top: 1em">returns the string</p>

<p style="margin-top: 1em">&rsquo;foobarA&rsquo;</p>

<p style="margin-top: 1em">which is ready to be
printed.</p>

<p style="margin-top: 1em">Special Cases <br>
&Acirc;&middot; Bit Complement Operator ~ And vec()</p>

<p style="margin-top: 1em">The bit complement operator
&quot;~&quot; may produce surprising results if used on
strings containing characters with ordinal values above 255.
In such a case, the results are <br>
consistent with the internal encoding of the characters, but
not with much else. So don&rsquo;t do that. Similarly for
&quot;vec()&quot;: you will be operating on the
internally-encoded bit <br>
patterns of the Unicode characters, not on the code point
values, which is very probably not what you want.</p>

<p style="margin-top: 1em">&Acirc;&middot; Peeking At
Perl&rsquo;s Internal Encoding</p>

<p style="margin-top: 1em">Normal users of Perl should
never care how Perl encodes any particular Unicode string
(because the normal ways to get at the contents of a string
with Unicode--via input and <br>
output--should always be via explicitly-defined I/O layers).
But if you must, there are two ways of looking behind the
scenes.</p>

<p style="margin-top: 1em">One way of peeking inside the
internal encoding of Unicode characters is to use
&quot;unpack(&quot;C*&quot;, ...&quot; to get the bytes of
whatever the string encoding happens to be, or <br>
&quot;unpack(&quot;U0..&quot;, ...)&quot; to get the bytes
of the UTF-8 encoding:</p>

<p style="margin-top: 1em"># this prints c4 80 for the
UTF-8 bytes 0xc4 0x80 <br>
print join(&quot; &quot;, unpack(&quot;U0(H2)*&quot;,
pack(&quot;U&quot;, 0x100))), &quot;0;</p>

<p style="margin-top: 1em">Yet another way would be to use
the Devel::Peek module:</p>

<p style="margin-top: 1em">perl -MDevel::Peek -e
&rsquo;Dump(chr(0x100))&rsquo;</p>

<p style="margin-top: 1em">That shows the &quot;UTF8&quot;
flag in FLAGS and both the UTF-8 bytes and Unicode
characters in &quot;PV&quot;. See also later in this
document the discussion about the
&quot;utf8::is_utf8()&quot; <br>
function.</p>

<p style="margin-top: 1em">Advanced Topics <br>
&Acirc;&middot; String Equivalence</p>

<p style="margin-top: 1em">The question of string
equivalence turns somewhat complicated in Unicode: what do
you mean by &quot;equal&quot;?</p>

<p style="margin-top: 1em">(Is &quot;LATIN CAPITAL LETTER A
WITH ACUTE&quot; equal to &quot;LATIN CAPITAL LETTER
A&quot;?)</p>

<p style="margin-top: 1em">The short answer is that by
default Perl compares equivalence (&quot;eq&quot;,
&quot;ne&quot;) based only on code points of the characters.
In the above case, the answer is no (because 0x00C1 <br>
!= 0x0041). But sometimes, any CAPITAL LETTER A&rsquo;s
should be considered equal, or even A&rsquo;s of any
case.</p>

<p style="margin-top: 1em">The long answer is that you need
to consider character normalization and casing issues: see
Unicode::Normalize, Unicode Technical Report #15, Unicode
Normalization Forms <br>
&lt;http://www.unicode.org/unicode/reports/tr15&gt; and
sections on case mapping in the Unicode Standard
&lt;http://www.unicode.org&gt;.</p>

<p style="margin-top: 1em">As of Perl 5.8.0, the
&quot;Full&quot; case-folding of Case Mappings/SpecialCasing
is implemented, but bugs remain in &quot;qr//i&quot; with
them, mostly fixed by 5.14.</p>

<p style="margin-top: 1em">&Acirc;&middot; String
Collation</p>

<p style="margin-top: 1em">People like to see their strings
nicely sorted--or as Unicode parlance goes, collated. But
again, what do you mean by collate?</p>

<p style="margin-top: 1em">(Does &quot;LATIN CAPITAL LETTER
A WITH ACUTE&quot; come before or after &quot;LATIN CAPITAL
LETTER A WITH GRAVE&quot;?)</p>

<p style="margin-top: 1em">The short answer is that by
default, Perl compares strings (&quot;lt&quot;,
&quot;le&quot;, &quot;cmp&quot;, &quot;ge&quot;,
&quot;gt&quot;) based only on the code points of the
characters. In the above case, the answer is <br>
&quot;after&quot;, since 0x00C1 &gt; 0x00C0.</p>

<p style="margin-top: 1em">The long answer is that &quot;it
depends&quot;, and a good answer cannot be given without
knowing (at the very least) the language context. See
Unicode::Collate, and Unicode Collation <br>
Algorithm
&lt;http://www.unicode.org/unicode/reports/tr10/&gt;</p>

<p style="margin-top: 1em">Miscellaneous <br>
&Acirc;&middot; Character Ranges and Classes</p>

<p style="margin-top: 1em">Character ranges in regular
expression bracketed character classes ( e.g.,
&quot;/[a-z]/&quot;) and in the &quot;tr///&quot; (also
known as &quot;y///&quot;) operator are not magically
Unicode-aware. <br>
What this means is that &quot;[A-Za-z]&quot; will not
magically start to mean &quot;all alphabetic letters&quot;
(not that it does mean that even for 8-bit characters; for
those, if you are <br>
using locales (perllocale), use &quot;/[[:alpha:]]/&quot;;
and if not, use the 8-bit-aware property
&quot;{alpha}&quot;).</p>

<p style="margin-top: 1em">All the properties that begin
with &quot;&quot; (and its inverse &quot;P&quot;) are
actually character classes that are Unicode-aware. There are
dozens of them, see perluniprops.</p>

<p style="margin-top: 1em">You can use Unicode code points
as the end points of character ranges, and the range will
include all Unicode code points that lie between those end
points.</p>

<p style="margin-top: 1em">&Acirc;&middot; String-To-Number
Conversions</p>

<p style="margin-top: 1em">Unicode does define several
other decimal--and numeric--characters besides the familiar
0 to 9, such as the Arabic and Indic digits. Perl does not
support string-to-number <br>
conversion for digits other than ASCII 0 to 9 (and ASCII a
to f for hexadecimal). To get safe conversions from any
Unicode string, use &quot;num()&quot; in Unicode::UCD.</p>

<p style="margin-top: 1em">Questions With Answers <br>
&Acirc;&middot; Will My Old Scripts Break?</p>

<p style="margin-top: 1em">Very probably not. Unless you
are generating Unicode characters somehow, old behaviour
should be preserved. About the only behaviour that has
changed and which could start <br>
generating Unicode is the old behaviour of &quot;chr()&quot;
where supplying an argument more than 255 produced a
character modulo 255. &quot;chr(300)&quot;, for example, was
equal to &quot;chr(45)&quot; <br>
or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER
I WITH BREVE.</p>

<p style="margin-top: 1em">&Acirc;&middot; How Do I Make My
Scripts Work With Unicode?</p>

<p style="margin-top: 1em">Very little work should be
needed since nothing changes until you generate Unicode
data. The most important thing is getting input as Unicode;
for that, see the earlier I/O <br>
discussion. To get full seamless Unicode support, add
&quot;use feature &rsquo;unicode_strings&rsquo;&quot; (or
&quot;use 5.012&quot; or higher) to your script.</p>

<p style="margin-top: 1em">&Acirc;&middot; How Do I Know
Whether My String Is In Unicode?</p>

<p style="margin-top: 1em">You shouldn&rsquo;t have to
care. But you may if your Perl is before 5.14.0 or you
haven&rsquo;t specified &quot;use feature
&rsquo;unicode_strings&rsquo;&quot; or &quot;use 5.012&quot;
(or higher) because otherwise <br>
the semantics of the code points in the range 128 to 255 are
different depending on whether the string they are contained
within is in Unicode or not. (See &quot;When Unicode <br>
Does Not Happen&quot; in perlunicode.)</p>

<p style="margin-top: 1em">To determine if a string is in
Unicode, use:</p>

<p style="margin-top: 1em">print utf8::is_utf8($string) ? 1
: 0, &quot;0;</p>

<p style="margin-top: 1em">But note that this doesn&rsquo;t
mean that any of the characters in the string are necessary
UTF-8 encoded, or that any of the characters have code
points greater than 0xFF (255) <br>
or even 0x80 (128), or that the string has any characters at
all. All the &quot;is_utf8()&quot; does is to return the
value of the internal &quot;utf8ness&quot; flag attached to
the $string. <br>
If the flag is off, the bytes in the scalar are interpreted
as a single byte encoding. If the flag is on, the bytes in
the scalar are interpreted as the (variable-length, <br>
potentially multi-byte) UTF-8 encoded code points of the
characters. Bytes added to a UTF-8 encoded string are
automatically upgraded to UTF-8. If mixed non-UTF-8 and
UTF-8 <br>
scalars are merged (double-quoted interpolation, explicit
concatenation, or printf/sprintf parameter substitution),
the result will be UTF-8 encoded as if copies of the byte
<br>
strings were upgraded to UTF-8: for example,</p>

<p style="margin-top: 1em">$a = &quot;ab0c&quot;; <br>
$b = &quot;&quot;; <br>
print &quot;$a = $b0;</p>

<p style="margin-top: 1em">the output string will be
UTF-8-encoded &quot;ab0c = 0, but $a will stay
byte-encoded.</p>

<p style="margin-top: 1em">Sometimes you might really need
to know the byte length of a string instead of the character
length. For that use either the
&quot;Encode::encode_utf8()&quot; function or the
&quot;bytes&quot; <br>
pragma and the &quot;length()&quot; function:</p>

<p style="margin-top: 1em">my $unicode = chr(0x100); <br>
print length($unicode), &quot;0; # will print 1 <br>
require Encode; <br>
print length(Encode::encode_utf8($unicode)),&quot;0; # will
print 2 <br>
use bytes; <br>
print length($unicode), &quot;0; # will also print 2 <br>
# (the 0xC4 0x80 of the UTF-8) <br>
no bytes;</p>

<p style="margin-top: 1em">&Acirc;&middot; How Do I Find
Out What Encoding a File Has?</p>

<p style="margin-top: 1em">You might try Encode::Guess, but
it has a number of limitations.</p>

<p style="margin-top: 1em">&Acirc;&middot; How Do I Detect
Data That&rsquo;s Not Valid In a Particular Encoding?</p>

<p style="margin-top: 1em">Use the &quot;Encode&quot;
package to try converting it. For example,</p>

<p style="margin-top: 1em">use Encode
&rsquo;decode_utf8&rsquo;;</p>

<p style="margin-top: 1em">if (eval { decode_utf8($string,
Encode::FB_CROAK); 1 }) { <br>
# $string is valid utf8 <br>
} else { <br>
# $string is not valid utf8 <br>
}</p>

<p style="margin-top: 1em">Or use &quot;unpack&quot; to try
decoding it:</p>

<p style="margin-top: 1em">use warnings; <br>
@chars = unpack(&quot;C0U*&quot;,
$string_of_bytes_that_I_think_is_utf8);</p>

<p style="margin-top: 1em">If invalid, a &quot;Malformed
UTF-8 character&quot; warning is produced. The
&quot;C0&quot; means &quot;process the string character per
character&quot;. Without that, the
&quot;unpack(&quot;U*&quot;, ...)&quot; would work <br>
in &quot;U0&quot; mode (the default if the format string
starts with &quot;U&quot;) and it would return the bytes
making up the UTF-8 encoding of the target string, something
that will always <br>
work.</p>

<p style="margin-top: 1em">&Acirc;&middot; How Do I Convert
Binary Data Into a Particular Encoding, Or Vice Versa?</p>

<p style="margin-top: 1em">This probably isn&rsquo;t as
useful as you might think. Normally, you shouldn&rsquo;t
need to.</p>

<p style="margin-top: 1em">In one sense, what you are
asking doesn&rsquo;t make much sense: encodings are for
characters, and binary data are not &quot;characters&quot;,
so converting &quot;data&quot; into some encoding
isn&rsquo;t <br>
meaningful unless you know in what character set and
encoding the binary data is in, in which case it&rsquo;s not
just binary data, now is it?</p>

<p style="margin-top: 1em">If you have a raw sequence of
bytes that you know should be interpreted via a particular
encoding, you can use &quot;Encode&quot;:</p>

<p style="margin-top: 1em">use Encode
&rsquo;from_to&rsquo;; <br>
from_to($data, &quot;iso-8859-1&quot;, &quot;utf-8&quot;); #
from latin-1 to utf-8</p>

<p style="margin-top: 1em">The call to
&quot;from_to()&quot; changes the bytes in $data, but
nothing material about the nature of the string has changed
as far as Perl is concerned. Both before and after the <br>
call, the string $data contains just a bunch of 8-bit bytes.
As far as Perl is concerned, the encoding of the string
remains as &quot;system-native 8-bit bytes&quot;.</p>

<p style="margin-top: 1em">You might relate this to a
fictional &rsquo;Translate&rsquo; module:</p>

<p style="margin-top: 1em">use Translate; <br>
my $phrase = &quot;Yes&quot;; <br>
Translate::from_to($phrase, &rsquo;english&rsquo;,
&rsquo;deutsch&rsquo;); <br>
## phrase now contains &quot;Ja&quot;</p>

<p style="margin-top: 1em">The contents of the string
changes, but not the nature of the string. Perl
doesn&rsquo;t know any more after the call than before that
the contents of the string indicates the <br>
affirmative.</p>

<p style="margin-top: 1em">Back to converting data. If you
have (or want) data in your system&rsquo;s native 8-bit
encoding (e.g. Latin-1, EBCDIC, etc.), you can use
pack/unpack to convert to/from Unicode.</p>

<p style="margin-top: 1em">$native_string =
pack(&quot;W*&quot;, unpack(&quot;U*&quot;,
$Unicode_string)); <br>
$Unicode_string = pack(&quot;U*&quot;,
unpack(&quot;W*&quot;, $native_string));</p>

<p style="margin-top: 1em">If you have a sequence of bytes
you know is valid UTF-8, but Perl doesn&rsquo;t know it yet,
you can make Perl a believer, too:</p>

<p style="margin-top: 1em">use Encode
&rsquo;decode_utf8&rsquo;; <br>
$Unicode = decode_utf8($bytes);</p>

<p style="margin-top: 1em">or:</p>

<p style="margin-top: 1em">$Unicode =
pack(&quot;U0a*&quot;, $bytes);</p>

<p style="margin-top: 1em">You can find the bytes that make
up a UTF-8 sequence with</p>

<p style="margin-top: 1em">@bytes = unpack(&quot;C*&quot;,
$Unicode_string)</p>

<p style="margin-top: 1em">and you can create well-formed
Unicode with</p>

<p style="margin-top: 1em">$Unicode_string =
pack(&quot;U*&quot;, 0xff, ...)</p>

<p style="margin-top: 1em">&Acirc;&middot; How Do I Display
Unicode? How Do I Input Unicode?</p>

<p style="margin-top: 1em">See
&lt;http://www.alanwood.net/unicode/&gt; and
&lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; How Does Unicode
Work With Traditional Locales?</p>

<p style="margin-top: 1em">Starting in Perl 5.16, you can
specify</p>

<p style="margin-top: 1em">use locale
&rsquo;:not_characters&rsquo;;</p>

<p style="margin-top: 1em">to get Perl to work well with
tradtional locales. The catch is that you have to translate
from the locale character set to/from Unicode yourself. See
&quot;Unicode I/O&quot; above <br>
for how to</p>

<p style="margin-top: 1em">use open
&rsquo;:locale&rsquo;;</p>

<p style="margin-top: 1em">to accomplish this, but full
details are in &quot;Unicode and UTF-8&quot; in perllocale,
including gotchas that happen if you don&rsquo;t specifiy
&quot;:not_characters&quot;.</p>

<p style="margin-top: 1em">Hexadecimal Notation <br>
The Unicode standard prefers using hexadecimal notation
because that more clearly shows the division of Unicode into
blocks of 256 characters. Hexadecimal is also simply shorter
<br>
than decimal. You can use decimal notation, too, but
learning to use hexadecimal just makes life easier with the
Unicode standard. The &quot;U+HHHH&quot; notation uses
hexadecimal, for <br>
example.</p>

<p style="margin-top: 1em">The &quot;0x&quot; prefix means
a hexadecimal number, the digits are 0-9 and a-f (or A-F,
case doesn&rsquo;t matter). Each hexadecimal digit
represents four bits, or half a byte. &quot;print 0x...,
<br>
&quot;0&quot; will show a hexadecimal number in decimal, and
&quot;printf &quot;%x0, $decimal&quot; will show a decimal
number in hexadecimal. If you have just the &quot;hex
digits&quot; of a hexadecimal <br>
number, you can use the &quot;hex()&quot; function.</p>

<p style="margin-top: 1em">print 0x0009, &quot;0; # 9 <br>
print 0x000a, &quot;0; # 10 <br>
print 0x000f, &quot;0; # 15 <br>
print 0x0010, &quot;0; # 16 <br>
print 0x0011, &quot;0; # 17 <br>
print 0x0100, &quot;0; # 256</p>

<p style="margin-top: 1em">print 0x0041, &quot;0; # 65</p>

<p style="margin-top: 1em">printf &quot;%x0, 65; # 41 <br>
printf &quot;%#x0, 65; # 0x41</p>

<p style="margin-top: 1em">print hex(&quot;41&quot;),
&quot;0; # 65</p>

<p style="margin-top: 1em">Further Resources <br>
&Acirc;&middot; Unicode Consortium</p>


<p style="margin-top: 1em">&lt;http://www.unicode.org/&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Unicode FAQ</p>


<p style="margin-top: 1em">&lt;http://www.unicode.org/unicode/faq/&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Unicode
Glossary</p>


<p style="margin-top: 1em">&lt;http://www.unicode.org/glossary/&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Unicode
Recommended Reading List</p>

<p style="margin-top: 1em">The Unicode Consortium has a
list of articles and books, some of which give a much more
in depth treatment of Unicode:
&lt;http://unicode.org/resources/readinglist.html&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Unicode Useful
Resources</p>


<p style="margin-top: 1em">&lt;http://www.unicode.org/unicode/onlinedat/resources.html&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Unicode and
Multilingual Support in HTML, Fonts, Web Browsers and Other
Applications</p>


<p style="margin-top: 1em">&lt;http://www.alanwood.net/unicode/&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; UTF-8 and
Unicode FAQ for Unix/Linux</p>


<p style="margin-top: 1em">&lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; Legacy Character
Sets</p>


<p style="margin-top: 1em">&lt;http://www.czyborra.com/&gt;
&lt;http://www.eki.ee/letter/&gt;</p>

<p style="margin-top: 1em">&Acirc;&middot; You can explore
various information from the Unicode data files using the
&quot;Unicode::UCD&quot; module.</p>

<p style="margin-top: 1em">UNICODE IN OLDER PERLS <br>
If you cannot upgrade your Perl to 5.8.0 or later, you can
still do some Unicode processing by using the modules
&quot;Unicode::String&quot;, &quot;Unicode::Map8&quot;, and
&quot;Unicode::Map&quot;, available <br>
from CPAN. If you have the GNU recode installed, you can
also use the Perl front-end &quot;Convert::Recode&quot; for
character conversions.</p>

<p style="margin-top: 1em">The following are fast
conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes
and back, the code works even with older Perl 5
versions.</p>

<p style="margin-top: 1em"># ISO 8859-1 to UTF-8 <br>

s/([0-])/chr(0xC0|ord($1)&gt;&gt;6).chr(0x80|ord($1)&amp;0x3F)/eg;</p>

<p style="margin-top: 1em"># UTF-8 to ISO 8859-1 <br>

s/([)([0-])/chr(ord($1)&lt;&lt;6&amp;0xC0|ord($2)&amp;0x3F)/eg;</p>

<p style="margin-top: 1em">SEE ALSO <br>
perlunitut, perlunicode, Encode, open, utf8, bytes,
perlretut, perlrun, Unicode::Collate, Unicode::Normalize,
Unicode::UCD</p>

<p style="margin-top: 1em">ACKNOWLEDGMENTS <br>
Thanks to the kind readers of the perl5-porters@perl.org,
perl-unicode@perl.org, linux-utf8@nl.linux.org, and
unicore@unicode.org mailing lists for their valuable
feedback.</p>

<p style="margin-top: 1em">AUTHOR, COPYRIGHT, AND LICENSE
<br>
Copyright 2001-2011 Jarkko Hietaniemi &lt;jhi@iki.fi&gt;</p>

<p style="margin-top: 1em">This document may be distributed
under the same terms as Perl itself.</p>

<p style="margin-top: 1em">perl v5.16.3 2013-03-04
PERLUNIINTRO(1)</p>
<hr>
</body>
</html>
