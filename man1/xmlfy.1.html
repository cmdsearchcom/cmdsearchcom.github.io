<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
  </style>
  <title>xmlfy(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">xmlfy(1)</td>
    <td class="head-vol">User Commands</td>
    <td class="head-rtitle">xmlfy(1)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="selflink" href="#NAME">NAME</a></h1>
xmlfy - Convert to XML on the fly.
<h1 class="Sh" title="Sh" id="SYNOPSIS"><a class="selflink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>xmlfy</b> [ <i>OPTION</i>]...
<div class="Pp"></div>
<b>-h</b>, <b>--help</b>
<div>&#x00A0;</div>
<br/>
print usage instructions
<br/>
<div class="Pp"></div>
<b>-v</b>, <b>--version</b>
<div>&#x00A0;</div>
<br/>
print version number
<br/>
<div class="Pp"></div>
<b>--license</b>
<div>&#x00A0;</div>
<br/>
print license
<br/>
<div class="Pp"></div>
<b>--debug</b>
<div>&#x00A0;</div>
<br/>
print extra debugging information
<br/>
<div class="Pp"></div>
Input options:
<div class="Pp"></div>
<b>-F</b>,
  <b>--fieldseparator</b>[<i>&lt;level&gt;</i>[<i>b</i>][<b>:</b><i>&lt;scope&gt;</i>]]
  <i>&lt;string&gt;</i>
<div>&#x00A0;</div>
<br/>
specify a delimiter string token for the level specified
<br/>
<div class="Pp"></div>
<b>-R</b>, <b>--recordseparator </b><i>&lt;string&gt;</i>
<div>&#x00A0;</div>
<br/>
this is a synonym for &quot;-F1 <i>&lt;string&gt;</i>&quot;
<div>&#x00A0;</div>
specify an alternative record separator string to the default
<br/>
<div class="Pp"></div>
<b>-C</b>, <b>--column</b>[<b>:</b><i>&lt;scope&gt;</i>]
  <i>&lt;r1&gt;</i><b>-</b> <i>&lt;r2&gt;</i>[<b>:</b><i>&lt;name&gt;</i>]
<div>&#x00A0;</div>
<br/>
create an input field from an input column range
<br/>
<div class="Pp"></div>
<b>-W</b>, <b>--regex</b>[<b>:</b><i>&lt;scope&gt;</i>]
  [<i>E</i>|<i>B</i>][<i>i</i>][
  <i>l</i>][<i>r</i>][<i>U</i>][<i>n</i>][<i>b</i>][
  <i>e</i>]<b>/</b><i>&lt;pattern&gt;</i>
  <b>/</b>[<i>&lt;name&gt;</i>[<b>,</b>..]]
<div>&#x00A0;</div>
<br/>
create input fields from a regular expression
<br/>
<div class="Pp"></div>
<b>-e</b>, <b>--expelempty</b>
<div>&#x00A0;</div>
<br/>
expel empty input records and fields
<br/>
<div class="Pp"></div>
<b>-E</b>, <b>--expel</b>
  <i>&lt;input_records&gt;</i>[<b>:</b><i>&lt;input_fields&gt;</i>]
<div>&#x00A0;</div>
<br/>
expel selected records or fields from being processed
<br/>
<div class="Pp"></div>
<b>-q</b>, <b>--quotedfields</b>[<i>2</i>]
<div>&#x00A0;</div>
<br/>
treat fields that are between quotes as one field
<br/>
<div class="Pp"></div>
<b>-Q</b>, <b>--quotechars</b>[<i>2</i>] <i>&lt;string&gt;</i>
<div>&#x00A0;</div>
<br/>
specify an array of quoting characters to use
<br/>
<div class="Pp"></div>
<b>-b</b>, <b>--blanklines</b>
<div>&#x00A0;</div>
<br/>
do not ignore blank input records
<br/>
<div class="Pp"></div>
<b>-t</b>, <b>--trim</b>
<div>&#x00A0;</div>
<br/>
trim leading and trailing white space from input fields
<br/>
<div class="Pp"></div>
Output options:
<div class="Pp"></div>
<b>-S</b>, <b>--schema </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<b>-Sd</b>, <b>--schemadtd </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<b>-Sr</b>, <b>--schemarnc </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<b>-Sx</b>, <b>--schemaxsd </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<br/>
use a schema <i>&lt;file&gt;</i> for tag names and element control
<br/>
<div class="Pp"></div>
<b>-M</b>, <b>--matchdirect</b> <i>0</i>|<i>&lt;elementname&gt;</i>
<div>&#x00A0;</div>
<br/>
match directly on a specific element in the schema
<br/>
<div class="Pp"></div>
<b>-A</b>,
  <b>--attribute</b>[<i>&lt;level&gt;</i>[<b>:</b><i>&lt;scope&gt;</i>]]
  <i>number</i>| <i>level</i>
<div>&#x00A0;</div>
<br/>
| <i>delimiter</i>|<i>timestamp</i>|<i>insert &lt;name&gt; &lt;value&gt;</i>
<br/>
<div>&#x00A0;</div>
<br/>
include attributes in the opening element tag
<br/>
<div class="Pp"></div>
<b>-T</b>, <b>--tag</b>[<i>&lt;level&gt;</i>[<b>:</b><i>&lt;scope&gt;</i>]]
  <i>number</i>| <i>level</i>
<div>&#x00A0;</div>
<br/>
| <i>name &lt;name&gt;</i>
<div>&#x00A0;</div>
|[ <i>re</i>]<i>insert &lt;name&gt; &lt;value&gt;</i>
<div>&#x00A0;</div>
|[ <i>re</i>]<i>insertfile &lt;name&gt; &lt;file&gt;</i>
<div>&#x00A0;</div>
|[ <i>re</i>]<i>insertfilexml &lt;indent&gt; &lt;file&gt;</i>
<br/>
<div>&#x00A0;</div>
<br/>
modify or insert element tags
<br/>
<div class="Pp"></div>
<b>-k</b>, <b>--keyvaluepairs</b>[<i>&lt;level&gt;</i>]
<div>&#x00A0;</div>
<br/>
generate key/value XML tag pairs
<br/>
<div class="Pp"></div>
<b>-l</b>, <b>--linenumbers</b>
<div>&#x00A0;</div>
<br/>
this is a synonym for &quot;-T1 number&quot;
<div>&#x00A0;</div>
include the line number in the line tag name
<br/>
<div class="Pp"></div>
<b>-f</b>, <b>--fieldnumbers</b>
<div>&#x00A0;</div>
<br/>
this is a synonym for &quot;-T2 number&quot;
<div>&#x00A0;</div>
include the field number in the field tag name
<br/>
<div class="Pp"></div>
<b>-L</b>, <b>--linetags</b>
<div>&#x00A0;</div>
<br/>
include a line number tag with the record data
<br/>
<div class="Pp"></div>
<b>-X</b>, <b>--xmlformat
  [</b><i>XML1.0</i>|<i>XML1.1</i>]|[<i>SOAP1.1</i>|<i>SOAP1.2</i>]|[ <i>HTML
  table</i>| <i>list</i>]
<div>&#x00A0;</div>
<br/>
|[
  <i>UTF-8</i>|<i>UTF-16</i>|<i>UTF-16BE</i>|<i>UTF-16LE</i>|<i>UTF-32</i>|<i>UTF-32BE</i>|
  <i>UTF-32LE</i>]|<i>BOM</i>
<div>&#x00A0;</div>
| <i>ASCIItoUTF</i>|[<i>noescape
  all</i>|<i>amp</i>|<i>lt</i>|<i>gt</i>|<i>quot</i>| <i>apos</i>|<i>brvbar</i>]
<div>&#x00A0;</div>
| <i>trimtagclose</i>|[<i>newline dos</i>|<i>unix</i>]
<br/>
<div>&#x00A0;</div>
<br/>
specify an XML output format
<br/>
<div class="Pp"></div>
<b>-p</b>, <b>--printonly
  </b><i>header</i>|<i>footer</i>|<i>rtagopen</i>|<i>rtagclose</i>|
  <i>records</i>
<div>&#x00A0;</div>
<br/>
print only snippets of the XML output
<br/>
<div class="Pp"></div>
<b>-I</b>, <b>--identifier </b><i>&lt;system_identifier&gt;</i>
<div>&#x00A0;</div>
<br/>
specify an alternate system identifier of the doctype or SOAP URI
<br/>
<div class="Pp"></div>
<b>-s</b>, <b>--summary</b>[<i>2</i>|<i>c</i>|<i>n</i>|<i>f &lt;file&gt;</i>]
<div>&#x00A0;</div>
<br/>
print a summary after the end of the processing
<br/>
<div class="Pp"></div>
<b>-U</b>, <b>--unxml</b>
<div>&#x00A0;</div>
<br/>
undo the XML syntax leaving just plain text
<br/>
<div class="Pp"></div>
<b>--noxml</b>
<div>&#x00A0;</div>
<br/>
do not XML-fy the input stream
<br/>
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="selflink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The xmlfy command reads stdin and outputs it to stdout in XML format using
  supplied control directives.
<div class="Pp"></div>
Delimiter tokens and/or column selections are used to break down the input
  stream into XML elements which are then represented inside an XML tree
  hierarchy that can span multiple depth levels. For example, command line
  output was originally designed for text or CRT based processing. The xmlfy
  command takes this text based output where a new-line often represents an
  end-of-record of data and white space often represents a field separator, and
  reformats it into XML output suitable for interfacing with modern object
  oriented systems.
<div class="Pp"></div>
xmlfy is a powerful yet lightweight tool that primarily caters for converting
  ASCII, UTF-8, UTF-16 or UTF-32 based output into XML format on the fly and
  dealing with common issues associated with this kind of transformation.
<div class="Pp"></div>
The xmlfy command also supports a basic version of a schema configuration
  allowing you to control the format of the XML output by supplying a schema
  file as an option.
<div class="Pp"></div>
With no options supplied xmlfy will use default values for its XML format. The
  entire standard input will be enclosed in &lt;xmlfy&gt;&lt;/xmlfy&gt; pairs,
  each line of standard input will be enclosed in &lt;line&gt;&lt;/line&gt;
  pairs, and each field of each line will be enclosed in
  &lt;field&gt;&lt;/field&gt; pairs.
<h1 class="Sh" title="Sh" id="OPTIONS"><a class="selflink" href="#OPTIONS">OPTIONS</a></h1>
You can supply options to customise the behaviour of xmlfy at the command line,
  or by a special token inside the schema file, or both. NOTE: Options are
  resolved from left to right. If any conflicting options are specified then the
  last one will have precedence.
<div class="Pp"></div>
<b>Option: -h</b>, <b>--help</b>
<div>&#x00A0;</div>
The command line usage is printed in plain text format not in XML format.
<div class="Pp"></div>
<b>Option: -v</b>, <b>--version</b>
<div>&#x00A0;</div>
The version number is printed in plain text format not in XML format. If the
  version number is required in XML format it is included with the summary
  option.
<div class="Pp"></div>
<b>Option: --license</b>
<div>&#x00A0;</div>
Print all licenses used by xmlfy.
<div class="Pp"></div>
<b>Option: --debug</b>
<div>&#x00A0;</div>
Print extra debugging information to stderr to help debug xmlfy behaviour.
<div class="Pp"></div>
Input options:
<div class="Pp"></div>
<b>Option: -F</b>,
  <b>--fieldseparator</b>[<i>&lt;level&gt;</i>[<i>b</i>][<b>:</b>
  <i>&lt;scope&gt;</i>]] <i>&lt;string&gt;</i>
<div>&#x00A0;</div>
Allows you to specify a delimiter string token for the level specified.
<div>&#x00A0;</div>
<i>&lt;level&gt;</i>
<br/>
-
<br/>
The XML depth level to be delimited by <i>&lt;string&gt;</i>.
<div>&#x00A0;</div>
Must be an integer value greater than or equal to 1.
<div>&#x00A0;</div>
E.g. a value of 1 will split the input into records delimited by
  <i>&lt;string&gt;</i>, a value of 2 will split records into fields delimited
  by <i>&lt;string&gt;</i>, a value of 3 will split fields into subfields
  delimited by <i>&lt;string&gt;</i>, and so on.
<div>&#x00A0;</div>
There is no space separating the option and the level value.
<div>&#x00A0;</div>
If no level is specified then the given options will only apply to level 2.
<br/>
<div>&#x00A0;</div>
<i>b</i>
<br/>
-
<br/>
Use byte matching for the specified delimiter string.
<div>&#x00A0;</div>
By specifying this option the delimiter string is treated as just a literal
  sequence of bytes. Normally command line arguments are presented to xmlfy as
  ASCII strings and if wide UTF encoding like UTF-16 or UTF-32 is being used
  then xmlfy will automatically convert the specified delimiter string to that
  encoding. With this option no encoding conversion takes place. In this mode
  you can also specify escaped decimal byte sequences inside the delimiter
  string. E.g. &quot;\123\234\\&quot;
<br/>
<div>&#x00A0;</div>
<i>&lt;scope&gt;</i>
<br/>
-
<br/>
A comma delimited set of sequence ranges with no spaces.
<div>&#x00A0;</div>
The <i>&lt;scope&gt;</i> parameter has a sub form of
  <i>&lt;s1&gt;</i>[-<i>&lt;s2&gt;</i>][ <i>r</i>][<b>,</b>..]
<div>&#x00A0;</div>
<i>&lt;s1&gt;</i>
<br/>
-
<br/>
integer representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;s2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
<i>r</i>
<br/>
-
<br/>
restart the scope counter for this delimiter after the completion of the
  associated range.
<br/>
<div>&#x00A0;</div>
Restrict the delimiter effectiveness to the occurrences specified in
  <i>&lt;scope&gt;</i>. If a delimiter <i>&lt;string&gt;</i> is encountered for
  the level specified and its sequence is not in the scope then it will not
  function as a field separator and will instead be treated as data.
<div>&#x00A0;</div>
E.g. -F3:1-3,8 &quot;.&quot; this is saying that level 3 fields will only be
  created for the 1st to 3rd, and 8th occurrences of the delimiter &quot;.&quot;
  (period).
<div>&#x00A0;</div>
The restart scope counter option <i>r</i> allows you to specify repeating scope
  sequences.
<div>&#x00A0;</div>
E.g -F1:2,5r &quot;\n&quot; this is saying create level 1 records out of every
  second and fifth lines and keep repeating this until the input is exhausted.
<div>&#x00A0;</div>
When using multiple same level delimiters, restarting scope counters of the
  equivalent level and higher get reset whenever a delimiter match is applied.
<div>&#x00A0;</div>
If a <i>&lt;scope&gt;</i> range is not specified then the delimiter function
  applies to every occurrence of <i>&lt;string&gt;</i> of the target level.
<br/>
<div>&#x00A0;</div>
<i>&lt;string&gt;</i>
<br/>
-
<br/>
A sequence of characters or token to be used as a delimiter. Tokens specified
  literally as &quot;\n&quot;, &quot;\r&quot;, and &quot;\t&quot; are translated
  to their corresponding control character. If using wide UTF encoding then
  <i>&lt;string&gt;</i> is automatically converted to that encoding, otherwise
  you can use the byte matching option and specify escaped decimal byte
  sequences inside <i>&lt;string&gt;</i>.
<br/>
<div>&#x00A0;</div>
<br/>
o
<br/>
If the delimiter token is the same for a series of levels then obviously the
  shallowest level will take precedence, unless the shallowest levels have been
  limited by scope restrictions. You can also make use of quotes in the input
  along with specifying quote options.
<br/>
<div>&#x00A0;</div>
o
<br/>
The XML tree algorithm deepens in a sequential way therefore you must set your
  delimiter levels as an unbroken sequence for them to be of any use, that is
  you cannot split a level 2 field with a level 4 delimiter string.
<br/>
<div>&#x00A0;</div>
o
<br/>
Refer to the schema option section for information on level handling when a
  schema file is specified.
<br/>
<div>&#x00A0;</div>
o
<br/>
Levels 1 and 2 are already set by default.
<br/>
<div>&#x00A0;</div>
o
<br/>
The default level 1 delimiter token is NEWLINE (new-line).
<br/>
<div>&#x00A0;</div>
o
<br/>
The default level 2 delimiter token is WHITESPACE (space, tab, new-line,
  carriage-return, vertical-tab and form-feed).
<br/>
<div>&#x00A0;</div>
o
<br/>
The delimiters for levels 3 and above are unset.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one delimiter string token can be specified however this option can be
  invoked multiple times allowing for multiple delimiters to be used at the
  level specified. When specifying multiple same level delimiters, the larger
  delimiter strings are matched before the smaller ones. The delimiter string is
  not included in the output.
<br/>
<div class="Pp"></div>
<b>Option: -R</b>, <b>--recordseparator</b> <i>&lt;string&gt;</i>
<div>&#x00A0;</div>
This is a synonym for &quot;-F1 <i>&lt;string&gt;</i>&quot;
<div>&#x00A0;</div>
Allows you to specify a record separator string token that is different from the
  default. The default record separator token is NEWLINE (new-line).
<div class="Pp"></div>
<b>Option: -C</b>, <b>--column</b>[<b>:</b><i>&lt;scope&gt;</i>]
  <i>&lt;c1&gt;</i> <b>-</b><i>&lt;c2&gt;</i>[<b>:</b><i>&lt;name&gt;</i>]
<div>&#x00A0;</div>
Use an input column range of the input record to generate an input field. This
  is an alternative method of capturing input fields from using delimiters.
<div>&#x00A0;</div>
<i>&lt;scope&gt;</i>
<br/>
-
<br/>
A comma delimited set of sequence ranges with no spaces.
<div>&#x00A0;</div>
The <i>&lt;scope&gt;</i> parameter has a sub form of
  <i>&lt;s1&gt;</i>[-<i>&lt;s2&gt;</i>][ <i>r</i>][<b>,</b>..]
<div>&#x00A0;</div>
<i>&lt;s1&gt;</i>
<br/>
-
<br/>
integer representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;s2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
<i>r</i>
<br/>
-
<br/>
restart the scope counter for this column option after the completion of the
  associated range.
<br/>
<div>&#x00A0;</div>
Restrict the column option effectiveness to the occurrences specified in
  <i>&lt;scope&gt;</i>. If the input record sequence is not in the scope then
  the column option will not be applied and input fields will not be generated.
<div>&#x00A0;</div>
The restart scope counter option <i>r</i> allows the scope sequences to
  continually repeat themselves. E.g -C:1-3,5r 1-20 this is saying capture
  column fields of 20 characters in length for every first to third and fifth
  input records, and keep repeating this until the input is exhausted.
<div>&#x00A0;</div>
If a <i>&lt;scope&gt;</i> range is not specified then the column option applies
  to all input records.
<br/>
<div>&#x00A0;</div>
<i>&lt;c1&gt;</i>
<br/>
-
<br/>
Integer or the $ token representing the start column range of the input field.
<br/>
<div>&#x00A0;</div>
<i>&lt;c2&gt;</i>
<br/>
-
<br/>
Integer or the $ token representing the end column range of the input field.
<br/>
<div>&#x00A0;</div>
<i>&lt;name&gt;</i>
<br/>
-
<br/>
Optional string value that will be used to override the tag name for this input
  field.
<div>&#x00A0;</div>
You can pretty much specify anything as a tag name including illegal XML
  therefore user discretion is advised.
<div>&#x00A0;</div>
Only applicable for changing default behaviour (i.e. when the --schema option is
  NOT specified).
<br/>
<div>&#x00A0;</div>
o
<br/>
Specifying field separators of level 2 and above with this option is conflicting
  and will produce a usage error.
<br/>
<div>&#x00A0;</div>
o
<br/>
The number of times and order in which this option is specified (in conjunction
  with the <b>-W</b> option) determines the number of input fields generated and
  their order.
<br/>
<div>&#x00A0;</div>
o
<br/>
Column ranges represent code points (characters) meaning any multi byte
  character will only account for just one column position.
<br/>
<div>&#x00A0;</div>
o
<br/>
Multiple options can use non linear ranges and can overlap e.g. -C 5-10:part -C
  1-$:whole
<br/>
<div>&#x00A0;</div>
o
<br/>
Ranges that exceed the size of the input record will not process beyond the end
  of the input record.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can use single or double quotes to protect the range from the shell
  interpreter e.g. -C '80-$:text'
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one parameter pair can be specified however this option can be invoked
  multiple times.
<br/>
<div class="Pp"></div>
<b>Option: -W</b>, <b>--regex</b>[<b>:</b><i>&lt;scope&gt;</i>]
  [<i>E</i>|<i>B</i>][
  <i>i</i>][<i>l</i>][<i>r</i>][<i>U</i>][<i>n</i>][<i>b</i>][
  <i>e</i>]<b>/</b><i>&lt;pattern&gt;</i><b>/</b>[<i>&lt;name&gt;</i>[<b>,</b>..]]
<div>&#x00A0;</div>
Use a regular expression on the input record to generate input fields. This is
  an alternative method of capturing input fields from using delimiters.
<div>&#x00A0;</div>
<i>&lt;scope&gt;</i>
<br/>
-
<br/>
A comma delimited set of sequence ranges with no spaces.
<div>&#x00A0;</div>
The <i>&lt;scope&gt;</i> parameter has a sub form of
  <i>&lt;s1&gt;</i>[-<i>&lt;s2&gt;</i>][ <i>r</i>][<b>,</b>..]
<div>&#x00A0;</div>
<i>&lt;s1&gt;</i>
<br/>
-
<br/>
integer representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;s2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
<i>r</i>
<br/>
-
<br/>
restart the scope counter for this regex option after the completion of the
  associated range.
<br/>
<div>&#x00A0;</div>
Restrict the regex option effectiveness to the occurrences specified in
  <i>&lt;scope&gt;</i>. If the input record sequence is not in the scope then
  the regex option will not be applied and input fields will not be generated.
<div>&#x00A0;</div>
The restart scope counter option <i>r</i> allows the scope sequences to
  continually repeat themselves. E.g -W:1-3,5r /(^A.*).*(B.*$)/ this is saying
  capture two regex fields for every first to third and fifth input records, and
  keep repeating this until the input is exhausted.
<div>&#x00A0;</div>
If a <i>&lt;scope&gt;</i> range is not specified then the regex option applies
  to all input records.
<br/>
<div>&#x00A0;</div>
<i>E</i>
<br/>
-
<br/>
flag to use Extended Regular Expressions in <i>&lt;pattern&gt;</i> (default).
<br/>
<div>&#x00A0;</div>
<i>B</i>
<br/>
-
<br/>
flag to use Basic Regular Expressions in <i>&lt;pattern&gt;</i>.
<br/>
<div>&#x00A0;</div>
<i>i</i>
<br/>
-
<br/>
flag to ignore case.
<br/>
<div>&#x00A0;</div>
<i>l</i>
<br/>
-
<br/>
flag to treat <i>&lt;pattern&gt;</i> as a literal.
<br/>
<div>&#x00A0;</div>
<i>r</i>
<br/>
-
<br/>
flag to make concatenation right associative.
<br/>
<div>&#x00A0;</div>
<i>U</i>
<br/>
-
<br/>
flag to make operators ungreedy by default.
<br/>
<div>&#x00A0;</div>
<i>n</i>
<br/>
-
<br/>
flag to give '\n' special meaning (REG_NEWLINE).
<br/>
<div>&#x00A0;</div>
<i>b</i>
<br/>
-
<br/>
flag to set '^' as not beginning-of-line (REG_NOTBOL).
<br/>
<div>&#x00A0;</div>
<i>e</i>
<br/>
-
<br/>
flag to set '$' as not end-of-line (REG_NOTEOL).
<br/>
<div>&#x00A0;</div>
<i>&lt;pattern&gt;</i>
<br/>
-
<br/>
A POSIX 1003.2 compliant Regular Expression pattern utilising zero or more
  parenthesis pairs to capture input fields.
<br/>
<div>&#x00A0;</div>
<i>&lt;name&gt;</i>
<br/>
-
<br/>
Optional string value that will be used to override the tag name for input
  fields derived from pattern matches.
<div>&#x00A0;</div>
A comma separated list of <i>&lt;name&gt;</i> can be specified with the last
  entry being re-used if more input fields than names are generated.
<div>&#x00A0;</div>
You can pretty much specify anything as a tag name including illegal XML
  therefore user discretion is advised.
<div>&#x00A0;</div>
Only applicable for changing default behaviour (i.e. when the --schema option is
  NOT specified).
<br/>
<div>&#x00A0;</div>
o
<br/>
Specifying field separators of level 2 and above with this option is conflicting
  and will produce a usage error.
<br/>
<div>&#x00A0;</div>
o
<br/>
The number of times and order in which this option is specified (in conjunction
  with the <b>-C</b> option) determines the number of input fields generated and
  their order.
<br/>
<div>&#x00A0;</div>
o
<br/>
If matches are not made for all parenthesis pairs specified in
  <i>&lt;pattern&gt;</i> then no output will result.
<br/>
<div>&#x00A0;</div>
o
<br/>
If no parenthesis pairs are specified in <i>&lt;pattern&gt;</i> then the entire
  input record will be used as the output when a pattern match occurs.
<br/>
<div>&#x00A0;</div>
o
<br/>
Wide UTF encoding can be specified in <i>&lt;pattern&gt;</i> by using the \x
  literal followed by two hexadecimal digits to represent any byte inside the
  code-point e.g. \x0b.
<br/>
<div>&#x00A0;</div>
o
<br/>
For further information on using regex syntax and its flags please consult the
  TRE web documentation.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can use single or double quotes to protect <i>&lt;pattern&gt;</i> from the
  shell interpreter e.g. -W 'iU/(^Pam .*)/pams'
<br/>
<div>&#x00A0;</div>
o
<br/>
You can specify the percentage character <b>%</b> as an alternative separator to
  forward-slash <b>/</b> for <i>&lt;pattern&gt;</i> so long as it remains
  paired.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one parameter pair can be specified however this option can be invoked
  multiple times.
<br/>
<div class="Pp"></div>
<b>Option: -e</b>, <b>--expelempty</b>
<div>&#x00A0;</div>
Expel input fields that are empty (zero bytes in length) from being processed.
  The use of multi level and multiple same level delimiters can sometimes yield
  plenty of empty fields which may be undesirable. This option expels all the
  empty input fields from being processed by the output processor. All levels
  are examined and any input records comprised entirely out of empty fields are
  also expelled.
<div>&#x00A0;</div>
This option will always run before any expelling tasks specified with option
  <b>-E</b> are run.
<div>&#x00A0;</div>
This option has no influence on levels subjected to key/value pairing as that
  process has its own way of dealing with empty fields at its target levels.
<div>&#x00A0;</div>
If a schema is used then obviously the number of input records/fields used for
  element matching has been reduced.
<div class="Pp"></div>
<b>Option: -E</b>, <b>--expel</b>
  <i>&lt;input_records&gt;</i>[<b>:</b><i>&lt;input_fields&gt;</i>]
<div>&#x00A0;</div>
Expel selected input records or selected input fields of selected input records
  from being processed. Each input record is checked against the expel criteria
  and if a match occurs then these input records or input fields are simply
  discarded from being passed onto the xmlfy output processor.
<div>&#x00A0;</div>
<i>&lt;input_records&gt;</i>
<br/>
-
<br/>
A comma delimited set of input record expel criteria with no spaces.
<div>&#x00A0;</div>
The <i>&lt;input_records&gt;</i> parameter has a sub form of
  <i>&lt;range_type&gt;&lt;r1&gt;</i>[
  <b>-</b><i>&lt;r2&gt;</i>][<b>/</b><i>&lt;string&gt;</i> <b>/</b>][<b>,</b>..]
<div>&#x00A0;</div>
Where <i>&lt;range_type&gt;</i> can be '<i>n</i>', '<i>f</i>' or '<i>c</i>'.
<div>&#x00A0;</div>
<i>n</i>
<br/>
-
<br/>
the associated range refers to input record numbers.
<br/>
<div>&#x00A0;</div>
<i>f</i>
<br/>
-
<br/>
the associated range refers to input field numbers.
<br/>
<div>&#x00A0;</div>
<i>c</i>
<br/>
-
<br/>
the associated range refers to input record character lengths.
<br/>
<div>&#x00A0;</div>
<i>&lt;r1&gt;</i>
<br/>
-
<br/>
integer representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;r2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
<i>&lt;string&gt;</i>
<br/>
-
<br/>
the specified <i>&lt;string&gt;</i> must also exist within the range.
<div>&#x00A0;</div>
Expel criteria types can be intermixed.
<div>&#x00A0;</div>
E.g. -E n10-$,f7-8,f4/Mercedes/,c10-20,c1-15/SUV/
<div>&#x00A0;</div>
this is saying that input records whose record number is greater than or equal
  to 10, AND input records whose total number of fields are between 7 and 8, AND
  input records whose 4th input field contains the string &quot;Mercedes&quot;,
  AND input records whose input record length is greater than or equal to 10 but
  less than or equal to 20 characters, AND input records whose first 15
  characters contain the string &quot;SUV&quot;, will finally match the input
  record expel criteria.
<div>&#x00A0;</div>
In this release you can only specify the $ token (last input record) in a paired
  range and not on its own.
<div>&#x00A0;</div>
Generally xmlfy can figure out where the search string delimiters would likely
  occur however you can specify the % character as an alternative separator to /
  for <i>&lt;string&gt;</i> so long as it remains paired.
<div>&#x00A0;</div>
If an <i>&lt;input_fields&gt;</i> criteria is not specified then the entire
  input record is expelled.
<br/>
<div>&#x00A0;</div>
<i>&lt;input_fields&gt;</i>
<br/>
-
<br/>
A comma delimited set of field number ranges with no spaces.
<div>&#x00A0;</div>
The <i>&lt;input_fields&gt;</i> parameter has a sub form of
  <i>&lt;r1&gt;</i>[<b>-</b><i>&lt;r2&gt;</i>][<b>,</b>..]
<div>&#x00A0;</div>
<i>&lt;r1&gt;</i>
<br/>
-
<br/>
integer or the $ token representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;r2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
Discard select input fields of the input records that match the expel criteria
  before passing onto the xmlfy output processor.
<div>&#x00A0;</div>
E.g. -E n2-$:1,$ this is saying that input records whose record number is
  greater than or equal to 2 will have their first and last fields expelled.
<div>&#x00A0;</div>
You can specify the $ token (last input field) in a paired range or on its own.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can use single or double quotes to protect the range from the shell
  interpreter e.g. -E 'n2-$:$'
<br/>
<div>&#x00A0;</div>
o
<br/>
If a schema is used then obviously the number of input records/fields used for
  element matching has been reduced.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one parameter group can be specified however this option can be invoked
  multiple times with resolution occurring from left to right.
<br/>
<div class="Pp"></div>
<b>Option: -q</b>, <b>--quotedfields</b>[<i>2</i>]
<div>&#x00A0;</div>
Treat fields that are quoted as one field. Normally xmlfy will parse fields by
  their delimiter e.g. WHITESPACE, this option allows multi delimited fields to
  be specified as one by quoting them. By default the quoted field may only span
  the current input record unless the <b>-q2</b> option is specified in which
  case the quoted field can span multiple input records.
<div>&#x00A0;</div>
Quotes are not included in the field and any leading/trailing text outside the
  field's quotes are truncated.
<div>&#x00A0;</div>
If quotes are not closed xmlfy will update the field until the end of the input
  record, or if option <b>-q2</b> is specified, until the input is exhausted
  (EOF).
<div>&#x00A0;</div>
The default quote character is a double quote (&quot;).
<div class="Pp"></div>
<b>Option: -Q</b>, <b>--quotechars</b>[<i>2</i>] <i>&lt;string&gt;</i>
<div>&#x00A0;</div>
specify a string of characters that can be used as the quoting character.
<div>&#x00A0;</div>
<i>&lt;string&gt;</i>
<br/>
-
<br/>
an array of quoting characters.
<br/>
<div>&#x00A0;</div>
o
<br/>
If field quoting is enabled then any input character that matches any character
  in <i>&lt;string&gt;</i> will toggle the quoting function, unless the
  <b>-Q2</b> option is specified in which case characters in
  <i>&lt;string&gt;</i> represent paired quotes with odd numbered characters in
  this array toggling the open quote function, and its corresponding pair
  toggling the close quote function. This allows parenthesis, brackets, etc to
  be used as quotes.
<br/>
<div>&#x00A0;</div>
o
<br/>
Obviously when specifying this option care must be taken to prevent the shell
  from interpreting the supplied quote characters. When using a schema file
  containing this option you can specify quote characters by escaping them with
  the backslash &quot;\&quot; character.
<br/>
<div class="Pp"></div>
<b>Option: -b</b>, <b>--blanklines</b>
<div>&#x00A0;</div>
Normally xmlfy ignores blank lines or empty level 1 records in the input stream.
  This option tells xmlfy to not ignore these blank lines and print out XML line
  record tags but with no elements.
<div>&#x00A0;</div>
In this mode blank lines count as line numbers.
<div class="Pp"></div>
<b>Option: -t</b>, <b>--trim</b>
<div>&#x00A0;</div>
Field elements are trimmed of leading and trailing white space.
<div class="Pp"></div>
Output options:
<div class="Pp"></div>
<b>Option: -S</b>, <b>--schema </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<br/>
<b>-Sd</b>, <b>--schemadtd </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<b>-Sr</b>, <b>--schemarnc </b><i>&lt;file&gt;</i>
<div>&#x00A0;</div>
<b>-Sx</b>, <b>--schemaxsd </b><i>&lt;file&gt;</i>
<br/>
<div>&#x00A0;</div>
Specify a schema <i>&lt;file&gt;</i> for controlling the XML output.
<div>&#x00A0;</div>
<i>&lt;file&gt;</i>
<br/>
-
<br/>
The schema file must comply with either the Document Type Definition (.dtd)
  language, or the RELAX NG Compact (.rnc) language, or the XML Schema Document
  (.xsd) language, however xmlfy does not support the finer aspects of these
  schema languages at this early stage.
<br/>
<div>&#x00A0;</div>
o
<br/>
When all input fields of the input record have been identified, xmlfy will match
  them against the elements inside the tree hierarchy of the schema file, and if
  a match is found then xmlfy will print an output record using the matching
  schema tree hierarchy as its XML structure.
<div>&#x00A0;</div>
Option <b>-S</b>, <b>--schema</b> uses the case-insensitive file name extension
  (.dtd or .rnc or .xsd) of <i>&lt;file&gt;</i> to determine which schema
  interpreter xmlfy will apply.
<div>&#x00A0;</div>
Option <b>-Sd</b>, <b>--schemadtd</b> forces xmlfy to use the DTD schema
  interpreter on <i>&lt;file&gt;</i>.
<div>&#x00A0;</div>
Option <b>-Sr</b>, <b>--schemarnc</b> forces xmlfy to use the RNC schema
  interpreter on <i>&lt;file&gt;</i>.
<div>&#x00A0;</div>
Option <b>-Sx</b>, <b>--schemaxsd</b> forces xmlfy to use the XSD schema
  interpreter on <i>&lt;file&gt;</i>.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can specify multi level delimiters when using this option however any
  delimiters greater than level 2 are only used to identify more input fields
  and are not used at all in altering the XML tree hierarchy as is dictated by
  the schema file. Fields with levels of 2 and above are flattened to be just
  plain fields of the input record - this is very different to the default
  behaviour where field levels form the XML tree hierarchy.
<br/>
<div>&#x00A0;</div>
o
<br/>
If a schema option is not supplied then xmlfy will use default values for tag
  names and element control.
<br/>
<div>&#x00A0;</div>
o
<br/>
For further information on how to write a schema for xmlfy please consult the
  web documentation.
<br/>
<div class="Pp"></div>
<b>Option: -M</b>, <b>--matchdirect</b> <i>0</i>|<i>&lt;elementname&gt;</i>
<div>&#x00A0;</div>
Match directly on a specific element in the schema making it the root element.
<div>&#x00A0;</div>
<i>0</i>
<br/>
-
<br/>
A token representing the default root element in the schema.
<br/>
<div>&#x00A0;</div>
<i>&lt;elementname&gt;</i>
<br/>
-
<br/>
The name of a record element in the schema.
<br/>
<div>&#x00A0;</div>
o
<br/>
This option alters the way the selected schema element is matched against the
  available input fields that were generated. In this mode the target element is
  matched in its entirety using its element helper and printed accordingly. This
  is very different to the default legacy mode whereby only the record elements
  of the root element get matched in a continuously sequential way.
<br/>
<div>&#x00A0;</div>
o
<br/>
Regardless of what wildcard attributes exist for the target element it will only
  be printed once as a root element.
<br/>
<div>&#x00A0;</div>
o
<br/>
If a schema file is not specified then this option will be ignored.
<br/>
<div class="Pp"></div>
<b>Option: -A</b>,
  <b>--attribute</b>[<i>&lt;level&gt;</i>[<b>:</b><i>&lt;scope&gt;</i>]]
  <i>number</i>| <i>level</i>
<div>&#x00A0;</div>
<br/>
| <i>delimiter</i>|<i>timestamp</i>|<i>insert &lt;name&gt; &lt;value&gt;</i>
<br/>
<div>&#x00A0;</div>
Include attributes in the opening element tag for the level specified.
<div>&#x00A0;</div>
<i>&lt;level&gt;</i>
<br/>
-
<br/>
The XML depth level to be modified.
<div>&#x00A0;</div>
Must be an integer value greater than or equal to 0.
<div>&#x00A0;</div>
E.g. a value of 1 will apply attributes to each opening record element and a
  value of 2 will apply attributes to each opening field element.
<div>&#x00A0;</div>
There is no space separating the option and the level value.
<div>&#x00A0;</div>
If no level is specified then the given options will apply to all levels except
  level 0.
<br/>
<div>&#x00A0;</div>
<i>&lt;scope&gt;</i>
<br/>
-
<br/>
A comma delimited set of sequence ranges with no spaces.
<div>&#x00A0;</div>
The <i>&lt;scope&gt;</i> parameter has a sub form of
  <i>&lt;s1&gt;</i>[-<i>&lt;s2&gt;</i>][ <i>r</i>][<b>,</b>..]
<div>&#x00A0;</div>
<i>&lt;s1&gt;</i>
<br/>
-
<br/>
integer representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;s2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
<i>r</i>
<br/>
-
<br/>
restart the scope counter for this attribute after the completion of the
  associated range.
<br/>
<div>&#x00A0;</div>
Restrict the custom attribute effectiveness to the occurrences specified in
  <i>&lt;scope&gt;</i>. If the element sequence is not in the scope then the
  custom attribute will not be applied.
<div>&#x00A0;</div>
The restart scope counter option <i>r</i> allows the scope sequences to
  continually repeat themselves. E.g -A2:1-3,5r insert x y this is saying insert
  custom attributes x=&quot;y&quot; for every first to third and fifth level 2
  elements, and keep repeating this until the output is exhausted.
<div>&#x00A0;</div>
Scope sequence counters are always reset to zero for the next element depth
  level and higher whenever a deeper XML depth level is entered into.
<div>&#x00A0;</div>
If a <i>&lt;scope&gt;</i> range is not specified then the custom attribute
  function applies to all elements at the specified <i>&lt;level&gt;</i>.
<br/>
<div>&#x00A0;</div>
<i>number</i>
<br/>
-
<br/>
Specify the sequence number as an element attribute.
<div>&#x00A0;</div>
E.g. &lt;field&gt; becomes &lt;field number=&quot;1&quot;&gt; and the next
  &lt;field&gt; becomes &lt;field number=&quot;2&quot;&gt; and so on.
<div>&#x00A0;</div>
Scoping is not supported.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
<i>level</i>
<br/>
-
<br/>
Specify the level as an element attribute.
<div>&#x00A0;</div>
E.g. &lt;field&gt; becomes &lt;field level=&quot;2&quot;&gt;
<div>&#x00A0;</div>
Scoping is not supported.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
<i>delimiter</i>
<br/>
-
<br/>
Specify the matching delimiter as an element attribute.
<div>&#x00A0;</div>
E.g. &lt;field&gt; becomes &lt;field delimiter=&quot;ABC&quot;&gt;
<div>&#x00A0;</div>
Delimiter string tokens that contain illegal XML characters are printed as their
  hex pair equivalent.
<div>&#x00A0;</div>
When using a schema file only level 1 records and field elements will have their
  delimiter attributes printed.
<div>&#x00A0;</div>
Scoping is not supported.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
<i>timestamp</i>
<br/>
-
<br/>
Include a timestamp as an element attribute.
<div>&#x00A0;</div>
Two timestamps are provided, one for humans and one for machines. The times are
  stamped at element print time.
<div>&#x00A0;</div>
E.g. &lt;field&gt; becomes &lt;field timestamp_date=&quot;Fri May 5 10:23:33
  2008&quot; timestamp_sec=&quot;123456790&quot;&gt;
<div>&#x00A0;</div>
Scoping is not supported.
<br/>
<div>&#x00A0;</div>
<i>insert &lt;name&gt; &lt;value&gt;</i>
<br/>
-
<br/>
Insert a custom element attribute.
<div>&#x00A0;</div>
The parameters <i>&lt;name&gt;</i> and <i>&lt;value&gt;</i> are combined to form
  an element attribute with <i>&lt;value&gt;</i> wrapped around double quotes.
<div>&#x00A0;</div>
E.g &lt;field&gt; becomes &lt;field name=&quot;value&quot;&gt;
<div>&#x00A0;</div>
You can pretty much specify anything as an attribute name and value including
  illegal XML therefore user discretion is advised.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one parameter group can be specified however this option can be invoked
  multiple times.
<br/>
<div class="Pp"></div>
<b>Option: -T</b>,
  <b>--tag</b>[<i>&lt;level&gt;</i>[<b>:</b><i>&lt;scope&gt;</i>]]
  <i>number</i>| <i>level</i>
<div>&#x00A0;</div>
<br/>
| <i>name &lt;name&gt;</i>
<div>&#x00A0;</div>
|[ <i>re</i>]<i>insert &lt;name&gt; &lt;value&gt;</i>
<div>&#x00A0;</div>
|[ <i>re</i>]<i>insertfile &lt;name&gt; &lt;file&gt;</i>
<div>&#x00A0;</div>
|[ <i>re</i>]<i>insertfilexml &lt;indent&gt; &lt;file&gt;</i>
<br/>
<div>&#x00A0;</div>
Modify or insert element tags for the level specified.
<div>&#x00A0;</div>
<i>&lt;level&gt;</i>
<br/>
-
<br/>
The XML depth level to be modified.
<div>&#x00A0;</div>
Must be an integer value greater than or equal to 0.
<div>&#x00A0;</div>
E.g. a value of 1 will modify the tag name for each record and a value of 2 will
  modify the tag name for each field.
<div>&#x00A0;</div>
There is no space separating the option and the level value.
<div>&#x00A0;</div>
If no level is specified then the given options will apply to all levels except
  level 0.
<br/>
<div>&#x00A0;</div>
<i>&lt;scope&gt;</i>
<br/>
-
<br/>
A comma delimited set of sequence ranges with no spaces.
<div>&#x00A0;</div>
The <i>&lt;scope&gt;</i> parameter has a sub form of
  <i>&lt;s1&gt;</i>[-<i>&lt;s2&gt;</i>][ <i>r</i>][<b>,</b>..]
<div>&#x00A0;</div>
<i>&lt;s1&gt;</i>
<br/>
-
<br/>
integer representing a start range.
<br/>
<div>&#x00A0;</div>
<i>&lt;s2&gt;</i>
<br/>
-
<br/>
integer or the $ token representing an end range.
<br/>
<div>&#x00A0;</div>
<i>r</i>
<br/>
-
<br/>
restart the scope counter for this tag after the completion of the associated
  range.
<br/>
<div>&#x00A0;</div>
Restrict the custom tag effectiveness to the occurrences specified in
  <i>&lt;scope&gt;</i>. If the element sequence is not in the scope then the
  custom tag will not be applied.
<div>&#x00A0;</div>
The restart scope counter option <i>r</i> allows the scope sequences to
  continually repeat themselves. E.g -T2:1-3,5r insert x y this is saying insert
  the custom tag &lt;x&gt;y&lt;/x&gt; before every first to third and fifth
  level 2 elements, and keep repeating this until the output is exhausted.
<div>&#x00A0;</div>
Scope sequence counters are always reset to zero for the next element depth
  level and higher whenever a deeper XML depth level is entered into.
<div>&#x00A0;</div>
If a <i>&lt;scope&gt;</i> range is not specified then the custom tag function
  applies to all elements at the specified <i>&lt;level&gt;</i>.
<br/>
<div>&#x00A0;</div>
<i>number</i>
<br/>
-
<br/>
Suffix the tag name with its sequence number.
<div>&#x00A0;</div>
E.g. &lt;line&gt; becomes &lt;line1&gt; and the next &lt;line&gt; becomes
  &lt;line2&gt; and so on.
<div>&#x00A0;</div>
Scoping is not supported.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
<i>level</i>
<br/>
-
<br/>
Prefix the tag name with its level.
<div>&#x00A0;</div>
E.g. &lt;field&gt; becomes &lt;L2field&gt;
<div>&#x00A0;</div>
Scoping is not supported.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
<i>name &lt;name&gt;</i>
<br/>
-
<br/>
Change the tag name from the default to <i>&lt;name&gt;</i>
<div>&#x00A0;</div>
Only applicable for changing default behaviour (i.e. when the --schema option is
  NOT specified).
<div>&#x00A0;</div>
E.g. &lt;field&gt; becomes &lt;word&gt;
<div>&#x00A0;</div>
You can pretty much specify anything as a tag name including illegal XML
  therefore user discretion is advised.
<div>&#x00A0;</div>
Scoping is not supported.
<br/>
<div>&#x00A0;</div>
[ <i>re</i>]<i>insert &lt;name&gt; &lt;value&gt;</i>
<br/>
-
<br/>
Insert a custom element tag.
<div>&#x00A0;</div>
The parameters <i>&lt;name&gt;</i> and <i>&lt;value&gt;</i> are combined to form
  an element tag with <i>&lt;value&gt;</i> wrapped between <i>&lt;name&gt;</i>
  tag pairs. E.g &lt;name&gt;value&lt;/name&gt;
<div>&#x00A0;</div>
The inserted element appears before any output elements for the level specified.
<div>&#x00A0;</div>
The reinsert feature keeps applying itself at the level specified.
<div>&#x00A0;</div>
You can pretty much specify anything as an element name and value including
  illegal XML therefore user discretion is advised.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
[ <i>re</i>]<i>insertfile &lt;name&gt; &lt;file&gt;</i>
<br/>
-
<br/>
Insert a custom element tag containing contents of a file.
<div>&#x00A0;</div>
The contents of <i>&lt;file&gt;</i> are wrapped between <i>&lt;name&gt;</i> tag
  pairs.
<div>&#x00A0;</div>
The encoding of <i>&lt;file&gt;</i> must match the output encoding being used
  otherwise an undesirable output will result.
<div>&#x00A0;</div>
Any BOM found in <i>&lt;file&gt;</i> is removed.
<div>&#x00A0;</div>
Any reserved XML characters in <i>&lt;file&gt;</i> are escaped, and newlines are
  corrected.
<div>&#x00A0;</div>
The inserted element appears before any output elements for the level specified.
<div>&#x00A0;</div>
The reinsert feature keeps applying itself at the level specified.
<div>&#x00A0;</div>
You can pretty much specify anything as an element name including illegal XML
  therefore user discretion is advised.
<div>&#x00A0;</div>
Not supported for level 0.
<br/>
<div>&#x00A0;</div>
[ <i>re</i>]<i>insertfilexml &lt;indent&gt; &lt;file&gt;</i>
<br/>
-
<br/>
Insert contents of an XML file.
<div>&#x00A0;</div>
The entire contents of <i>&lt;file&gt;</i> are inserted before any output
  elements for the level specified.
<div>&#x00A0;</div>
The encoding of <i>&lt;file&gt;</i> must match the output encoding being used
  otherwise an undesirable output will result.
<div>&#x00A0;</div>
Any BOM found in <i>&lt;file&gt;</i> is removed.
<div>&#x00A0;</div>
If the parameter <i>&lt;indent&gt;</i> is an integer value greater than or equal
  to zero then the contents of file are indented by this amount, any XML
  prologue is removed, and newlines are corrected.
<div>&#x00A0;</div>
If the parameter <i>&lt;indent&gt;</i> is the value &quot;raw&quot; then the XML
  file is inserted as is without its BOM.
<div>&#x00A0;</div>
The reinsert feature keeps applying itself at the level specified.
<div>&#x00A0;</div>
You can pretty much insert anything as XML file content including illegal XML
  therefore user discretion is advised.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one parameter group can be specified however this option can be invoked
  multiple times.
<br/>
<div class="Pp"></div>
<b>Option: -k</b>, <b>--keyvaluepairs</b>[<i>&lt;level&gt;</i>]
<div>&#x00A0;</div>
Switch on the generation of key/value XML tag pairs for the output.
<div>&#x00A0;</div>
<i>&lt;level&gt;</i>
<br/>
-
<br/>
The XML depth level to be modified.
<div>&#x00A0;</div>
Must be an integer value greater than or equal to 2.
<div>&#x00A0;</div>
There is no space separating the option and the level value.
<div>&#x00A0;</div>
If no level is specified then the option will apply to all levels except levels
  0 and 1.
<br/>
<div>&#x00A0;</div>
o
<br/>
In this mode the data of the first field of the current XML level becomes the
  tag name for that level, that is, it becomes the key, and any subsequent
  fields become its value.
<br/>
<div>&#x00A0;</div>
o
<br/>
This key/value pairing continues down the XML tree hierarchy for all the XML
  levels specified.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can pretty much generate anything as a tag name including illegal XML
  therefore user discretion is advised. The new tag name is trimmed of leading
  and trailing white space and white space between text is replaced with the
  underscore &quot;_&quot; character.
<br/>
<div>&#x00A0;</div>
o
<br/>
If a blank field becomes a tag name candidate then xmlfy will skip it and search
  along the same level for a more suitable candidate. This behaviour can be
  mitigated by using the <b>-b</b> option which will force the default tag name
  to be substituted instead.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only applicable for changing default behaviour (i.e. when the --schema option is
  NOT specified).
<br/>
<div>&#x00A0;</div>
o
<br/>
This option can be invoked multiple times.
<br/>
<div class="Pp"></div>
<b>Option: -l</b>, <b>--linenumbers</b>
<div>&#x00A0;</div>
This is a synonym for &quot;-T1 number&quot;
<div>&#x00A0;</div>
Include the line number in the line tag name
<div class="Pp"></div>
<b>Option: -f</b>, <b>--fieldnumbers</b>
<div>&#x00A0;</div>
This is a synonym for &quot;-T2 number&quot;
<div>&#x00A0;</div>
include the field number in the field tag name
<div class="Pp"></div>
<b>Option: -L</b>, <b>--linetags</b>
<div>&#x00A0;</div>
Insert a line number tag within the XML formatted output.
<div>&#x00A0;</div>
This is an alternative way of numbering your XML records. E.g. for the first
  line record of XML output the following tag is inserted
  &lt;linenumber&gt;1&lt;/linenumber&gt; and so on.
<div class="Pp"></div>
<b>Option: -X</b>, <b>--xmlformat
  [</b><i>XML1.0</i>|<i>XML1.1</i>]|[<i>SOAP1.1</i>| <i>SOAP1.2</i>]|[<i>HTML
  table</i>| <i>list</i>]
<div>&#x00A0;</div>
<br/>
|[
  <i>UTF-8</i>|<i>UTF-16</i>|<i>UTF-16BE</i>|<i>UTF-16LE</i>|<i>UTF-32</i>|<i>UTF-32BE</i>|
  <i>UTF-32LE</i>]|<i>BOM</i>
<div>&#x00A0;</div>
| <i>ASCIItoUTF</i>|[<i>noescape
  all</i>|<i>amp</i>|<i>lt</i>|<i>gt</i>|<i>quot</i>| <i>apos</i>|<i>brvbar</i>]
<div>&#x00A0;</div>
| <i>trimtagclose</i>|[<i>newline dos</i>|<i>unix</i>]
<br/>
<div>&#x00A0;</div>
Allows you to specify the XML format to be used for the output.
<div>&#x00A0;</div>
<i>XML1.0</i> - Generate XML 1.0 output (this is the default).
<div>&#x00A0;</div>
<i>XML1.1</i> - Generate XML 1.1 output.
<div>&#x00A0;</div>
<i>SOAP1.1</i> - Generate XML SOAP 1.1 output.
<div>&#x00A0;</div>
<i>SOAP1.2</i> - Generate XML SOAP 1.2 output.
<div>&#x00A0;</div>
<i>HTML</i>
<br/>
-
<br/>
Generate HTML output.
<div>&#x00A0;</div>
<i>table</i>
<br/>
-
<br/>
elements are displayed in table format.
<br/>
<div>&#x00A0;</div>
<i>list</i>
<br/>
-
<br/>
elements are displayed in list format.
<br/>
<br/>
<div>&#x00A0;</div>
<i>UTF-8</i> - Generate UTF-8 output encoding (default).
<div>&#x00A0;</div>
<i>UTF-16</i> - Generate UTF-16 output encoding.
<div>&#x00A0;</div>
<i>UTF-16BE</i> - Generate UTF-16BE (big-endian) output encoding.
<div>&#x00A0;</div>
<i>UTF-16LE</i> - Generate UTF-16LE (little-endian) output encoding.
<div>&#x00A0;</div>
<i>UTF-32</i> - Generate UTF-32 output encoding.
<div>&#x00A0;</div>
<i>UTF-32BE</i> - Generate UTF-32BE (big-endian) output encoding.
<div>&#x00A0;</div>
<i>UTF-32LE</i> - Generate UTF-32LE (little-endian) output encoding.
<div>&#x00A0;</div>
<i>BOM</i> - Generate and interpret a Byte-Order-Mark.
<div>&#x00A0;</div>
<i>ASCIItoUTF</i> - Convert ASCII input to wide UTF encoding.
<div>&#x00A0;</div>
<i>noescape</i>
<br/>
-
<br/>
Do not escape select reserved XML characters. By default xmlfy will escape
  reserved XML characters that appear in the input stream and this option
  provides an adjustment to this behaviour.
<div>&#x00A0;</div>
<i>all</i> - do not escape any characters.
<div>&#x00A0;</div>
<i>amp</i> - do not escape the character &amp; (ampersand).
<div>&#x00A0;</div>
<i>lt</i> - do not escape the character &lt; (less-than).
<div>&#x00A0;</div>
<i>gt</i> - do not escape the character &gt; (greater-than).
<div>&#x00A0;</div>
<i>quot</i> - do not escape the character &quot; (quote).
<div>&#x00A0;</div>
<i>apos</i> - do not escape the character ' (apostrophe).
<div>&#x00A0;</div>
<i>brvbar</i>
<br/>
-
<br/>
do not escape the character | (broken vertical bar).
<br/>
<br/>
<div>&#x00A0;</div>
<i>trimtagclose</i>
<br/>
-
<br/>
Truncate superfluous characters from the closing tag name.
<br/>
<div>&#x00A0;</div>
<i>newline</i>
<br/>
-
<br/>
Select the line ending format for XML meta-data.
<div>&#x00A0;</div>
<i>dos</i>
<br/>
-
<br/>
use carriage-return and new-line (&quot;\r\n&quot;) for line endings.
<br/>
<div>&#x00A0;</div>
<i>unix</i>
<br/>
-
<br/>
use new-line (&quot;\n&quot;) for line endings.
<br/>
<br/>
<div>&#x00A0;</div>
o
<br/>
The only thing option <i>XML1.1</i> does is change the prologue version string
  to &quot;1.1&quot; and nothing else.
<br/>
<div>&#x00A0;</div>
o
<br/>
When using the <i>SOAP*</i> options, the normal XML output generated by xmlfy is
  encapsulated in a SOAP Envelope and SOAP Body, the root tag defines a
  namespace prefix of &quot;x&quot; with a URI reference that can be adjusted
  with the -I option, and all children elements (records and fields) use this
  prefix name.
<div>&#x00A0;</div>
A non-mandatory administrative header element with a prefix name of
  &quot;xh&quot; is provided containing program and execution details.
<div>&#x00A0;</div>
The <i>SOAP*</i> options are only a basic implementation for generating a simple
  XML SOAP envelope containing xmlfy data. There is no further scope provided
  for SOAP Headers, SOAP Faults, transaction or protocol handling.
<br/>
<div>&#x00A0;</div>
o
<br/>
When using the <i>HTML</i> option, the normal XML output generated by xmlfy is
  displayed in either a table or list layout and encapsulated in a HTML Body, of
  which the document title can be adjusted with the -I option.
<br/>
<div>&#x00A0;</div>
o
<br/>
The <i>UTF-*</i> options tell xmlfy to use the specified encoding for all its
  XML meta-data (element tags, element attributes, prologues, etc). Other than
  the <i>ASCIItoUTF</i> option, no transformation of the input stream is
  performed and xmlfy assumes that the encoding used by the input stream matches
  the encoding specified, otherwise an undesirable output will result containing
  different encodings between the input data and XML meta-data.
<div>&#x00A0;</div>
If specifying the <i>UTF-16</i> or <i>UTF-32</i> parameter and the <i>BOM</i>
  option is either not specified or there is no BOM in the input stream then
  encoding in big-endian format will be assumed.
<br/>
<div>&#x00A0;</div>
o
<br/>
The <i>BOM</i> (Byte-Order-Mark) option will force xmlfy to handle the BOM in
  the input stream if it is there, and also generate a BOM in the output stream.
  If specifying the <i>BOM</i> option and a BOM is found in the input stream
  then that will overide any user specified encoding option.
<div>&#x00A0;</div>
The BOM byte sequence used for UTF-8 is 0xef 0xbb 0xbf (U+FEFF).
<div>&#x00A0;</div>
The BOM byte sequence used for UTF-16BE is 0xfe 0xff (U+FEFF).
<div>&#x00A0;</div>
The BOM byte sequence used for UTF-16LE is 0xff 0xfe (U+FFFE).
<div>&#x00A0;</div>
The BOM byte sequence used for UTF-32BE is 0x00 0x00 0xfe 0xff (U+FEFF).
<div>&#x00A0;</div>
The BOM byte sequence used for UTF-32LE is 0xff 0xfe 0x00 0x00 (U+FFFE).
<br/>
<div>&#x00A0;</div>
o
<br/>
The <i>ASCIItoUTF</i> option when used in conjunction with one of the
  <i>UTF-*</i> options will process ASCII input and convert it to the wide UTF
  encoding specified.
<br/>
<div>&#x00A0;</div>
o
<br/>
The <i>noescape</i> options control which reserved XML characters should not be
  escaped.
<br/>
<div>&#x00A0;</div>
o
<br/>
The <i>trimtagclose</i> option trims back the closing tag from the first white
  space character found. Some options allow the user to define anything as a tag
  name including tag names that have element attributes (non normal approach).
  Using this option under these circumstances will prevent these element
  attributes from appearing in the close tag.
<br/>
<div>&#x00A0;</div>
o
<br/>
The <i>newline</i> option adjusts the line ending format used for XML meta-data.
  On Unix platforms the default is <i>unix</i> and on Win32 platforms the
  default is <i>dos</i>. Only applies to XML meta-data output and does not do
  conversion of newline characters found in the input stream.
<br/>
<div>&#x00A0;</div>
o
<br/>
Only one parameter group can be specified however this option can be invoked
  multiple times.
<br/>
<div class="Pp"></div>
<b>Option: -p</b>, <b>--printonly
  </b><i>header</i>|<i>footer</i>|<i>rtagopen</i>|
  <i>rtagclose</i>|<i>records</i>
<div>&#x00A0;</div>
Allows you to just print XML snippets to the output.
<div>&#x00A0;</div>
This is useful when you want to execute xmlfy multiple times to construct a
  single XML output file.
<div>&#x00A0;</div>
<i>header</i>
<br/>
-
<br/>
Will only print the prologue, doctype, opened SOAP Envelope and Body tags, the
  SOAP Header tag, HTML headers, and the BOM.
<br/>
<div>&#x00A0;</div>
<i>footer</i>
<br/>
-
<br/>
Will only print closed SOAP Envelope and Body tags, and closed HTML tags.
<br/>
<div>&#x00A0;</div>
<i>rtagopen</i> - Will only print an opened root element tag.
<div>&#x00A0;</div>
<i>rtagclose</i> - Will only print a closed root element tag.
<div>&#x00A0;</div>
<i>records</i> - Will only print record elements and their field elements.
<div>&#x00A0;</div>
o
<br/>
Only one parameter can be specified however this option can be invoked multiple
  times.
<br/>
<div class="Pp"></div>
<b>Option: -I</b>, <b>--identifier </b><i>&lt;system_identifier&gt;</i>
<div>&#x00A0;</div>
Allows you to specify your own system identifier of the doctype should you not
  be content with what xmlfy has specified.
<div>&#x00A0;</div>
<i>system_identifier</i>
<br/>
-
<br/>
An array of characters used to override the default system identifier.
<div>&#x00A0;</div>
You can pretty much specify anything as a system identifier including illegal
  XML therefore user discretion is advised.
<br/>
<div>&#x00A0;</div>
o
<br/>
By default xmlfy will use the string &quot;xmlfy.dtd&quot;, or if specifying a
  schema, use the schema filename as the system identifier.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can also use this option to overide the default SOAP namespace URI value for
  the root element when using the XML SOAP format options.
<br/>
<div>&#x00A0;</div>
o
<br/>
You can also use this option to overide the document title in the HTML header
  when using the XML HTML format options.
<br/>
<div class="Pp"></div>
<b>Option: -s</b>, <b>--summary</b>[<i>2</i>|<i>c</i>|<i>n</i>|<i>f
  &lt;file&gt;</i>]
<div>&#x00A0;</div>
When all input is exhausted an XML summary element is printed at the bottom
  providing a brief summary of what xmlfy processed.
<div>&#x00A0;</div>
<i>2</i>
<br/>
-
<br/>
Print the summary element to stderr instead.
<br/>
<div>&#x00A0;</div>
<i>c</i>
<br/>
-
<br/>
Print the summary element as an XML comment.
<br/>
<i>n</i>
<br/>
-
<br/>
Print the summary element without calculating any message digests.
<br/>
<i>f &lt;file&gt;</i>
<br/>
-
<br/>
Print the summary element to <i>&lt;file&gt;</i>.
<br/>
<div>&#x00A0;</div>
By default MD5 and SHA512 checksum elements are provided inside the summary
  called md5_input, md5_output, sha512_input and sha512_output. The md5_input
  and sha512_input checksums are a digest of all the input that was actually
  processed including any input BOM. The md5_output and sha512_output checksums
  are a digest of all the output including any output BOM that precedes the XML
  summary element. To correctly validate the output result against the output
  checksum you must first remove any summary element and summary comments from
  the output result.
<div class="Pp"></div>
<b>Option: -U</b>, <b>--unxml</b>
<div>&#x00A0;</div>
Read XML formatted input and remove all that bracket racket reverting your XML
  document back to a plain format. Can be used in conjunction with the
  <b>-F</b><i>&lt;level&gt; &lt;string&gt;</i> option to specify the delimiter
  to use for each XML depth level. Multiple same level <b>-F</b> options are
  meaningless in this context and delimiters are only inserted if more than one
  field is available to be delimited. Field separator scoping options are
  ignored. The default delimiter is a space character for XML depth levels of 2
  and above, and new-line for XML depth levels below 2. Tag names and their
  attributes are not included in the output, and anything between XML comments
  are filtered out. If there is a BOM in the input then xmlfy will use that for
  the encoding, otherwise xmlfy will look for the opening XML character sequence
  of &quot;&lt;?&quot; to determine the encoding being used. If neither of the
  previous methods found the correct encoding then you can use the <b>-X
  UTF-*</b> options as a fallback. Basic quoting options are also supported.
  Works best with XML output generated by xmlfy but can also be used with
  caution on other foreign XML documents.
<div class="Pp"></div>
<b>Option: --noxml</b>
<div>&#x00A0;</div>
Do not XML-fy the input stream but do process it for reserved XML characters
  (this feature was initially written for formatting the xmlfy HTML test reports
  that use wide encodings). Used in conjunction with the <b>-X</b> options to
  control the conversion of reserved characters and/or to transform the input
  stream to wide UTF encodings.
<div>&#x00A0;</div>
E.g. To transform an ASCII input stream to UTF-16BE encoding with a BOM:
<div>&#x00A0;</div>
xmlfy --noxml -X UTF-16BE -X ASCIItoUTF -X noescape all -X BOM
<div>&#x00A0;</div>
E.g. To just escape select reserved XML characters in an UTF-32LE input stream:
<div>&#x00A0;</div>
xmlfy --noxml -X UTF-32LE -X noescape amp
<div class="Pp"></div>
<b>Important note on specifying options.</b>
<div>&#x00A0;</div>
The way xmlfy handles options is very straightforward and can be easily confused
  if you don't follow the syntax specified for each option. The getopt library
  has been deliberately avoided to keep xmlfy portable.
<div class="Pp"></div>
xmlfy first evaluates options supplied on the command line, if a schema file is
  supplied then xmlfy will also look for options in that file and evaluate them
  too. See the schema file section below on how to specify xmlfy options inside
  a schema file.
<h1 class="Sh" title="Sh" id="OUTPUT"><a class="selflink" href="#OUTPUT">OUTPUT</a></h1>
<b>How it works.</b>
<div>&#x00A0;</div>
The input processor used by xmlfy block reads unprocessed bytes from standard
  input (stdin) and stores them in an array the size of a level 1 record. This
  level 1 record is then processed for fields and sub fields etc by marking
  their positions in this array. Dynamic memory handling is used.
<div class="Pp"></div>
The output processor used by xmlfy takes the results from the input processor
  and re-packages it with suitably encoded XML syntax. Any input characters that
  are reserved for XML are by default re-represented in their escaped form.
<div>&#x00A0;</div>
<br/>
Character &amp; (ampersand) becomes string &amp;amp;
<div>&#x00A0;</div>
Character &lt; (less-than) becomes string &amp;lt;
<div>&#x00A0;</div>
Character &gt; (greater-than) becomes string &amp;gt;
<div>&#x00A0;</div>
Character &quot; (quote) becomes string &amp;quot;
<div>&#x00A0;</div>
Character ' (apostrophe) becomes string &amp;apos;
<div>&#x00A0;</div>
Character | (broken vertical bar) becomes string &amp;brvbar;
<br/>
<div>&#x00A0;</div>
The output processor then writes processed bytes to a block buffer for printing
  to standard output (stdout).
<div class="Pp"></div>
<b>Using a schema file.</b>
<div>&#x00A0;</div>
The default schema used by xmlfy is hard coded and can be described as follows:
<div>&#x00A0;</div>
In DTD schema form:
<div>&#x00A0;</div>
<br/>
&lt;!ELEMENT xmlfy (line*)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT line (field*)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT field (#PCDATA)&gt;
<br/>
<div>&#x00A0;</div>
In RNC schema form:
<div>&#x00A0;</div>
<br/>
start = xmlfy
<div>&#x00A0;</div>
xmlfy = element xmlfy { line* }
<div>&#x00A0;</div>
line = element line { field* }
<div>&#x00A0;</div>
field = element field { text }
<br/>
<div>&#x00A0;</div>
In XSD schema form:
<div>&#x00A0;</div>
<br/>
&lt;xs:schema&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;xmlfy&quot;&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;line&quot; type=&quot;lineType&quot;
  minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:element&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:complexType name=&quot;lineType&quot;&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;field&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:complexType&gt;
<div>&#x00A0;</div>
&lt;/xs:schema&gt;
<br/>
<div class="Pp"></div>
A schema file for the ls -la command that produces output like this:
<div>&#x00A0;</div>
<br/>
total 73
<div>&#x00A0;</div>
drwx------+ 3 ag None 0 Apr 20 19:36 .
<div>&#x00A0;</div>
-rwxr-xr-x 1 ag None 15639 Apr 20 19:31 a.exe
<div>&#x00A0;</div>
-rwx------+ 1 ag None 6354 Apr 20 19:31 xmlfy.c
<div>&#x00A0;</div>
-rwx------+ 1 ag None 4901 Apr 19 2008 xmlfy.h
<br/>
<div class="Pp"></div>
In DTD schema form will look like this:
<div>&#x00A0;</div>
<br/>
&lt;!ELEMENT ls (total?), (file*)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT total (prompt, totalsize)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT file (permission?, blocks?, user?, group?, size?, date_M?, date_d?,
  date_ty?, fname)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_ty (date_y)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_ty (date_h, date_m)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT prompt (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT totalsize (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT permission (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT blocks (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT user (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT group (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT size (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_y (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_M (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_d (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_h (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT date_m (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT fname (#PCDATA)&gt;
<br/>
<div class="Pp"></div>
and should be saved to a file as ls.dtd and invoked as:
<div>&#x00A0;</div>
<br/>
% ls -la | xmlfy --schema ls.dtd -F3 :
<br/>
<div class="Pp"></div>
In RNC schema form will look like this:
<div>&#x00A0;</div>
<br/>
start = ls
<div>&#x00A0;</div>
ls = element ls { total? | file* }
<div>&#x00A0;</div>
total = element total { prompt, totalsize }
<div>&#x00A0;</div>
file = element file { permission?, blocks?, user?, group?, size?, date_M?,
  date_d?, date_ty?, fname }
<div>&#x00A0;</div>
date_ty = element date_ty { date_y }
<div>&#x00A0;</div>
date_ty |= element date_ty { date_h, date_m }
<div>&#x00A0;</div>
prompt = element prompt { text }
<div>&#x00A0;</div>
totalsize = element totalsize { text }
<div>&#x00A0;</div>
permission = element permission { text }
<div>&#x00A0;</div>
blocks = element blocks { text }
<div>&#x00A0;</div>
user = element user { text }
<div>&#x00A0;</div>
group = element group { text }
<div>&#x00A0;</div>
size = element size { text }
<div>&#x00A0;</div>
date_y = element date_y { text }
<div>&#x00A0;</div>
date_M = element date_M { text }
<div>&#x00A0;</div>
date_d = element date_d { text }
<div>&#x00A0;</div>
date_h = element date_h { text }
<div>&#x00A0;</div>
date_m = element date_m { text }
<div>&#x00A0;</div>
fname = element fname { text }
<br/>
<div class="Pp"></div>
and should be saved to a file as ls.rnc and invoked as:
<div>&#x00A0;</div>
<br/>
% ls -la | xmlfy --schema ls.rnc -F3 :
<br/>
<div class="Pp"></div>
In XSD schema form will look like this:
<div>&#x00A0;</div>
<br/>
&lt;xs:schema&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;ls&quot; type=&quot;lsType&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:complexType name=&quot;lsType&quot;&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;total&quot; type=&quot;totalType&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;file&quot; type=&quot;fileType&quot;
  minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:complexType&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:complexType name=&quot;totalType&quot;&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;prompt&quot; type=&quot;xs:string&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;totalsize&quot; type=&quot;xs:string&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:complexType&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:complexType name=&quot;fileType&quot;&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;permission&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;blocks&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;user&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;group&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;size&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;date_M&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;date_d&quot; type=&quot;xs:string&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;date_ty&quot; type=&quot;datetyType&quot;
  minOccurs=&quot;0&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;fname&quot; type=&quot;xs:string&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:complexType&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:complexType name=&quot;datetyType&quot;&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:choice&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;date_y&quot; type=&quot;xs:string&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;date_h&quot; type=&quot;xs:string&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;xs:element name=&quot;date_m&quot; type=&quot;xs:string&quot; /&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:sequence&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:choice&gt;
<div>&#x00A0;</div>
<br/>
 &lt;/xs:complexType&gt;
<div>&#x00A0;</div>
&lt;/xs:schema&gt;
<div class="Pp"></div>
and should be saved to a file as ls.xsd and invoked as:
<div>&#x00A0;</div>
<br/>
% ls -la | xmlfy --schema ls.xsd -F3 :
<br/>
<div class="Pp"></div>
Shoe-horning raw data into a structure defined by a schema is rather straight
  forward when the input fields have a one-to-one relationship with the fields
  of the schema elements, however if wildcard tokens and/or Boolean logic are
  employed in the schema then it becomes quite a challenge, sometimes even
  impossible, to be deterministic about which input field belongs to which
  schema field. Strictly speaking, the main function of the schema is to ensure
  XML is valid and to do this requires the XML document to already pre-exist. In
  xmlfy's case we are doing the reverse by building an XML document on the fly
  while following rules described by the schema - this is still okay and the
  resulting XML can be considered to be both valid and well formed.
<div class="Pp"></div>
xmlfy employs two techniques to help with this shoe-horning input data problem.
  The first technique xmlfy uses is recognising multiple element definitions
  that have the same name. This allows you to capture your schema elements under
  a variety of input circumstances without having to create a unique element for
  each circumstance - you can still do that if you want. The second technique
  xmlfy uses is auto-generated field match constraint helpers to assist in
  matching the input fields to the elements described by the schema. These
  helpers are useful in improving the speed of xmlfy particularly when using
  compound element structures and wildcard tokens in the schema hierarchy. After
  the schema file is loaded into memory, an array of helpers is generated for
  each element that describes all combinations of the schema tree traversal
  paths that can be taken and associates each combination with the minimum,
  maximum and last number of fields required for a match against the number of
  available input fields. For example, using the above schema a match will occur
  for:
<div>&#x00A0;</div>
<br/>
total(min=2, max=2, last=2) when input fields = 2.
<div>&#x00A0;</div>
file(min=1, max=9, last=1) when 1 &gt;= input fields &lt;= 9
<div>&#x00A0;</div>
and date_ty is a single field (min=1, max=1, last=1).
<div>&#x00A0;</div>
file(min=1, max=10, last=1) when 1 &gt;= input fields &lt;= 10
<div>&#x00A0;</div>
and date_ty is two fields (min=2, max=2, last=2).
<br/>
<div>&#x00A0;</div>
By default xmlfy continuously iterates through just the record elements of the
  root element looking for element helpers that can fully satisfy the
  requirements of that particular element's schema tree hierarchy for the given
  input fields, after which the matching record element is then checked against
  its wildcard obligations in the root element definition, and if okay is
  finally printed.
<div>&#x00A0;</div>
In match direct mode xmlfy only looks at the element helpers of the targeted
  element, and if that element can fully satisfy the requirements of its schema
  tree hierarchy for the given input fields, is printed in its entirety only
  once as the root element.
<div class="Pp"></div>
To specify xmlfy options inside a schema file you encapsulate them inside a
  special token that is in effect a schema comment.
<div>&#x00A0;</div>
<br/>
DTD and XSD example:
<div>&#x00A0;</div>
&lt;!-- xmlfy-args: -F1 &quot;\n&quot; -F2 ABC -q -Q \&quot;\' --&gt;
<div>&#x00A0;</div>
RNC example:
<div>&#x00A0;</div>
## xmlfy-args: -F1 &quot;\n&quot; -F2 ABC -q -Q \&quot;\'
<br/>
<div>&#x00A0;</div>
This special token must exist in completed form on just one line at the left
  most side, spacing is important, only the first occurrence is recognised, and
  ideally it is placed somewhere near the top of the schema file. The schema
  option syntax is the same as the command line option syntax except that some
  options are not allowed e.g. --schema.
<h1 class="Sh" title="Sh" id="LIMITATIONS"><a class="selflink" href="#LIMITATIONS">LIMITATIONS</a></h1>
xmlfy has been successfully tested on average hardware with input records
  containing over 10,000,000 fields whilst using a complex schema tree structure
  and multi level delimiters.
<div class="Pp"></div>
Currently the xmlfy schema file parser is not that sophisticated and exhibits
  the following behaviour:
<div class="Pp"></div>
<b>DTD schema</b>
<div>&#x00A0;</div>
-
<br/>
Only recognises the &lt;!ELEMENT&gt; directive and ignores all others.
<br/>
<div>&#x00A0;</div>
-
<br/>
The first valid &lt;!ELEMENT&gt; definition becomes the root element.
<br/>
<div>&#x00A0;</div>
-
<br/>
Element fields that don't have an element definition default to being (#PCDATA).
<br/>
<div>&#x00A0;</div>
-
<br/>
Elements defined as (#PCDATA) or (#CDATA) are ignored causing the referring
  field to default to (#PCDATA) however it is good practice to include these
  elements in order to furnish a complete DTD schema.
<br/>
<div>&#x00A0;</div>
-
<br/>
Only honours the +, ? and * wildcard tokens.
<br/>
<div>&#x00A0;</div>
-
<br/>
At this stage does not honour field group sets () and or-ing | syntax tokens.
<br/>
<div class="Pp"></div>
<b>RNC schema</b>
<div>&#x00A0;</div>
-
<br/>
Only recognises named directives and ignores all others.
<br/>
<div>&#x00A0;</div>
-
<br/>
The element named &quot;start&quot; becomes the root element.
<br/>
<div>&#x00A0;</div>
-
<br/>
Element fields that don't have an element definition default to being { text }.
<br/>
<div>&#x00A0;</div>
-
<br/>
Elements defined as { text } are ignored causing the referring field to default
  to { text } however it is good practice to include these elements in order to
  furnish a complete RNC schema.
<br/>
<div>&#x00A0;</div>
-
<br/>
Only honours the +, ? and * wildcard tokens.
<br/>
<div>&#x00A0;</div>
-
<br/>
At this stage does not honour field group sets () and or-ing | syntax tokens.
<br/>
<div class="Pp"></div>
<b>XSD schema</b>
<div>&#x00A0;</div>
-
<br/>
Only recognises the &lt;schema&gt;, &lt;element&gt;, &lt;complexType&gt;,
  &lt;ref&gt;, &lt;sequence&gt;, and &lt;choice&gt; directives and ignores all
  others.
<br/>
<div>&#x00A0;</div>
-
<br/>
The recognised directives are not fully implemented and their use should be kept
  straightforward.
<br/>
<div>&#x00A0;</div>
-
<br/>
The first valid &lt;element&gt; definition becomes the root element.
<br/>
<div>&#x00A0;</div>
-
<br/>
Element types that are not of matchable complexType are treated as
  &quot;xsi:string&quot; regardless of what type is specified.
<br/>
<div>&#x00A0;</div>
-
<br/>
Only honours the minOccurs=&quot;0&quot;, maxOccurs=&quot;0&quot; and
  maxOccurs=&quot;unbounded&quot; wildcard attributes.
<br/>
<div>&#x00A0;</div>
-
<br/>
At this stage does not honour group sets but does do limited support with
  choices.
<br/>
<div class="Pp"></div>
<b>All schema types</b>
<div>&#x00A0;</div>
-
<br/>
The fields of the root element define all the level 1 elements (lets call the
  fields that have their own branch structure record elements).
<br/>
<div>&#x00A0;</div>
-
<br/>
By default fields of the root element that are not record elements are ignored.
  Use the match direct option to match targeted elements in their entirety.
<br/>
<div>&#x00A0;</div>
-
<br/>
The fields of the record elements simply represent other elements and unlimited
  element nesting is allowed.
<br/>
<div>&#x00A0;</div>
-
<br/>
The field names that are specified in the element definitions are read from left
  to right and matched against a field number calculation on the input fields,
  and then matched again on any wildcard tokens.
<br/>
<div>&#x00A0;</div>
-
<br/>
You can wildcard many fields but you should think clearly about what you are
  trying to achieve and whether it is at all possible. For example, the
  following DTD which is perfectly suitable for checking for valid XML, will
  however prove impossible for xmlfy to shoe-horn input data into DTD elements
  a, b and c reliably because more than one field has a wildcard token to match
  none or many input fields.
<div>&#x00A0;</div>
<br/>
&lt;!ELEMENT parent (record)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT record (a*, b, c*)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT a (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT b (#PCDATA)&gt;
<div>&#x00A0;</div>
&lt;!ELEMENT c (#PCDATA)&gt;
<br/>
<div>&#x00A0;</div>
In the above example xmlfy will allocate ALL input fields to element &lt;a&gt;
  and that MAY not be the desired intention.
<br/>
<h1 class="Sh" title="Sh" id="RETURN_VALUES"><a class="selflink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<br/>
 0
<br/>
Normal exit.
<br/>
<div>&#x00A0;</div>
-1
<br/>
Invalid argument specified.
<br/>
<div>&#x00A0;</div>
-2
<br/>
Error processing schema file contents.
<br/>
<div>&#x00A0;</div>
-3
<br/>
Infinite loop detected when matching input against schema elements.
<br/>
<div>&#x00A0;</div>
-10
<br/>
Out of memory.
<br/>
<h1 class="Sh" title="Sh" id="AUTHOR"><a class="selflink" href="#AUTHOR">AUTHOR</a></h1>
Originally written by Arthur Gouros.
<div>&#x00A0;</div>
This software also contains material derived from Ville Laurikari's TRE regex
  library.
<div>&#x00A0;</div>
This software also contains material derived from the US Secure Hash Algorithms
  (RFC4634).
<div>&#x00A0;</div>
This software also contains material derived from the RSA Data Security, Inc.
  MD5 Message-Digest Algorithm.
<h1 class="Sh" title="Sh" id="LICENSE"><a class="selflink" href="#LICENSE">LICENSE</a></h1>
BSD License for xmlfy
<div>&#x00A0;</div>
Copyright &#x00A9; 2008-2013, Arthur Gouros
<div>&#x00A0;</div>
All rights reserved.
<div class="Pp"></div>
Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:
<div class="Pp"></div>
-
<br/>
Redistributions of source code must retain the above copyright notice, this list
  of conditions and the following disclaimer.
<br/>
<div>&#x00A0;</div>
-
<br/>
Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.
<br/>
<div>&#x00A0;</div>
-
<br/>
Neither the name of Arthur Gouros nor the names of its contributors may be used
  to endorse or promote products derived from this software without specific
  prior written permission.
<br/>
<div class="Pp"></div>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS
  IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
<h1 class="Sh" title="Sh" id="SEE_ALSO"><a class="selflink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The full documentation of the xmlfy project can be found on the web at:
<div class="Pp"></div>
<br/>
<b>http://xmlfy.sourceforge.net</b>
<br/>
<div class="Pp"></div>
The website is updated more frequently than the man pages and should be
  considered the authoritative source of information.</div>
<table class="foot">
  <tr>
    <td class="foot-date">April 4, 2013</td>
    <td class="foot-os">xmlfy 1.5.6</td>
  </tr>
</table>
</body>
</html>
