<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Aug 27 16:44:13 2017 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>xmlfy(1) User Commands xmlfy(1)</p>

<p style="margin-top: 1em">NAME <br>
xmlfy - Convert to XML on the fly.</p>

<p style="margin-top: 1em">SYNOPSIS <br>
xmlfy [OPTION]...</p>

<p style="margin-top: 1em">-h, --help <br>
print usage instructions</p>

<p style="margin-top: 1em">-v, --version <br>
print version number</p>

<p style="margin-top: 1em">--license <br>
print license</p>

<p style="margin-top: 1em">--debug <br>
print extra debugging information</p>

<p style="margin-top: 1em">Input options:</p>

<p style="margin-top: 1em">-F,
--fieldseparator[&lt;level&gt;[b][:&lt;scope&gt;]]
&lt;string&gt; <br>
specify a delimiter string token for the level specified</p>

<p style="margin-top: 1em">-R, --recordseparator
&lt;string&gt; <br>
this is a synonym for &quot;-F1 &lt;string&gt;&quot; <br>
specify an alternative record separator string to the
default</p>

<p style="margin-top: 1em">-C, --column[:&lt;scope&gt;]
&lt;r1&gt;-&lt;r2&gt;[:&lt;name&gt;] <br>
create an input field from an input column range</p>

<p style="margin-top: 1em">-W, --regex[:&lt;scope&gt;]
[E|B][i][l][r][U][n][b][e]/&lt;pattern&gt;/[&lt;name&gt;[,..]]
<br>
create input fields from a regular expression</p>

<p style="margin-top: 1em">-e, --expelempty <br>
expel empty input records and fields</p>

<p style="margin-top: 1em">-E, --expel
&lt;input_records&gt;[:&lt;input_fields&gt;] <br>
expel selected records or fields from being processed</p>

<p style="margin-top: 1em">-q, --quotedfields[2] <br>
treat fields that are between quotes as one field</p>

<p style="margin-top: 1em">-Q, --quotechars[2]
&lt;string&gt; <br>
specify an array of quoting characters to use</p>

<p style="margin-top: 1em">-b, --blanklines <br>
do not ignore blank input records</p>

<p style="margin-top: 1em">-t, --trim <br>
trim leading and trailing white space from input fields</p>

<p style="margin-top: 1em">Output options:</p>

<p style="margin-top: 1em">-S, --schema &lt;file&gt; <br>
-Sd, --schemadtd &lt;file&gt; <br>
-Sr, --schemarnc &lt;file&gt; <br>
-Sx, --schemaxsd &lt;file&gt; <br>
use a schema &lt;file&gt; for tag names and element
control</p>

<p style="margin-top: 1em">-M, --matchdirect
0|&lt;elementname&gt; <br>
match directly on a specific element in the schema</p>

<p style="margin-top: 1em">-A,
--attribute[&lt;level&gt;[:&lt;scope&gt;]] number|level <br>
|delimiter|timestamp|insert &lt;name&gt; &lt;value&gt; <br>
include attributes in the opening element tag</p>

<p style="margin-top: 1em">-T,
--tag[&lt;level&gt;[:&lt;scope&gt;]] number|level <br>
|name &lt;name&gt; <br>
|[re]insert &lt;name&gt; &lt;value&gt; <br>
|[re]insertfile &lt;name&gt; &lt;file&gt; <br>
|[re]insertfilexml &lt;indent&gt; &lt;file&gt; <br>
modify or insert element tags</p>

<p style="margin-top: 1em">-k,
--keyvaluepairs[&lt;level&gt;] <br>
generate key/value XML tag pairs</p>

<p style="margin-top: 1em">-l, --linenumbers <br>
this is a synonym for &quot;-T1 number&quot; <br>
include the line number in the line tag name</p>

<p style="margin-top: 1em">-f, --fieldnumbers <br>
this is a synonym for &quot;-T2 number&quot; <br>
include the field number in the field tag name</p>

<p style="margin-top: 1em">-L, --linetags <br>
include a line number tag with the record data</p>

<p style="margin-top: 1em">-X, --xmlformat
[XML1.0|XML1.1]|[SOAP1.1|SOAP1.2]|[HTML table|list] <br>

|[UTF-8|UTF-16|UTF-16BE|UTF-16LE|UTF-32|UTF-32BE|UTF-32LE]|BOM
<br>
|ASCIItoUTF|[noescape all|amp|lt|gt|quot|apos|brvbar] <br>
|trimtagclose|[newline dos|unix] <br>
specify an XML output format</p>

<p style="margin-top: 1em">-p, --printonly
header|footer|rtagopen|rtagclose|records <br>
print only snippets of the XML output</p>

<p style="margin-top: 1em">-I, --identifier
&lt;system_identifier&gt; <br>
specify an alternate system identifier of the doctype or
SOAP URI</p>

<p style="margin-top: 1em">-s, --summary[2|c|n|f
&lt;file&gt;] <br>
print a summary after the end of the processing</p>

<p style="margin-top: 1em">-U, --unxml <br>
undo the XML syntax leaving just plain text</p>

<p style="margin-top: 1em">--noxml <br>
do not XML-fy the input stream</p>

<p style="margin-top: 1em">DESCRIPTION <br>
The xmlfy command reads stdin and outputs it to stdout in
XML format using supplied control directives.</p>

<p style="margin-top: 1em">Delimiter tokens and/or column
selections are used to break down the input stream into XML
elements which are then represented inside an XML tree
hierarchy that can span multiple <br>
depth levels. For example, command line output was
originally designed for text or CRT based processing. The
xmlfy command takes this text based output where a new-line
often <br>
represents an end-of-record of data and white space often
represents a field separator, and reformats it into XML
output suitable for interfacing with modern object oriented
sys&acirc; <br>
tems.</p>

<p style="margin-top: 1em">xmlfy is a powerful yet
lightweight tool that primarily caters for converting ASCII,
UTF-8, UTF-16 or UTF-32 based output into XML format on the
fly and dealing with common <br>
issues associated with this kind of transformation.</p>

<p style="margin-top: 1em">The xmlfy command also supports
a basic version of a schema configuration allowing you to
control the format of the XML output by supplying a schema
file as an option.</p>

<p style="margin-top: 1em">With no options supplied xmlfy
will use default values for its XML format. The entire
standard input will be enclosed in
&lt;xmlfy&gt;&lt;/xmlfy&gt; pairs, each line of standard
input will <br>
be enclosed in &lt;line&gt;&lt;/line&gt; pairs, and each
field of each line will be enclosed in
&lt;field&gt;&lt;/field&gt; pairs.</p>

<p style="margin-top: 1em">OPTIONS <br>
You can supply options to customise the behaviour of xmlfy
at the command line, or by a special token inside the schema
file, or both. NOTE: Options are resolved from left to <br>
right. If any conflicting options are specified then the
last one will have precedence.</p>

<p style="margin-top: 1em">Option: -h, --help <br>
The command line usage is printed in plain text format not
in XML format.</p>

<p style="margin-top: 1em">Option: -v, --version <br>
The version number is printed in plain text format not in
XML format. If the version number is required in XML format
it is included with the summary option.</p>

<p style="margin-top: 1em">Option: --license <br>
Print all licenses used by xmlfy.</p>

<p style="margin-top: 1em">Option: --debug <br>
Print extra debugging information to stderr to help debug
xmlfy behaviour.</p>

<p style="margin-top: 1em">Input options:</p>

<p style="margin-top: 1em">Option: -F,
--fieldseparator[&lt;level&gt;[b][:&lt;scope&gt;]]
&lt;string&gt; <br>
Allows you to specify a delimiter string token for the level
specified. <br>
&lt;level&gt; - The XML depth level to be delimited by
&lt;string&gt;. <br>
Must be an integer value greater than or equal to 1. <br>
E.g. a value of 1 will split the input into records
delimited by &lt;string&gt;, a value of 2 will split records
into fields delimited by &lt;string&gt;, a value of 3 will
split <br>
fields into subfields delimited by &lt;string&gt;, and so
on. <br>
There is no space separating the option and the level value.
<br>
If no level is specified then the given options will only
apply to level 2. <br>
b - Use byte matching for the specified delimiter string.
<br>
By specifying this option the delimiter string is treated as
just a literal sequence of bytes. Normally command line
arguments are presented to xmlfy as ASCII strings and if
<br>
wide UTF encoding like UTF-16 or UTF-32 is being used then
xmlfy will automatically convert the specified delimiter
string to that encoding. With this option no encoding
con&acirc; <br>
version takes place. In this mode you can also specify
escaped decimal byte sequences inside the delimiter string.
E.g. &quot;123234\&quot; <br>
&lt;scope&gt; - A comma delimited set of sequence ranges
with no spaces. <br>
The &lt;scope&gt; parameter has a sub form of
&lt;s1&gt;[-&lt;s2&gt;][r][,..] <br>
&lt;s1&gt; - integer representing a start range. <br>
&lt;s2&gt; - integer or the $ token representing an end
range. <br>
r - restart the scope counter for this delimiter after the
completion of the associated range. <br>
Restrict the delimiter effectiveness to the occurrences
specified in &lt;scope&gt;. If a delimiter &lt;string&gt; is
encountered for the level specified and its sequence is not
in <br>
the scope then it will not function as a field separator and
will instead be treated as data. <br>
E.g. -F3:1-3,8 &quot;.&quot; this is saying that level 3
fields will only be created for the 1st to 3rd, and 8th
occurrences of the delimiter &quot;.&quot; (period). <br>
The restart scope counter option r allows you to specify
repeating scope sequences. <br>
E.g -F1:2,5r &quot;0 this is saying create level 1 records
out of every second and fifth lines and keep repeating this
until the input is exhausted. <br>
When using multiple same level delimiters, restarting scope
counters of the equivalent level and higher get reset
whenever a delimiter match is applied. <br>
If a &lt;scope&gt; range is not specified then the delimiter
function applies to every occurrence of &lt;string&gt; of
the target level. <br>
&lt;string&gt; - A sequence of characters or token to be
used&quot;, and &quot;&quot; are as a delimiter. Tokens
specified literally as &quot;0, &quot; translated to their
corresponding control charac&acirc; <br>
ter. If using wide UTF encoding then &lt;string&gt; is
automatically converted to that encoding, otherwise you can
use the byte matching option and specify escaped decimal
<br>
byte sequences inside &lt;string&gt;. <br>
o If the delimiter token is the same for a series of levels
then obviously the shallowest level will take precedence,
unless the shallowest levels have been limited by scope <br>
restrictions. You can also make use of quotes in the input
along with specifying quote options. <br>
o The XML tree algorithm deepens in a sequential way
therefore you must set your delimiter levels as an unbroken
sequence for them to be of any use, that is you cannot split
a <br>
level 2 field with a level 4 delimiter string. <br>
o Refer to the schema option section for information on
level handling when a schema file is specified. <br>
o Levels 1 and 2 are already set by default. <br>
o The default level 1 delimiter token is NEWLINE (new-line).
<br>
o The default level 2 delimiter token is WHITESPACE (space,
tab, new-line, carriage-return, vertical-tab and form-feed).
<br>
o The delimiters for levels 3 and above are unset. <br>
o Only one delimiter string token can be specified however
this option can be invoked multiple times allowing for
multiple delimiters to be used at the level specified. When
<br>
specifying multiple same level delimiters, the larger
delimiter strings are matched before the smaller ones. The
delimiter string is not included in the output.</p>

<p style="margin-top: 1em">Option: -R, --recordseparator
&lt;string&gt; <br>
This is a synonym for &quot;-F1 &lt;string&gt;&quot; <br>
Allows you to specify a record separator string token that
is different from the default. The default record separator
token is NEWLINE (new-line).</p>

<p style="margin-top: 1em">Option: -C,
--column[:&lt;scope&gt;]
&lt;c1&gt;-&lt;c2&gt;[:&lt;name&gt;] <br>
Use an input column range of the input record to generate an
input field. This is an alternative method of capturing
input fields from using delimiters. <br>
&lt;scope&gt; - A comma delimited set of sequence ranges
with no spaces. <br>
The &lt;scope&gt; parameter has a sub form of
&lt;s1&gt;[-&lt;s2&gt;][r][,..] <br>
&lt;s1&gt; - integer representing a start range. <br>
&lt;s2&gt; - integer or the $ token representing an end
range. <br>
r - restart the scope counter for this column option after
the completion of the associated range. <br>
Restrict the column option effectiveness to the occurrences
specified in &lt;scope&gt;. If the input record sequence is
not in the scope then the column option will not be <br>
applied and input fields will not be generated. <br>
The restart scope counter option r allows the scope
sequences to continually repeat themselves. E.g -C:1-3,5r
1-20 this is saying capture column fields of 20 characters
<br>
in length for every first to third and fifth input records,
and keep repeating this until the input is exhausted. <br>
If a &lt;scope&gt; range is not specified then the column
option applies to all input records. <br>
&lt;c1&gt; - Integer or the $ token representing the start
column range of the input field. <br>
&lt;c2&gt; - Integer or the $ token representing the end
column range of the input field. <br>
&lt;name&gt; - Optional string value that will be used to
override the tag name for this input field. <br>
You can pretty much specify anything as a tag name including
illegal XML therefore user discretion is advised. <br>
Only applicable for changing default behaviour (i.e. when
the --schema option is NOT specified). <br>
o Specifying field separators of level 2 and above with this
option is conflicting and will produce a usage error. <br>
o The number of times and order in which this option is
specified (in conjunction with the -W option) determines the
number of input fields generated and their order. <br>
o Column ranges represent code points (characters) meaning
any multi byte character will only account for just one
column position. <br>
o Multiple options can use non linear ranges and can overlap
e.g. -C 5-10:part -C 1-$:whole <br>
o Ranges that exceed the size of the input record will not
process beyond the end of the input record. <br>
o You can use single or double quotes to protect the range
from the shell interpreter e.g. -C &rsquo;80-$:text&rsquo;
<br>
o Only one parameter pair can be specified however this
option can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -W,
--regex[:&lt;scope&gt;]
[E|B][i][l][r][U][n][b][e]/&lt;pattern&gt;/[&lt;name&gt;[,..]]
<br>
Use a regular expression on the input record to generate
input fields. This is an alternative method of capturing
input fields from using delimiters. <br>
&lt;scope&gt; - A comma delimited set of sequence ranges
with no spaces. <br>
The &lt;scope&gt; parameter has a sub form of
&lt;s1&gt;[-&lt;s2&gt;][r][,..] <br>
&lt;s1&gt; - integer representing a start range. <br>
&lt;s2&gt; - integer or the $ token representing an end
range. <br>
r - restart the scope counter for this regex option after
the completion of the associated range. <br>
Restrict the regex option effectiveness to the occurrences
specified in &lt;scope&gt;. If the input record sequence is
not in the scope then the regex option will not be <br>
applied and input fields will not be generated. <br>
The restart scope counter option r allows the scope
sequences to continually repeat themselves. E.g -W:1-3,5r
/(^A.*).*(B.*$)/ this is saying capture two regex fields
<br>
for every first to third and fifth input records, and keep
repeating this until the input is exhausted. <br>
If a &lt;scope&gt; range is not specified then the regex
option applies to all input records. <br>
E - flag to use Extended Regular Expressions in
&lt;pattern&gt; (default). <br>
B - flag to use Basic Regular Expressions in
&lt;pattern&gt;. <br>
i - flag to ignore case. <br>
l - flag to treat &lt;pattern&gt; as a literal. <br>
r - flag to make concatenation right associative. <br>
U - flag to make operators ungreedy by default. <br>
n - flag to give &rsquo;0 special meaning (REG_NEWLINE).
<br>
b - flag to set &rsquo;^&rsquo; as not beginning-of-line
(REG_NOTBOL). <br>
e - flag to set &rsquo;$&rsquo; as not end-of-line
(REG_NOTEOL). <br>
&lt;pattern&gt; - A POSIX 1003.2 compliant Regular
Expression pattern utilising zero or more parenthesis pairs
to capture input fields. <br>
&lt;name&gt; - Optional string value that will be used to
override the tag name for input fields derived from pattern
matches. <br>
A comma separated list of &lt;name&gt; can be specified with
the last entry being re-used if more input fields than names
are generated. <br>
You can pretty much specify anything as a tag name including
illegal XML therefore user discretion is advised. <br>
Only applicable for changing default behaviour (i.e. when
the --schema option is NOT specified). <br>
o Specifying field separators of level 2 and above with this
option is conflicting and will produce a usage error. <br>
o The number of times and order in which this option is
specified (in conjunction with the -C option) determines the
number of input fields generated and their order. <br>
o If matches are not made for all parenthesis pairs
specified in &lt;pattern&gt; then no output will result.
<br>
o If no parenthesis pairs are specified in &lt;pattern&gt;
then the entire input record will be used as the output when
a pattern match occurs. <br>
o Wide UTF encoding can be specified in &lt;pattern&gt; by
using the literal followed by two hexadecimal digits to
represent any byte inside the code-point e.g. b. <br>
o For further information on using regex syntax and its
flags please consult the TRE web documentation. <br>
o You can use single or double quotes to protect
&lt;pattern&gt; from the shell interpreter e.g. -W
&rsquo;iU/(^Pam .*)/pams&rsquo; <br>
o You can specify the percentage character % as an
alternative separator to forward-slash / for &lt;pattern&gt;
so long as it remains paired. <br>
o Only one parameter pair can be specified however this
option can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -e, --expelempty <br>
Expel input fields that are empty (zero bytes in length)
from being processed. The use of multi level and multiple
same level delimiters can sometimes yield plenty of empty
<br>
fields which may be undesirable. This option expels all the
empty input fields from being processed by the output
processor. All levels are examined and any input records
com&acirc; <br>
prised entirely out of empty fields are also expelled. <br>
This option will always run before any expelling tasks
specified with option -E are run. <br>
This option has no influence on levels subjected to
key/value pairing as that process has its own way of dealing
with empty fields at its target levels. <br>
If a schema is used then obviously the number of input
records/fields used for element matching has been
reduced.</p>

<p style="margin-top: 1em">Option: -E, --expel
&lt;input_records&gt;[:&lt;input_fields&gt;] <br>
Expel selected input records or selected input fields of
selected input records from being processed. Each input
record is checked against the expel criteria and if a match
<br>
occurs then these input records or input fields are simply
discarded from being passed onto the xmlfy output processor.
<br>
&lt;input_records&gt; - A comma delimited set of input
record expel criteria with no spaces. <br>
The &lt;input_records&gt; parameter has a sub form of
&lt;range_type&gt;&lt;r1&gt;[-&lt;r2&gt;][/&lt;string&gt;/][,..]
<br>
Where &lt;range_type&gt; can be &rsquo;n&rsquo;,
&rsquo;f&rsquo; or &rsquo;c&rsquo;. <br>
n - the associated range refers to input record numbers.
<br>
f - the associated range refers to input field numbers. <br>
c - the associated range refers to input record character
lengths. <br>
&lt;r1&gt; - integer representing a start range. <br>
&lt;r2&gt; - integer or the $ token representing an end
range. <br>
&lt;string&gt; - the specified &lt;string&gt; must also
exist within the range. <br>
Expel criteria types can be intermixed. <br>
E.g. -E n10-$,f7-8,f4/Mercedes/,c10-20,c1-15/SUV/ <br>
this is saying that input records whose record number is
greater than or equal to 10, AND input records whose total
number of fields are between 7 <br>
and 8, AND input records whose 4th input field contains the
string &quot;Mercedes&quot;, AND input records whose input
record length is greater than or equal <br>
to 10 but less than or equal to 20 characters, AND input
records whose first 15 characters contain the string
&quot;SUV&quot;, will finally match the input <br>
record expel criteria. <br>
In this release you can only specify the $ token (last input
record) in a paired range and not on its own. <br>
Generally xmlfy can figure out where the search string
delimiters would likely occur however you can specify the %
character as an alternative sepa&acirc; <br>
rator to / for &lt;string&gt; so long as it remains paired.
<br>
If an &lt;input_fields&gt; criteria is not specified then
the entire input record is expelled. <br>
&lt;input_fields&gt; - A comma delimited set of field number
ranges with no spaces. <br>
The &lt;input_fields&gt; parameter has a sub form of
&lt;r1&gt;[-&lt;r2&gt;][,..] <br>
&lt;r1&gt; - integer or the $ token representing a start
range. <br>
&lt;r2&gt; - integer or the $ token representing an end
range. <br>
Discard select input fields of the input records that match
the expel criteria before passing onto the xmlfy output
processor. <br>
E.g. -E n2-$:1,$ this is saying that input records whose
record number is greater than or equal to 2 will have their
first and last fields expelled. <br>
You can specify the $ token (last input field) in a paired
range or on its own. <br>
o You can use single or double quotes to protect the range
from the shell interpreter e.g. -E &rsquo;n2-$:$&rsquo; <br>
o If a schema is used then obviously the number of input
records/fields used for element matching has been reduced.
<br>
o Only one parameter group can be specified however this
option can be invoked multiple times with resolution
occurring from left to right.</p>

<p style="margin-top: 1em">Option: -q, --quotedfields[2]
<br>
Treat fields that are quoted as one field. Normally xmlfy
will parse fields by their delimiter e.g. WHITESPACE, this
option allows multi delimited fields to be specified as one
<br>
by quoting them. By default the quoted field may only span
the current input record unless the -q2 option is specified
in which case the quoted field can span multiple input <br>
records. <br>
Quotes are not included in the field and any
leading/trailing text outside the field&rsquo;s quotes are
truncated. <br>
If quotes are not closed xmlfy will update the field until
the end of the input record, or if option -q2 is specified,
until the input is exhausted (EOF). <br>
The default quote character is a double quote (&quot;).</p>

<p style="margin-top: 1em">Option: -Q, --quotechars[2]
&lt;string&gt; <br>
specify a string of characters that can be used as the
quoting character. <br>
&lt;string&gt; - an array of quoting characters. <br>
o If field quoting is enabled then any input character that
matches any character in &lt;string&gt; will toggle the
quoting function, unless the -Q2 option is specified in
which case <br>
characters in &lt;string&gt; represent paired quotes with
odd numbered characters in this array toggling the open
quote function, and its corresponding pair toggling the
close quote <br>
function. This allows parenthesis, brackets, etc to be used
as quotes. <br>
o Obviously when specifying this option care must be taken
to prevent the shell from interpreting the supplied quote
characters. When using a schema file containing this option
<br>
you can specify quote characters by escaping them with the
backslash &quot;</p>

<p style="margin-top: 1em">Option: -b, --blanklines <br>
Normally xmlfy ignores blank lines or empty level 1 records
in the input stream. This option tells xmlfy to not ignore
these blank lines and print out XML line record tags but
<br>
with no elements. <br>
In this mode blank lines count as line numbers.</p>

<p style="margin-top: 1em">Option: -t, --trim <br>
Field elements are trimmed of leading and trailing white
space.</p>

<p style="margin-top: 1em">Output options:</p>

<p style="margin-top: 1em">Option: -S, --schema
&lt;file&gt; <br>
-Sd, --schemadtd &lt;file&gt; <br>
-Sr, --schemarnc &lt;file&gt; <br>
-Sx, --schemaxsd &lt;file&gt; <br>
Specify a schema &lt;file&gt; for controlling the XML
output. <br>
&lt;file&gt; - The schema file must comply with either the
Document Type Definition (.dtd) language, or the RELAX NG
Compact (.rnc) language, or the XML Schema Document (.xsd)
lan&acirc; <br>
guage, however xmlfy does not support the finer aspects of
these schema languages at this early stage. <br>
o When all input fields of the input record have been
identified, xmlfy will match them against the elements
inside the tree hierarchy of the schema file, and if a match
is found <br>
then xmlfy will print an output record using the matching
schema tree hierarchy as its XML structure. <br>
Option -S, --schema uses the case-insensitive file name
extension (.dtd or .rnc or .xsd) of &lt;file&gt; to
determine which schema interpreter xmlfy will apply. <br>
Option -Sd, --schemadtd forces xmlfy to use the DTD schema
interpreter on &lt;file&gt;. <br>
Option -Sr, --schemarnc forces xmlfy to use the RNC schema
interpreter on &lt;file&gt;. <br>
Option -Sx, --schemaxsd forces xmlfy to use the XSD schema
interpreter on &lt;file&gt;. <br>
o You can specify multi level delimiters when using this
option however any delimiters greater than level 2 are only
used to identify more input fields and are not used at all
in <br>
altering the XML tree hierarchy as is dictated by the schema
file. Fields with levels of 2 and above are flattened to be
just plain fields of the input record - this is very <br>
different to the default behaviour where field levels form
the XML tree hierarchy. <br>
o If a schema option is not supplied then xmlfy will use
default values for tag names and element control. <br>
o For further information on how to write a schema for xmlfy
please consult the web documentation.</p>

<p style="margin-top: 1em">Option: -M, --matchdirect
0|&lt;elementname&gt; <br>
Match directly on a specific element in the schema making it
the root element. <br>
0 - A token representing the default root element in the
schema. <br>
&lt;elementname&gt; - The name of a record element in the
schema. <br>
o This option alters the way the selected schema element is
matched against the available input fields that were
generated. In this mode the target element is matched in its
<br>
entirety using its element helper and printed accordingly.
This is very different to the default legacy mode whereby
only the record elements of the root element get matched
<br>
in a continuously sequential way. <br>
o Regardless of what wildcard attributes exist for the
target element it will only be printed once as a root
element. <br>
o If a schema file is not specified then this option will be
ignored.</p>

<p style="margin-top: 1em">Option: -A,
--attribute[&lt;level&gt;[:&lt;scope&gt;]] number|level <br>
|delimiter|timestamp|insert &lt;name&gt; &lt;value&gt; <br>
Include attributes in the opening element tag for the level
specified. <br>
&lt;level&gt; - The XML depth level to be modified. <br>
Must be an integer value greater than or equal to 0. <br>
E.g. a value of 1 will apply attributes to each opening
record element and a value of 2 will apply attributes to
each opening field element. <br>
There is no space separating the option and the level value.
<br>
If no level is specified then the given options will apply
to all levels except level 0. <br>
&lt;scope&gt; - A comma delimited set of sequence ranges
with no spaces. <br>
The &lt;scope&gt; parameter has a sub form of
&lt;s1&gt;[-&lt;s2&gt;][r][,..] <br>
&lt;s1&gt; - integer representing a start range. <br>
&lt;s2&gt; - integer or the $ token representing an end
range. <br>
r - restart the scope counter for this attribute after the
completion of the associated range. <br>
Restrict the custom attribute effectiveness to the
occurrences specified in &lt;scope&gt;. If the element
sequence is not in the scope then the custom attribute will
not be <br>
applied. <br>
The restart scope counter option r allows the scope
sequences to continually repeat themselves. E.g -A2:1-3,5r
insert x y this is saying insert custom attributes
x=&quot;y&quot; <br>
for every first to third and fifth level 2 elements, and
keep repeating this until the output is exhausted. <br>
Scope sequence counters are always reset to zero for the
next element depth level and higher whenever a deeper XML
depth level is entered into. <br>
If a &lt;scope&gt; range is not specified then the custom
attribute function applies to all elements at the specified
&lt;level&gt;. <br>
number - Specify the sequence number as an element
attribute. <br>
E.g. &lt;field&gt; becomes &lt;field
number=&quot;1&quot;&gt; and the next &lt;field&gt; becomes
&lt;field number=&quot;2&quot;&gt; and so on. <br>
Scoping is not supported. <br>
Not supported for level 0. <br>
level - Specify the level as an element attribute. <br>
E.g. &lt;field&gt; becomes &lt;field level=&quot;2&quot;&gt;
<br>
Scoping is not supported. <br>
Not supported for level 0. <br>
delimiter - Specify the matching delimiter as an element
attribute. <br>
E.g. &lt;field&gt; becomes &lt;field
delimiter=&quot;ABC&quot;&gt; <br>
Delimiter string tokens that contain illegal XML characters
are printed as their hex pair equivalent. <br>
When using a schema file only level 1 records and field
elements will have their delimiter attributes printed. <br>
Scoping is not supported. <br>
Not supported for level 0. <br>
timestamp - Include a timestamp as an element attribute.
<br>
Two timestamps are provided, one for humans and one for
machines. The times are stamped at element print time. <br>
E.g. &lt;field&gt; becomes &lt;field
timestamp_date=&quot;Fri May 5 10:23:33 2008&quot;
timestamp_sec=&quot;123456790&quot;&gt; <br>
Scoping is not supported. <br>
insert &lt;name&gt; &lt;value&gt; - Insert a custom element
attribute. <br>
The parameters &lt;name&gt; and &lt;value&gt; are combined
to form an element attribute with &lt;value&gt; wrapped
around double quotes. <br>
E.g &lt;field&gt; becomes &lt;field
name=&quot;value&quot;&gt; <br>
You can pretty much specify anything as an attribute name
and value including illegal XML therefore user discretion is
advised. <br>
o Only one parameter group can be specified however this
option can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -T,
--tag[&lt;level&gt;[:&lt;scope&gt;]] number|level <br>
|name &lt;name&gt; <br>
|[re]insert &lt;name&gt; &lt;value&gt; <br>
|[re]insertfile &lt;name&gt; &lt;file&gt; <br>
|[re]insertfilexml &lt;indent&gt; &lt;file&gt; <br>
Modify or insert element tags for the level specified. <br>
&lt;level&gt; - The XML depth level to be modified. <br>
Must be an integer value greater than or equal to 0. <br>
E.g. a value of 1 will modify the tag name for each record
and a value of 2 will modify the tag name for each field.
<br>
There is no space separating the option and the level value.
<br>
If no level is specified then the given options will apply
to all levels except level 0. <br>
&lt;scope&gt; - A comma delimited set of sequence ranges
with no spaces. <br>
The &lt;scope&gt; parameter has a sub form of
&lt;s1&gt;[-&lt;s2&gt;][r][,..] <br>
&lt;s1&gt; - integer representing a start range. <br>
&lt;s2&gt; - integer or the $ token representing an end
range. <br>
r - restart the scope counter for this tag after the
completion of the associated range. <br>
Restrict the custom tag effectiveness to the occurrences
specified in &lt;scope&gt;. If the element sequence is not
in the scope then the custom tag will not be applied. <br>
The restart scope counter option r allows the scope
sequences to continually repeat themselves. E.g -T2:1-3,5r
insert x y this is saying insert the custom tag
&lt;x&gt;y&lt;/x&gt; <br>
before every first to third and fifth level 2 elements, and
keep repeating this until the output is exhausted. <br>
Scope sequence counters are always reset to zero for the
next element depth level and higher whenever a deeper XML
depth level is entered into. <br>
If a &lt;scope&gt; range is not specified then the custom
tag function applies to all elements at the specified
&lt;level&gt;. <br>
number - Suffix the tag name with its sequence number. <br>
E.g. &lt;line&gt; becomes &lt;line1&gt; and the next
&lt;line&gt; becomes &lt;line2&gt; and so on. <br>
Scoping is not supported. <br>
Not supported for level 0. <br>
level - Prefix the tag name with its level. <br>
E.g. &lt;field&gt; becomes &lt;L2field&gt; <br>
Scoping is not supported. <br>
Not supported for level 0. <br>
name &lt;name&gt; - Change the tag name from the default to
&lt;name&gt; <br>
Only applicable for changing default behaviour (i.e. when
the --schema option is NOT specified). <br>
E.g. &lt;field&gt; becomes &lt;word&gt; <br>
You can pretty much specify anything as a tag name including
illegal XML therefore user discretion is advised. <br>
Scoping is not supported. <br>
[re]insert &lt;name&gt; &lt;value&gt; - Insert a custom
element tag. <br>
The parameters &lt;name&gt; and &lt;value&gt; are combined
to form an element tag with &lt;value&gt; wrapped between
&lt;name&gt; tag pairs. E.g &lt;name&gt;value&lt;/name&gt;
<br>
The inserted element appears before any output elements for
the level specified. <br>
The reinsert feature keeps applying itself at the level
specified. <br>
You can pretty much specify anything as an element name and
value including illegal XML therefore user discretion is
advised. <br>
Not supported for level 0. <br>
[re]insertfile &lt;name&gt; &lt;file&gt; - Insert a custom
element tag containing contents of a file. <br>
The contents of &lt;file&gt; are wrapped between
&lt;name&gt; tag pairs. <br>
The encoding of &lt;file&gt; must match the output encoding
being used otherwise an undesirable output will result. <br>
Any BOM found in &lt;file&gt; is removed. <br>
Any reserved XML characters in &lt;file&gt; are escaped, and
newlines are corrected. <br>
The inserted element appears before any output elements for
the level specified. <br>
The reinsert feature keeps applying itself at the level
specified. <br>
You can pretty much specify anything as an element name
including illegal XML therefore user discretion is advised.
<br>
Not supported for level 0. <br>
[re]insertfilexml &lt;indent&gt; &lt;file&gt; - Insert
contents of an XML file. <br>
The entire contents of &lt;file&gt; are inserted before any
output elements for the level specified. <br>
The encoding of &lt;file&gt; must match the output encoding
being used otherwise an undesirable output will result. <br>
Any BOM found in &lt;file&gt; is removed. <br>
If the parameter &lt;indent&gt; is an integer value greater
than or equal to zero then the contents of file are indented
by this amount, any XML <br>
prologue is removed, and newlines are corrected. <br>
If the parameter &lt;indent&gt; is the value &quot;raw&quot;
then the XML file is inserted as is without its BOM. <br>
The reinsert feature keeps applying itself at the level
specified. <br>
You can pretty much insert anything as XML file content
including illegal XML therefore user discretion is advised.
<br>
o Only one parameter group can be specified however this
option can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -k,
--keyvaluepairs[&lt;level&gt;] <br>
Switch on the generation of key/value XML tag pairs for the
output. <br>
&lt;level&gt; - The XML depth level to be modified. <br>
Must be an integer value greater than or equal to 2. <br>
There is no space separating the option and the level value.
<br>
If no level is specified then the option will apply to all
levels except levels 0 and 1. <br>
o In this mode the data of the first field of the current
XML level becomes the tag name for that level, that is, it
becomes the key, and any subsequent fields become its value.
<br>
o This key/value pairing continues down the XML tree
hierarchy for all the XML levels specified. <br>
o You can pretty much generate anything as a tag name
including illegal XML therefore user discretion is advised.
The new tag name is trimmed of leading and trailing white
space <br>
and white space between text is replaced with the underscore
&quot;_&quot; character. <br>
o If a blank field becomes a tag name candidate then xmlfy
will skip it and search along the same level for a more
suitable candidate. This behaviour can be mitigated by using
<br>
the -b option which will force the default tag name to be
substituted instead. <br>
o Only applicable for changing default behaviour (i.e. when
the --schema option is NOT specified). <br>
o This option can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -l, --linenumbers <br>
This is a synonym for &quot;-T1 number&quot; <br>
Include the line number in the line tag name</p>

<p style="margin-top: 1em">Option: -f, --fieldnumbers <br>
This is a synonym for &quot;-T2 number&quot; <br>
include the field number in the field tag name</p>

<p style="margin-top: 1em">Option: -L, --linetags <br>
Insert a line number tag within the XML formatted output.
<br>
This is an alternative way of numbering your XML records.
E.g. for the first line record of XML output the following
tag is inserted &lt;linenumber&gt;1&lt;/linenumber&gt; and
so on.</p>

<p style="margin-top: 1em">Option: -X, --xmlformat
[XML1.0|XML1.1]|[SOAP1.1|SOAP1.2]|[HTML table|list] <br>

|[UTF-8|UTF-16|UTF-16BE|UTF-16LE|UTF-32|UTF-32BE|UTF-32LE]|BOM
<br>
|ASCIItoUTF|[noescape all|amp|lt|gt|quot|apos|brvbar] <br>
|trimtagclose|[newline dos|unix] <br>
Allows you to specify the XML format to be used for the
output. <br>
XML1.0 - Generate XML 1.0 output (this is the default). <br>
XML1.1 - Generate XML 1.1 output. <br>
SOAP1.1 - Generate XML SOAP 1.1 output. <br>
SOAP1.2 - Generate XML SOAP 1.2 output. <br>
HTML - Generate HTML output. <br>
table- elements are displayed in table format. <br>
list - elements are displayed in list format. <br>
UTF-8 - Generate UTF-8 output encoding (default). <br>
UTF-16 - Generate UTF-16 output encoding. <br>
UTF-16BE - Generate UTF-16BE (big-endian) output encoding.
<br>
UTF-16LE - Generate UTF-16LE (little-endian) output
encoding. <br>
UTF-32 - Generate UTF-32 output encoding. <br>
UTF-32BE - Generate UTF-32BE (big-endian) output encoding.
<br>
UTF-32LE - Generate UTF-32LE (little-endian) output
encoding. <br>
BOM - Generate and interpret a Byte-Order-Mark. <br>
ASCIItoUTF - Convert ASCII input to wide UTF encoding. <br>
noescape - Do not escape select reserved XML characters. By
default xmlfy will escape reserved XML characters that
appear in the input stream and this option provides an
adjust&acirc; <br>
ment to this behaviour. <br>
all - do not escape any characters. <br>
amp - do not escape the character &amp; (ampersand). <br>
lt - do not escape the character &lt; (less-than). <br>
gt - do not escape the character &gt; (greater-than). <br>
quot - do not escape the character &quot; (quote). <br>
apos - do not escape the character &rsquo; (apostrophe).
<br>
brvbar - do not escape the character | (broken vertical
bar). <br>
trimtagclose - Truncate superfluous characters from the
closing tag name. <br>
newline - Select the line ending format for XML meta-data.0)
for <br>
dos - use carriage-return and new-line (&quot; line endings.
<br>
unix - use new-line (&quot;0) for line endings. <br>
o The only thing option XML1.1 does is change the prologue
version string to &quot;1.1&quot; and nothing else. <br>
o When using the SOAP* options, the normal XML output
generated by xmlfy is encapsulated in a SOAP Envelope and
SOAP Body, the root tag defines a namespace prefix of
&quot;x&quot; with a <br>
URI reference that can be adjusted with the -I option, and
all children elements (records and fields) use this prefix
name. <br>
A non-mandatory administrative header element with a prefix
name of &quot;xh&quot; is provided containing program and
execution details. <br>
The SOAP* options are only a basic implementation for
generating a simple XML SOAP envelope containing xmlfy data.
There is no further scope provided for SOAP Headers, SOAP
<br>
Faults, transaction or protocol handling. <br>
o When using the HTML option, the normal XML output
generated by xmlfy is displayed in either a table or list
layout and encapsulated in a HTML Body, of which the
document title <br>
can be adjusted with the -I option. <br>
o The UTF-* options tell xmlfy to use the specified encoding
for all its XML meta-data (element tags, element attributes,
prologues, etc). Other than the ASCIItoUTF option, no <br>
transformation of the input stream is performed and xmlfy
assumes that the encoding used by the input stream matches
the encoding specified, otherwise an undesirable output <br>
will result containing different encodings between the input
data and XML meta-data. <br>
If specifying the UTF-16 or UTF-32 parameter and the BOM
option is either not specified or there is no BOM in the
input stream then encoding in big-endian format will be <br>
assumed. <br>
o The BOM (Byte-Order-Mark) option will force xmlfy to
handle the BOM in the input stream if it is there, and also
generate a BOM in the output stream. If specifying the BOM
<br>
option and a BOM is found in the input stream then that will
overide any user specified encoding option. <br>
The BOM byte sequence used for UTF-8 is 0xef 0xbb 0xbf
(U+FEFF). <br>
The BOM byte sequence used for UTF-16BE is 0xfe 0xff
(U+FEFF). <br>
The BOM byte sequence used for UTF-16LE is 0xff 0xfe
(U+FFFE). <br>
The BOM byte sequence used for UTF-32BE is 0x00 0x00 0xfe
0xff (U+FEFF). <br>
The BOM byte sequence used for UTF-32LE is 0xff 0xfe 0x00
0x00 (U+FFFE). <br>
o The ASCIItoUTF option when used in conjunction with one of
the UTF-* options will process ASCII input and convert it to
the wide UTF encoding specified. <br>
o The noescape options control which reserved XML characters
should not be escaped. <br>
o The trimtagclose option trims back the closing tag from
the first white space character found. Some options allow
the user to define anything as a tag name including tag
names <br>
that have element attributes (non normal approach). Using
this option under these circumstances will prevent these
element attributes from appearing in the close tag. <br>
o The newline option adjusts the line ending format used for
XML meta-data. On Unix platforms the default is unix and on
Win32 platforms the default is dos. Only applies to XML <br>
meta-data output and does not do conversion of newline
characters found in the input stream. <br>
o Only one parameter group can be specified however this
option can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -p, --printonly
header|footer|rtagopen|rtagclose|records <br>
Allows you to just print XML snippets to the output. <br>
This is useful when you want to execute xmlfy multiple times
to construct a single XML output file. <br>
header - Will only print the prologue, doctype, opened SOAP
Envelope and Body tags, the SOAP Header tag, HTML headers,
and the BOM. <br>
footer - Will only print closed SOAP Envelope and Body tags,
and closed HTML tags. <br>
rtagopen - Will only print an opened root element tag. <br>
rtagclose - Will only print a closed root element tag. <br>
records - Will only print record elements and their field
elements. <br>
o Only one parameter can be specified however this option
can be invoked multiple times.</p>

<p style="margin-top: 1em">Option: -I, --identifier
&lt;system_identifier&gt; <br>
Allows you to specify your own system identifier of the
doctype should you not be content with what xmlfy has
specified. <br>
system_identifier - An array of characters used to override
the default system identifier. <br>
You can pretty much specify anything as a system identifier
including illegal XML therefore user discretion is advised.
<br>
o By default xmlfy will use the string
&quot;xmlfy.dtd&quot;, or if specifying a schema, use the
schema filename as the system identifier. <br>
o You can also use this option to overide the default SOAP
namespace URI value for the root element when using the XML
SOAP format options. <br>
o You can also use this option to overide the document title
in the HTML header when using the XML HTML format
options.</p>

<p style="margin-top: 1em">Option: -s, --summary[2|c|n|f
&lt;file&gt;] <br>
When all input is exhausted an XML summary element is
printed at the bottom providing a brief summary of what
xmlfy processed. <br>
2 - Print the summary element to stderr instead. <br>
c - Print the summary element as an XML comment. <br>
n - Print the summary element without calculating any
message digests. <br>
f &lt;file&gt; - Print the summary element to &lt;file&gt;.
<br>
By default MD5 and SHA512 checksum elements are provided
inside the summary called md5_input, md5_output,
sha512_input and sha512_output. The md5_input and
sha512_input checksums <br>
are a digest of all the input that was actually processed
including any input BOM. The md5_output and sha512_output
checksums are a digest of all the output including any
output <br>
BOM that precedes the XML summary element. To correctly
validate the output result against the output checksum you
must first remove any summary element and summary comments
from <br>
the output result.</p>

<p style="margin-top: 1em">Option: -U, --unxml <br>
Read XML formatted input and remove all that bracket racket
reverting your XML document back to a plain format. Can be
used in conjunction with the -F&lt;level&gt; &lt;string&gt;
option to <br>
specify the delimiter to use for each XML depth level.
Multiple same level -F options are meaningless in this
context and delimiters are only inserted if more than one
field is <br>
available to be delimited. Field separator scoping options
are ignored. The default delimiter is a space character for
XML depth levels of 2 and above, and new-line for XML depth
<br>
levels below 2. Tag names and their attributes are not
included in the output, and anything between XML comments
are filtered out. If there is a BOM in the input then xmlfy
will <br>
use that for the encoding, otherwise xmlfy will look for the
opening XML character sequence of &quot;&lt;?&quot; to
determine the encoding being used. If neither of the
previous methods <br>
found the correct encoding then you can use the -X UTF-*
options as a fallback. Basic quoting options are also
supported. Works best with XML output generated by xmlfy but
can <br>
also be used with caution on other foreign XML
documents.</p>

<p style="margin-top: 1em">Option: --noxml <br>
Do not XML-fy the input stream but do process it for
reserved XML characters (this feature was initially written
for formatting the xmlfy HTML test reports that use wide
encod&acirc; <br>
ings). Used in conjunction with the -X options to control
the conversion of reserved characters and/or to transform
the input stream to wide UTF encodings. <br>
E.g. To transform an ASCII input stream to UTF-16BE encoding
with a BOM: <br>
xmlfy --noxml -X UTF-16BE -X ASCIItoUTF -X noescape all -X
BOM <br>
E.g. To just escape select reserved XML characters in an
UTF-32LE input stream: <br>
xmlfy --noxml -X UTF-32LE -X noescape amp</p>

<p style="margin-top: 1em">Important note on specifying
options. <br>
The way xmlfy handles options is very straightforward and
can be easily confused if you don&rsquo;t follow the syntax
specified for each option. The getopt library has been
deliber&acirc; <br>
ately avoided to keep xmlfy portable.</p>

<p style="margin-top: 1em">xmlfy first evaluates options
supplied on the command line, if a schema file is supplied
then xmlfy will also look for options in that file and
evaluate them too. See the schema <br>
file section below on how to specify xmlfy options inside a
schema file.</p>

<p style="margin-top: 1em">OUTPUT <br>
How it works. <br>
The input processor used by xmlfy block reads unprocessed
bytes from standard input (stdin) and stores them in an
array the size of a level 1 record. This level 1 record is
then <br>
processed for fields and sub fields etc by marking their
positions in this array. Dynamic memory handling is
used.</p>

<p style="margin-top: 1em">The output processor used by
xmlfy takes the results from the input processor and
re-packages it with suitably encoded XML syntax. Any input
characters that are reserved for XML <br>
are by default re-represented in their escaped form. <br>
Character &amp; (ampersand) becomes string &amp;amp; <br>
Character &lt; (less-than) becomes string &amp;lt; <br>
Character &gt; (greater-than) becomes string &amp;gt; <br>
Character &quot; (quote) becomes string &amp;quot; <br>
Character &rsquo; (apostrophe) becomes string &amp;apos;
<br>
Character | (broken vertical bar) becomes string
&amp;brvbar; <br>
The output processor then writes processed bytes to a block
buffer for printing to standard output (stdout).</p>

<p style="margin-top: 1em">Using a schema file. <br>
The default schema used by xmlfy is hard coded and can be
described as follows: <br>
In DTD schema form: <br>
&lt;!ELEMENT xmlfy (line*)&gt; <br>
&lt;!ELEMENT line (field*)&gt; <br>
&lt;!ELEMENT field (#PCDATA)&gt; <br>
In RNC schema form: <br>
start = xmlfy <br>
xmlfy = element xmlfy { line* } <br>
line = element line { field* } <br>
field = element field { text } <br>
In XSD schema form: <br>
&lt;xs:schema&gt; <br>
&lt;xs:element name=&quot;xmlfy&quot;&gt; <br>
&lt;xs:sequence&gt; <br>
&lt;xs:element name=&quot;line&quot;
type=&quot;lineType&quot; minOccurs=&quot;0&quot;
maxOccurs=&quot;unbounded&quot; /&gt; <br>
&lt;/xs:sequence&gt; <br>
&lt;/xs:element&gt; <br>
&lt;xs:complexType name=&quot;lineType&quot;&gt; <br>
&lt;xs:sequence&gt; <br>
&lt;xs:element name=&quot;field&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot;
maxOccurs=&quot;unbounded&quot; /&gt; <br>
&lt;/xs:sequence&gt; <br>
&lt;/xs:complexType&gt; <br>
&lt;/xs:schema&gt;</p>

<p style="margin-top: 1em">A schema file for the ls -la
command that produces output like this: <br>
total 73 <br>
drwx------+ 3 ag None 0 Apr 20 19:36 . <br>
-rwxr-xr-x 1 ag None 15639 Apr 20 19:31 a.exe <br>
-rwx------+ 1 ag None 6354 Apr 20 19:31 xmlfy.c <br>
-rwx------+ 1 ag None 4901 Apr 19 2008 xmlfy.h</p>

<p style="margin-top: 1em">In DTD schema form will look
like this: <br>
&lt;!ELEMENT ls (total?), (file*)&gt; <br>
&lt;!ELEMENT total (prompt, totalsize)&gt; <br>
&lt;!ELEMENT file (permission?, blocks?, user?, group?,
size?, date_M?, date_d?, date_ty?, fname)&gt; <br>
&lt;!ELEMENT date_ty (date_y)&gt; <br>
&lt;!ELEMENT date_ty (date_h, date_m)&gt; <br>
&lt;!ELEMENT prompt (#PCDATA)&gt; <br>
&lt;!ELEMENT totalsize (#PCDATA)&gt; <br>
&lt;!ELEMENT permission (#PCDATA)&gt; <br>
&lt;!ELEMENT blocks (#PCDATA)&gt; <br>
&lt;!ELEMENT user (#PCDATA)&gt; <br>
&lt;!ELEMENT group (#PCDATA)&gt; <br>
&lt;!ELEMENT size (#PCDATA)&gt; <br>
&lt;!ELEMENT date_y (#PCDATA)&gt; <br>
&lt;!ELEMENT date_M (#PCDATA)&gt; <br>
&lt;!ELEMENT date_d (#PCDATA)&gt; <br>
&lt;!ELEMENT date_h (#PCDATA)&gt; <br>
&lt;!ELEMENT date_m (#PCDATA)&gt; <br>
&lt;!ELEMENT fname (#PCDATA)&gt;</p>

<p style="margin-top: 1em">and should be saved to a file as
ls.dtd and invoked as: <br>
% ls -la | xmlfy --schema ls.dtd -F3 :</p>

<p style="margin-top: 1em">In RNC schema form will look
like this: <br>
start = ls <br>
ls = element ls { total? | file* } <br>
total = element total { prompt, totalsize } <br>
file = element file { permission?, blocks?, user?, group?,
size?, date_M?, date_d?, date_ty?, fname } <br>
date_ty = element date_ty { date_y } <br>
date_ty |= element date_ty { date_h, date_m } <br>
prompt = element prompt { text } <br>
totalsize = element totalsize { text } <br>
permission = element permission { text } <br>
blocks = element blocks { text } <br>
user = element user { text } <br>
group = element group { text } <br>
size = element size { text } <br>
date_y = element date_y { text } <br>
date_M = element date_M { text } <br>
date_d = element date_d { text } <br>
date_h = element date_h { text } <br>
date_m = element date_m { text } <br>
fname = element fname { text }</p>

<p style="margin-top: 1em">and should be saved to a file as
ls.rnc and invoked as: <br>
% ls -la | xmlfy --schema ls.rnc -F3 :</p>

<p style="margin-top: 1em">In XSD schema form will look
like this: <br>
&lt;xs:schema&gt; <br>
&lt;xs:element name=&quot;ls&quot; type=&quot;lsType&quot;
/&gt; <br>
&lt;xs:complexType name=&quot;lsType&quot;&gt; <br>
&lt;xs:sequence&gt; <br>
&lt;xs:element name=&quot;total&quot;
type=&quot;totalType&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;file&quot;
type=&quot;fileType&quot; minOccurs=&quot;0&quot;
maxOccurs=&quot;unbounded&quot; /&gt; <br>
&lt;/xs:sequence&gt; <br>
&lt;/xs:complexType&gt; <br>
&lt;xs:complexType name=&quot;totalType&quot;&gt; <br>
&lt;xs:sequence&gt; <br>
&lt;xs:element name=&quot;prompt&quot;
type=&quot;xs:string&quot; /&gt; <br>
&lt;xs:element name=&quot;totalsize&quot;
type=&quot;xs:string&quot; /&gt; <br>
&lt;/xs:sequence&gt; <br>
&lt;/xs:complexType&gt; <br>
&lt;xs:complexType name=&quot;fileType&quot;&gt; <br>
&lt;xs:sequence&gt; <br>
&lt;xs:element name=&quot;permission&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;blocks&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;user&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;group&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;size&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;date_M&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;date_d&quot;
type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;date_ty&quot;
type=&quot;datetyType&quot; minOccurs=&quot;0&quot; /&gt;
<br>
&lt;xs:element name=&quot;fname&quot;
type=&quot;xs:string&quot; /&gt; <br>
&lt;/xs:sequence&gt; <br>
&lt;/xs:complexType&gt; <br>
&lt;xs:complexType name=&quot;datetyType&quot;&gt; <br>
&lt;xs:choice&gt; <br>
&lt;xs:element name=&quot;date_y&quot;
type=&quot;xs:string&quot; /&gt; <br>
&lt;xs:sequence&gt; <br>
&lt;xs:element name=&quot;date_h&quot;
type=&quot;xs:string&quot; /&gt; <br>
&lt;xs:element name=&quot;date_m&quot;
type=&quot;xs:string&quot; /&gt; <br>
&lt;/xs:sequence&gt; <br>
&lt;/xs:choice&gt; <br>
&lt;/xs:complexType&gt; <br>
&lt;/xs:schema&gt;</p>

<p style="margin-top: 1em">and should be saved to a file as
ls.xsd and invoked as: <br>
% ls -la | xmlfy --schema ls.xsd -F3 :</p>

<p style="margin-top: 1em">Shoe-horning raw data into a
structure defined by a schema is rather straight forward
when the input fields have a one-to-one relationship with
the fields of the schema elements, <br>
however if wildcard tokens and/or Boolean logic are employed
in the schema then it becomes quite a challenge, sometimes
even impossible, to be deterministic about which input <br>
field belongs to which schema field. Strictly speaking, the
main function of the schema is to ensure XML is valid and to
do this requires the XML document to already pre-exist. <br>
In xmlfy&rsquo;s case we are doing the reverse by building
an XML document on the fly while following rules described
by the schema - this is still okay and the resulting XML can
be <br>
considered to be both valid and well formed.</p>

<p style="margin-top: 1em">xmlfy employs two techniques to
help with this shoe-horning input data problem. The first
technique xmlfy uses is recognising multiple element
definitions that have the same <br>
name. This allows you to capture your schema elements under
a variety of input circumstances without having to create a
unique element for each circumstance - you can still do <br>
that if you want. The second technique xmlfy uses is
auto-generated field match constraint helpers to assist in
matching the input fields to the elements described by the
schema. <br>
These helpers are useful in improving the speed of xmlfy
particularly when using compound element structures and
wildcard tokens in the schema hierarchy. After the schema
file is <br>
loaded into memory, an array of helpers is generated for
each element that describes all combinations of the schema
tree traversal paths that can be taken and associates each
<br>
combination with the minimum, maximum and last number of
fields required for a match against the number of available
input fields. For example, using the above schema a match
<br>
will occur for: <br>
total(min=2, max=2, last=2) when input fields = 2. <br>
file(min=1, max=9, last=1) when 1 &gt;= input fields &lt;= 9
<br>
and date_ty is a single field (min=1, max=1, last=1). <br>
file(min=1, max=10, last=1) when 1 &gt;= input fields &lt;=
10 <br>
and date_ty is two fields (min=2, max=2, last=2). <br>
By default xmlfy continuously iterates through just the
record elements of the root element looking for element
helpers that can fully satisfy the requirements of that
particular <br>
element&rsquo;s schema tree hierarchy for the given input
fields, after which the matching record element is then
checked against its wildcard obligations in the root element
defini&acirc; <br>
tion, and if okay is finally printed. <br>
In match direct mode xmlfy only looks at the element helpers
of the targeted element, and if that element can fully
satisfy the requirements of its schema tree hierarchy for
the <br>
given input fields, is printed in its entirety only once as
the root element.</p>

<p style="margin-top: 1em">To specify xmlfy options inside
a schema file you encapsulate them inside a special token
that is in effect a schema comment. <br>
DTD and XSD example: <br>
&lt;!-- xmlfy-args: -F1 &quot;0 -F2 ABC -q -Q <br>
RNC example: <br>
## xmlfy-args: -F1 &quot;0 -F2 ABC -q -Q <br>
This special token must exist in completed form on just one
line at the left most side, spacing is important, only the
first occurrence is recognised, and ideally it is placed
<br>
somewhere near the top of the schema file. The schema option
syntax is the same as the command line option syntax except
that some options are not allowed e.g. --schema.</p>

<p style="margin-top: 1em">LIMITATIONS <br>
xmlfy has been successfully tested on average hardware with
input records containing over 10,000,000 fields whilst using
a complex schema tree structure and multi level delim&acirc;
<br>
iters.</p>

<p style="margin-top: 1em">Currently the xmlfy schema file
parser is not that sophisticated and exhibits the following
behaviour:</p>

<p style="margin-top: 1em">DTD schema <br>
- Only recognises the &lt;!ELEMENT&gt; directive and ignores
all others. <br>
- The first valid &lt;!ELEMENT&gt; definition becomes the
root element. <br>
- Element fields that don&rsquo;t have an element definition
default to being (#PCDATA). <br>
- Elements defined as (#PCDATA) or (#CDATA) are ignored
causing the referring field to default to (#PCDATA) however
it is good practice to include these elements in order to
fur&acirc; <br>
nish a complete DTD schema. <br>
- Only honours the +, ? and * wildcard tokens. <br>
- At this stage does not honour field group sets () and
or-ing | syntax tokens.</p>

<p style="margin-top: 1em">RNC schema <br>
- Only recognises named directives and ignores all others.
<br>
- The element named &quot;start&quot; becomes the root
element. <br>
- Element fields that don&rsquo;t have an element definition
default to being { text }. <br>
- Elements defined as { text } are ignored causing the
referring field to default to { text } however it is good
practice to include these elements in order to furnish a
complete <br>
RNC schema. <br>
- Only honours the +, ? and * wildcard tokens. <br>
- At this stage does not honour field group sets () and
or-ing | syntax tokens.</p>

<p style="margin-top: 1em">XSD schema <br>
- Only recognises the &lt;schema&gt;, &lt;element&gt;,
&lt;complexType&gt;, &lt;ref&gt;, &lt;sequence&gt;, and
&lt;choice&gt; directives and ignores all others. <br>
- The recognised directives are not fully implemented and
their use should be kept straightforward. <br>
- The first valid &lt;element&gt; definition becomes the
root element. <br>
- Element types that are not of matchable complexType are
treated as &quot;xsi:string&quot; regardless of what type is
specified. <br>
- Only honours the minOccurs=&quot;0&quot;,
maxOccurs=&quot;0&quot; and maxOccurs=&quot;unbounded&quot;
wildcard attributes. <br>
- At this stage does not honour group sets but does do
limited support with choices.</p>

<p style="margin-top: 1em">All schema types <br>
- The fields of the root element define all the level 1
elements (lets call the fields that have their own branch
structure record elements). <br>
- By default fields of the root element that are not record
elements are ignored. Use the match direct option to match
targeted elements in their entirety. <br>
- <br>
The fields of the record elements simply represent other
elements and unlimited element nesting is allowed. <br>
- The field names that are specified in the element
definitions are read from left to right and matched against
a field number calculation on the input fields, and then
matched <br>
again on any wildcard tokens. <br>
- You can wildcard many fields but you should think clearly
about what you are trying to achieve and whether it is at
all possible. For example, the following DTD which is
per&acirc; <br>
fectly suitable for checking for valid XML, will however
prove impossible for xmlfy to shoe-horn input data into DTD
elements a, b and c reliably because more than one field
<br>
has a wildcard token to match none or many input fields.
<br>
&lt;!ELEMENT parent (record)&gt; <br>
&lt;!ELEMENT record (a*, b, c*)&gt; <br>
&lt;!ELEMENT a (#PCDATA)&gt; <br>
&lt;!ELEMENT b (#PCDATA)&gt; <br>
&lt;!ELEMENT c (#PCDATA)&gt; <br>
In the above example xmlfy will allocate ALL input fields to
element &lt;a&gt; and that MAY not be the desired
intention.</p>

<p style="margin-top: 1em">RETURN VALUES <br>
0 Normal exit. <br>
-1 Invalid argument specified. <br>
-2 Error processing schema file contents. <br>
-3 Infinite loop detected when matching input against schema
elements. <br>
-10 Out of memory.</p>

<p style="margin-top: 1em">AUTHOR <br>
Originally written by Arthur Gouros. <br>
This software also contains material derived from Ville
Laurikari&rsquo;s TRE regex library. <br>
This software also contains material derived from the US
Secure Hash Algorithms (RFC4634). <br>
This software also contains material derived from the RSA
Data Security, Inc. MD5 Message-Digest Algorithm.</p>

<p style="margin-top: 1em">LICENSE <br>
BSD License for xmlfy <br>
Copyright &Acirc;&copy; 2008-2013, Arthur Gouros <br>
All rights reserved.</p>

<p style="margin-top: 1em">Redistribution and use in source
and binary forms, with or without modification, are
permitted provided that the following conditions are
met:</p>

<p style="margin-top: 1em">- Redistributions of source code
must retain the above copyright notice, this list of
conditions and the following disclaimer. <br>
- Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials
pro&acirc; <br>
vided with the distribution. <br>
- Neither the name of Arthur Gouros nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior written
permis&acirc; <br>
sion.</p>

<p style="margin-top: 1em">THIS SOFTWARE IS PROVIDED BY THE
COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MER&acirc; <br>
CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, <br>
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER <br>
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN <br>
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

<p style="margin-top: 1em">SEE ALSO <br>
The full documentation of the xmlfy project can be found on
the web at:</p>


<p style="margin-top: 1em">http://xmlfy.sourceforge.net</p>

<p style="margin-top: 1em">The website is updated more
frequently than the man pages and should be considered the
authoritative source of information.</p>

<p style="margin-top: 1em">xmlfy 1.5.6 April 4, 2013
xmlfy(1)</p>
<hr>
</body>
</html>
